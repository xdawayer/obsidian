var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ClaudianPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian29 = require("obsidian");

// src/core/hooks/DiffTrackingHooks.ts
var fs2 = __toESM(require("fs"));
var path2 = __toESM(require("path"));

// src/utils/path.ts
var fs = __toESM(require("fs"));
var os = __toESM(require("os"));
var path = __toESM(require("path"));
function getVaultPath(app) {
  const adapter = app.vault.adapter;
  if ("basePath" in adapter) {
    return adapter.basePath;
  }
  return null;
}
function getEnvValue(key) {
  const hasKey = (name) => Object.prototype.hasOwnProperty.call(process.env, name);
  if (hasKey(key)) {
    return process.env[key];
  }
  if (process.platform !== "win32") {
    return void 0;
  }
  const upper = key.toUpperCase();
  if (hasKey(upper)) {
    return process.env[upper];
  }
  const lower = key.toLowerCase();
  if (hasKey(lower)) {
    return process.env[lower];
  }
  const matchKey = Object.keys(process.env).find((name) => name.toLowerCase() === key.toLowerCase());
  return matchKey ? process.env[matchKey] : void 0;
}
function expandEnvironmentVariables(value) {
  if (!value.includes("%") && !value.includes("$") && !value.includes("!")) {
    return value;
  }
  const isWindows2 = process.platform === "win32";
  let expanded = value;
  expanded = expanded.replace(/%([A-Za-z_][A-Za-z0-9_]*(?:\([A-Za-z0-9_]+\))?[A-Za-z0-9_]*)%/g, (match, name) => {
    const envValue = getEnvValue(name);
    return envValue !== void 0 ? envValue : match;
  });
  if (isWindows2) {
    expanded = expanded.replace(/!([A-Za-z_][A-Za-z0-9_]*)!/g, (match, name) => {
      const envValue = getEnvValue(name);
      return envValue !== void 0 ? envValue : match;
    });
    expanded = expanded.replace(/\$env:([A-Za-z_][A-Za-z0-9_]*)/gi, (match, name) => {
      const envValue = getEnvValue(name);
      return envValue !== void 0 ? envValue : match;
    });
  }
  expanded = expanded.replace(/\$([A-Za-z_][A-Za-z0-9_]*)|\$\{([A-Za-z_][A-Za-z0-9_]*)\}/g, (match, name1, name2) => {
    const key = name1 != null ? name1 : name2;
    if (!key) return match;
    const envValue = getEnvValue(key);
    return envValue !== void 0 ? envValue : match;
  });
  return expanded;
}
function expandHomePath(p) {
  const expanded = expandEnvironmentVariables(p);
  if (expanded === "~") {
    return os.homedir();
  }
  if (expanded.startsWith("~/")) {
    return path.join(os.homedir(), expanded.slice(2));
  }
  if (expanded.startsWith("~\\")) {
    return path.join(os.homedir(), expanded.slice(2));
  }
  return expanded;
}
function stripSurroundingQuotes(value) {
  if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
    return value.slice(1, -1);
  }
  return value;
}
function isPathPlaceholder(value) {
  const trimmed = value.trim();
  if (!trimmed) return false;
  if (trimmed === "$PATH" || trimmed === "${PATH}") return true;
  return trimmed.toUpperCase() === "%PATH%";
}
function parsePathEntries(pathValue) {
  if (!pathValue) {
    return [];
  }
  const delimiter = process.platform === "win32" ? ";" : ":";
  return pathValue.split(delimiter).map((segment) => stripSurroundingQuotes(segment.trim())).filter((segment) => segment.length > 0 && !isPathPlaceholder(segment)).map((segment) => translateMsysPath(expandHomePath(segment)));
}
function dedupePaths(entries) {
  const seen = /* @__PURE__ */ new Set();
  return entries.filter((entry) => {
    const key = process.platform === "win32" ? entry.toLowerCase() : entry;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
}
function findFirstExistingPath(entries, candidates) {
  for (const dir of entries) {
    if (!dir) continue;
    for (const candidate of candidates) {
      const fullPath = path.join(dir, candidate);
      if (isExistingFile(fullPath)) {
        return fullPath;
      }
    }
  }
  return null;
}
function isExistingFile(filePath) {
  try {
    if (fs.existsSync(filePath)) {
      const stat = fs.statSync(filePath);
      return stat.isFile();
    }
  } catch (e) {
  }
  return false;
}
function resolveCliJsNearPathEntry(entry, isWindows2) {
  const directCandidate = path.join(entry, "node_modules", "@anthropic-ai", "claude-code", "cli.js");
  if (isExistingFile(directCandidate)) {
    return directCandidate;
  }
  const baseName = path.basename(entry).toLowerCase();
  if (baseName === "bin") {
    const prefix = path.dirname(entry);
    const candidate = isWindows2 ? path.join(prefix, "node_modules", "@anthropic-ai", "claude-code", "cli.js") : path.join(prefix, "lib", "node_modules", "@anthropic-ai", "claude-code", "cli.js");
    if (isExistingFile(candidate)) {
      return candidate;
    }
  }
  return null;
}
function resolveCliJsFromPathEntries(entries, isWindows2) {
  for (const entry of entries) {
    const candidate = resolveCliJsNearPathEntry(entry, isWindows2);
    if (candidate) {
      return candidate;
    }
  }
  return null;
}
function resolveClaudeFromPathEntries(entries, isWindows2) {
  if (entries.length === 0) {
    return null;
  }
  if (!isWindows2) {
    const unixCandidate = findFirstExistingPath(entries, ["claude"]);
    return unixCandidate;
  }
  const exeCandidate = findFirstExistingPath(entries, ["claude.exe", "claude"]);
  if (exeCandidate) {
    return exeCandidate;
  }
  const cliJsCandidate = resolveCliJsFromPathEntries(entries, isWindows2);
  if (cliJsCandidate) {
    return cliJsCandidate;
  }
  return null;
}
function getNpmGlobalPrefix() {
  if (process.env.npm_config_prefix) {
    return process.env.npm_config_prefix;
  }
  if (process.platform === "win32") {
    const appDataNpm = process.env.APPDATA ? path.join(process.env.APPDATA, "npm") : null;
    if (appDataNpm && fs.existsSync(appDataNpm)) {
      return appDataNpm;
    }
  }
  return null;
}
function getNpmCliJsPaths() {
  const homeDir = os.homedir();
  const isWindows2 = process.platform === "win32";
  const cliJsPaths = [];
  if (isWindows2) {
    cliJsPaths.push(
      path.join(homeDir, "AppData", "Roaming", "npm", "node_modules", "@anthropic-ai", "claude-code", "cli.js")
    );
    const npmPrefix = getNpmGlobalPrefix();
    if (npmPrefix) {
      cliJsPaths.push(
        path.join(npmPrefix, "node_modules", "@anthropic-ai", "claude-code", "cli.js")
      );
    }
    const programFiles = process.env.ProgramFiles || "C:\\Program Files";
    const programFilesX86 = process.env["ProgramFiles(x86)"] || "C:\\Program Files (x86)";
    cliJsPaths.push(
      path.join(programFiles, "nodejs", "node_global", "node_modules", "@anthropic-ai", "claude-code", "cli.js"),
      path.join(programFilesX86, "nodejs", "node_global", "node_modules", "@anthropic-ai", "claude-code", "cli.js")
    );
    cliJsPaths.push(
      path.join("D:", "Program Files", "nodejs", "node_global", "node_modules", "@anthropic-ai", "claude-code", "cli.js")
    );
  } else {
    cliJsPaths.push(
      path.join(homeDir, ".npm-global", "lib", "node_modules", "@anthropic-ai", "claude-code", "cli.js"),
      "/usr/local/lib/node_modules/@anthropic-ai/claude-code/cli.js",
      "/usr/lib/node_modules/@anthropic-ai/claude-code/cli.js"
    );
    if (process.env.npm_config_prefix) {
      cliJsPaths.push(
        path.join(process.env.npm_config_prefix, "lib", "node_modules", "@anthropic-ai", "claude-code", "cli.js")
      );
    }
  }
  return cliJsPaths;
}
function findClaudeCLIPath(pathValue) {
  const homeDir = os.homedir();
  const isWindows2 = process.platform === "win32";
  const customEntries = dedupePaths(parsePathEntries(pathValue));
  if (customEntries.length > 0) {
    const customResolution = resolveClaudeFromPathEntries(customEntries, isWindows2);
    if (customResolution) {
      return customResolution;
    }
  }
  if (isWindows2) {
    const exePaths = [
      path.join(homeDir, ".claude", "local", "claude.exe"),
      path.join(homeDir, "AppData", "Local", "Claude", "claude.exe"),
      path.join(process.env.ProgramFiles || "C:\\Program Files", "Claude", "claude.exe"),
      path.join(process.env["ProgramFiles(x86)"] || "C:\\Program Files (x86)", "Claude", "claude.exe"),
      path.join(homeDir, ".local", "bin", "claude.exe")
    ];
    for (const p of exePaths) {
      if (isExistingFile(p)) {
        return p;
      }
    }
    const cliJsPaths = getNpmCliJsPaths();
    for (const p of cliJsPaths) {
      if (isExistingFile(p)) {
        return p;
      }
    }
  }
  const commonPaths = [
    // Native binary paths (preferred)
    path.join(homeDir, ".claude", "local", "claude"),
    path.join(homeDir, ".local", "bin", "claude"),
    path.join(homeDir, ".volta", "bin", "claude"),
    path.join(homeDir, ".asdf", "shims", "claude"),
    path.join(homeDir, ".asdf", "bin", "claude"),
    "/usr/local/bin/claude",
    "/opt/homebrew/bin/claude",
    path.join(homeDir, "bin", "claude"),
    // npm global bin symlinks (created by npm install -g)
    path.join(homeDir, ".npm-global", "bin", "claude")
  ];
  const npmPrefix = getNpmGlobalPrefix();
  if (npmPrefix) {
    commonPaths.push(path.join(npmPrefix, "bin", "claude"));
  }
  for (const p of commonPaths) {
    if (isExistingFile(p)) {
      return p;
    }
  }
  if (!isWindows2) {
    const cliJsPaths = getNpmCliJsPaths();
    for (const p of cliJsPaths) {
      if (isExistingFile(p)) {
        return p;
      }
    }
  }
  const envEntries = dedupePaths(parsePathEntries(getEnvValue("PATH")));
  if (envEntries.length > 0) {
    const envResolution = resolveClaudeFromPathEntries(envEntries, isWindows2);
    if (envResolution) {
      return envResolution;
    }
  }
  return null;
}
function resolveRealPath(p) {
  var _a;
  const realpathFn = (_a = fs.realpathSync.native) != null ? _a : fs.realpathSync;
  try {
    return realpathFn(p);
  } catch (e) {
    const absolute = path.resolve(p);
    let current = absolute;
    const suffix = [];
    while (true) {
      try {
        if (fs.existsSync(current)) {
          const resolvedExisting = realpathFn(current);
          return suffix.length > 0 ? path.join(resolvedExisting, ...suffix.reverse()) : resolvedExisting;
        }
      } catch (e2) {
      }
      const parent = path.dirname(current);
      if (parent === current) {
        return absolute;
      }
      suffix.push(path.basename(current));
      current = parent;
    }
  }
}
function translateMsysPath(value) {
  var _a;
  if (process.platform !== "win32") {
    return value;
  }
  const msysMatch = value.match(/^\/([a-zA-Z])(\/.*)?$/);
  if (msysMatch) {
    const driveLetter = msysMatch[1].toUpperCase();
    const restOfPath = (_a = msysMatch[2]) != null ? _a : "";
    return `${driveLetter}:${restOfPath.replace(/\//g, "\\")}`;
  }
  return value;
}
function normalizePathBeforeResolution(p) {
  const expanded = expandHomePath(p);
  return translateMsysPath(expanded);
}
function normalizeWindowsPathPrefix(value) {
  if (process.platform !== "win32") {
    return value;
  }
  const normalized = translateMsysPath(value);
  if (normalized.startsWith("\\\\?\\UNC\\")) {
    return `\\\\${normalized.slice("\\\\?\\UNC\\".length)}`;
  }
  if (normalized.startsWith("\\\\?\\")) {
    return normalized.slice("\\\\?\\".length);
  }
  return normalized;
}
function normalizePathForFilesystem(value) {
  if (!value || typeof value !== "string") {
    return "";
  }
  const expanded = normalizePathBeforeResolution(value);
  let normalized = expanded;
  try {
    normalized = process.platform === "win32" ? path.win32.normalize(expanded) : path.normalize(expanded);
  } catch (e) {
    normalized = expanded;
  }
  return normalizeWindowsPathPrefix(normalized);
}
function normalizePathForComparison(value) {
  if (!value || typeof value !== "string") {
    return "";
  }
  const expanded = normalizePathBeforeResolution(value);
  let normalized = expanded;
  try {
    normalized = process.platform === "win32" ? path.win32.normalize(expanded) : path.normalize(expanded);
  } catch (e) {
    normalized = expanded;
  }
  normalized = normalizeWindowsPathPrefix(normalized);
  normalized = normalized.replace(/\\/g, "/").replace(/\/+$/, "");
  return process.platform === "win32" ? normalized.toLowerCase() : normalized;
}
function isPathWithinVault(candidatePath, vaultPath) {
  const vaultReal = normalizePathForComparison(resolveRealPath(vaultPath));
  const normalizedPath = normalizePathBeforeResolution(candidatePath);
  const absCandidate = path.isAbsolute(normalizedPath) ? normalizedPath : path.resolve(vaultPath, normalizedPath);
  const resolvedCandidate = normalizePathForComparison(resolveRealPath(absCandidate));
  return resolvedCandidate === vaultReal || resolvedCandidate.startsWith(vaultReal + "/");
}
function normalizePathForVault(rawPath, vaultPath) {
  if (!rawPath) return null;
  const normalizedRaw = normalizePathForFilesystem(rawPath);
  if (!normalizedRaw) return null;
  if (vaultPath && isPathWithinVault(normalizedRaw, vaultPath)) {
    const absolute = path.isAbsolute(normalizedRaw) ? normalizedRaw : path.resolve(vaultPath, normalizedRaw);
    const relative4 = path.relative(vaultPath, absolute);
    return relative4 ? relative4.replace(/\\/g, "/") : null;
  }
  return normalizedRaw.replace(/\\/g, "/");
}
function getPathAccessType(candidatePath, allowedContextPaths, allowedExportPaths, vaultPath) {
  if (!candidatePath) return "none";
  const vaultReal = normalizePathForComparison(resolveRealPath(vaultPath));
  const normalizedCandidate = normalizePathBeforeResolution(candidatePath);
  const absCandidate = path.isAbsolute(normalizedCandidate) ? normalizedCandidate : path.resolve(vaultPath, normalizedCandidate);
  const resolvedCandidate = normalizePathForComparison(resolveRealPath(absCandidate));
  if (resolvedCandidate === vaultReal || resolvedCandidate.startsWith(vaultReal + "/")) {
    return "vault";
  }
  const claudeDir = normalizePathForComparison(resolveRealPath(path.join(os.homedir(), ".claude")));
  if (resolvedCandidate === claudeDir || resolvedCandidate.startsWith(claudeDir + "/")) {
    return "vault";
  }
  const roots = /* @__PURE__ */ new Map();
  const addRoot = (rawPath, kind) => {
    var _a;
    const trimmed = rawPath.trim();
    if (!trimmed) return;
    const normalized = normalizePathBeforeResolution(trimmed);
    const resolved = normalizePathForComparison(resolveRealPath(normalized));
    const existing = (_a = roots.get(resolved)) != null ? _a : { context: false, export: false };
    existing[kind] = true;
    roots.set(resolved, existing);
  };
  for (const contextPath of allowedContextPaths != null ? allowedContextPaths : []) {
    addRoot(contextPath, "context");
  }
  for (const exportPath of allowedExportPaths != null ? allowedExportPaths : []) {
    addRoot(exportPath, "export");
  }
  let bestRoot = null;
  let bestFlags = null;
  for (const [root2, flags] of roots) {
    if (resolvedCandidate === root2 || resolvedCandidate.startsWith(root2 + "/")) {
      if (!bestRoot || root2.length > bestRoot.length) {
        bestRoot = root2;
        bestFlags = flags;
      }
    }
  }
  if (!bestRoot || !bestFlags) return "none";
  if (bestFlags.context && bestFlags.export) return "readwrite";
  if (bestFlags.context) return "context";
  if (bestFlags.export) return "export";
  return "none";
}

// src/core/tools/toolNames.ts
var TOOL_AGENT_OUTPUT = "AgentOutputTool";
var TOOL_BASH = "Bash";
var TOOL_BASH_OUTPUT = "BashOutput";
var TOOL_EDIT = "Edit";
var TOOL_GLOB = "Glob";
var TOOL_GREP = "Grep";
var TOOL_KILL_SHELL = "KillShell";
var TOOL_LS = "LS";
var TOOL_LIST_MCP_RESOURCES = "ListMcpResources";
var TOOL_MCP = "Mcp";
var TOOL_NOTEBOOK_EDIT = "NotebookEdit";
var TOOL_READ = "Read";
var TOOL_READ_MCP_RESOURCE = "ReadMcpResource";
var TOOL_SKILL = "Skill";
var TOOL_TASK = "Task";
var TOOL_TODO_WRITE = "TodoWrite";
var TOOL_WEB_FETCH = "WebFetch";
var TOOL_WEB_SEARCH = "WebSearch";
var TOOL_WRITE = "Write";
var EDIT_TOOLS = [TOOL_WRITE, TOOL_EDIT, TOOL_NOTEBOOK_EDIT];
var WRITE_EDIT_TOOLS = [TOOL_WRITE, TOOL_EDIT];
var FILE_TOOLS = [
  TOOL_READ,
  TOOL_WRITE,
  TOOL_EDIT,
  TOOL_GLOB,
  TOOL_GREP,
  TOOL_LS,
  TOOL_NOTEBOOK_EDIT,
  TOOL_BASH
];
var READ_ONLY_TOOLS = [
  TOOL_READ,
  TOOL_GREP,
  TOOL_GLOB,
  TOOL_LS,
  TOOL_WEB_SEARCH,
  TOOL_WEB_FETCH
];
function isEditTool(toolName) {
  return EDIT_TOOLS.includes(toolName);
}
function isWriteEditTool(toolName) {
  return WRITE_EDIT_TOOLS.includes(toolName);
}
function isFileTool(toolName) {
  return FILE_TOOLS.includes(toolName);
}
function isReadOnlyTool(toolName) {
  return READ_ONLY_TOOLS.includes(toolName);
}

// src/core/hooks/DiffTrackingHooks.ts
var MAX_DIFF_SIZE = 100 * 1024;
var DiffStore = class {
  constructor() {
    this.originalContents = /* @__PURE__ */ new Map();
    this.pendingDiffData = /* @__PURE__ */ new Map();
  }
  getOriginalContents() {
    return this.originalContents;
  }
  getPendingDiffData() {
    return this.pendingDiffData;
  }
  getDiffData(toolUseId) {
    const data = this.pendingDiffData.get(toolUseId);
    if (data) {
      this.pendingDiffData.delete(toolUseId);
    }
    return data;
  }
  clear() {
    this.originalContents.clear();
    this.pendingDiffData.clear();
  }
};
var diffStore = new DiffStore();
function getDiffData(toolUseId) {
  return diffStore.getDiffData(toolUseId);
}
function clearDiffState() {
  diffStore.clear();
}
function createFileHashPreHook(vaultPath) {
  const originalContents = diffStore.getOriginalContents();
  return {
    matcher: "Write|Edit|NotebookEdit",
    hooks: [
      async (hookInput, toolUseId, _options) => {
        const input = hookInput;
        if (input.tool_name === TOOL_WRITE || input.tool_name === TOOL_EDIT) {
          const rawPath = input.tool_input.file_path;
          const filePath = typeof rawPath === "string" && rawPath ? rawPath : void 0;
          if (filePath && vaultPath && toolUseId) {
            const normalizedPath = normalizePathForFilesystem(filePath);
            const fullPath = path2.isAbsolute(normalizedPath) ? normalizedPath : path2.join(vaultPath, normalizedPath);
            try {
              if (fs2.existsSync(fullPath)) {
                const stats = fs2.statSync(fullPath);
                if (stats.size <= MAX_DIFF_SIZE) {
                  const content = fs2.readFileSync(fullPath, "utf-8");
                  originalContents.set(toolUseId, { filePath, content });
                } else {
                  originalContents.set(toolUseId, { filePath, content: null, skippedReason: "too_large" });
                }
              } else {
                originalContents.set(toolUseId, { filePath, content: "" });
              }
            } catch (e) {
              originalContents.set(toolUseId, { filePath, content: null, skippedReason: "unavailable" });
            }
          }
        }
        return { continue: true };
      }
    ]
  };
}
function createFileHashPostHook(vaultPath, postCallback) {
  const originalContents = diffStore.getOriginalContents();
  const pendingDiffData = diffStore.getPendingDiffData();
  return {
    matcher: "Write|Edit|NotebookEdit",
    hooks: [
      async (hookInput, toolUseId, _options) => {
        var _a, _b, _c;
        const input = hookInput;
        const isError = (_b = (_a = input.tool_result) == null ? void 0 : _a.is_error) != null ? _b : false;
        if ((input.tool_name === TOOL_WRITE || input.tool_name === TOOL_EDIT) && toolUseId) {
          const originalEntry = originalContents.get(toolUseId);
          const rawPath = input.tool_input.file_path;
          const filePath = typeof rawPath === "string" && rawPath ? rawPath : originalEntry == null ? void 0 : originalEntry.filePath;
          if (!isError && filePath && vaultPath) {
            const normalizedPath = normalizePathForFilesystem(filePath);
            const fullPath = path2.isAbsolute(normalizedPath) ? normalizedPath : path2.join(vaultPath, normalizedPath);
            let diffData;
            if ((originalEntry == null ? void 0 : originalEntry.content) === null) {
              diffData = { filePath, skippedReason: (_c = originalEntry.skippedReason) != null ? _c : "unavailable" };
            } else {
              try {
                if (fs2.existsSync(fullPath)) {
                  const stats = fs2.statSync(fullPath);
                  if (stats.size <= MAX_DIFF_SIZE) {
                    const newContent = fs2.readFileSync(fullPath, "utf-8");
                    if (originalEntry && originalEntry.content !== void 0) {
                      diffData = {
                        filePath,
                        originalContent: originalEntry.content,
                        newContent
                      };
                    } else {
                      diffData = { filePath, skippedReason: "unavailable" };
                    }
                  } else {
                    diffData = { filePath, skippedReason: "too_large" };
                  }
                } else {
                  diffData = { filePath, skippedReason: "unavailable" };
                }
              } catch (e) {
                diffData = { filePath, skippedReason: "unavailable" };
              }
            }
            if (diffData) {
              pendingDiffData.set(toolUseId, diffData);
            }
          }
          originalContents.delete(toolUseId);
        }
        await (postCallback == null ? void 0 : postCallback.trackEditedFile(input.tool_name, input.tool_input, isError));
        return { continue: true };
      }
    ]
  };
}

// src/core/hooks/SecurityHooks.ts
var import_obsidian = require("obsidian");

// src/core/security/BashPathValidator.ts
var path3 = __toESM(require("path"));
function tokenizeBashCommand(command) {
  var _a;
  const tokens = [];
  const tokenRegex = /(['"`])(.*?)\1|[^\s]+/g;
  let match;
  while ((match = tokenRegex.exec(command)) !== null) {
    const token = (_a = match[2]) != null ? _a : match[0];
    const cleaned = token.trim();
    if (!cleaned) continue;
    tokens.push(cleaned);
  }
  return tokens;
}
function splitBashTokensIntoSegments(tokens) {
  const separators = /* @__PURE__ */ new Set(["&&", "||", ";", "|"]);
  const segments = [];
  let current = [];
  for (const token of tokens) {
    if (separators.has(token)) {
      if (current.length > 0) {
        segments.push(current);
        current = [];
      }
      continue;
    }
    current.push(token);
  }
  if (current.length > 0) {
    segments.push(current);
  }
  return segments;
}
function getBashSegmentCommandName(segment) {
  const wrappers = /* @__PURE__ */ new Set(["command", "env", "sudo"]);
  let cmdIndex = 0;
  while (cmdIndex < segment.length) {
    const token = segment[cmdIndex];
    if (wrappers.has(token)) {
      cmdIndex += 1;
      continue;
    }
    if (!token.startsWith("-") && token.includes("=")) {
      cmdIndex += 1;
      continue;
    }
    break;
  }
  const rawCmd = segment[cmdIndex] || "";
  const cmdName = path3.basename(rawCmd);
  return { cmdName, cmdIndex };
}
function isBashOutputRedirectOperator(token) {
  return token === ">" || token === ">>" || token === "1>" || token === "1>>" || token === "2>" || token === "2>>" || token === "&>" || token === "&>>" || token === ">|";
}
function isBashInputRedirectOperator(token) {
  return token === "<" || token === "<<" || token === "0<" || token === "0<<";
}
function isBashOutputOptionExpectingValue(token) {
  return token === "-o" || token === "--output" || token === "--out" || token === "--outfile" || token === "--output-file";
}
function cleanPathToken(raw) {
  let token = raw.trim();
  if (!token) return null;
  if (token.startsWith('"') && token.endsWith('"') || token.startsWith("'") && token.endsWith("'") || token.startsWith("`") && token.endsWith("`")) {
    token = token.slice(1, -1).trim();
  }
  while (token.startsWith("(") || token.startsWith("[") || token.startsWith("{")) {
    token = token.slice(1).trim();
  }
  while (token.endsWith(")") || token.endsWith("]") || token.endsWith("}") || token.endsWith(";") || token.endsWith(",")) {
    token = token.slice(0, -1).trim();
  }
  if (!token) return null;
  if (token.startsWith('"') && token.endsWith('"') || token.startsWith("'") && token.endsWith("'") || token.startsWith("`") && token.endsWith("`")) {
    token = token.slice(1, -1).trim();
  }
  if (!token) return null;
  if (token === "." || token === "/" || token === "\\" || token === "--") return null;
  return token;
}
function isPathLikeToken(token) {
  const cleaned = token.trim();
  if (!cleaned) return false;
  if (cleaned === "." || cleaned === "/" || cleaned === "\\" || cleaned === "--") return false;
  const isWindows2 = process.platform === "win32";
  return (
    // Home directory paths (Unix and Windows style)
    cleaned === "~" || cleaned.startsWith("~/") || isWindows2 && cleaned.startsWith("~\\") || // Relative paths
    cleaned.startsWith("./") || cleaned.startsWith("../") || cleaned === ".." || isWindows2 && (cleaned.startsWith(".\\") || cleaned.startsWith("..\\")) || // Absolute paths (Unix)
    cleaned.startsWith("/") || // Absolute paths (Windows drive letters)
    isWindows2 && /^[A-Za-z]:[\\/]/.test(cleaned) || // Absolute paths (Windows UNC)
    isWindows2 && (cleaned.startsWith("\\\\") || cleaned.startsWith("//")) || // Contains path separators
    cleaned.includes("/") || isWindows2 && cleaned.includes("\\")
  );
}
function checkBashPathAccess(candidate, access, context) {
  const cleaned = cleanPathToken(candidate);
  if (!cleaned) return null;
  const accessType = context.getPathAccessType(cleaned);
  if (accessType === "vault" || accessType === "readwrite") {
    return null;
  }
  if (accessType === "context") {
    return null;
  }
  if (accessType === "export") {
    return access === "write" ? null : { type: "export_path_read", path: cleaned };
  }
  return { type: "outside_vault", path: cleaned };
}
function findBashPathViolationInSegment(segment, context) {
  if (segment.length === 0) return null;
  const { cmdName, cmdIndex } = getBashSegmentCommandName(segment);
  const destinationCommands = /* @__PURE__ */ new Set(["cp", "mv", "rsync"]);
  let destinationTokenIndex = null;
  if (destinationCommands.has(cmdName)) {
    const pathArgIndices = [];
    let seenDoubleDash = false;
    for (let i = cmdIndex + 1; i < segment.length; i += 1) {
      const token = segment[i];
      if (!seenDoubleDash && token === "--") {
        seenDoubleDash = true;
        continue;
      }
      if (!seenDoubleDash && token.startsWith("-")) {
        continue;
      }
      if (isPathLikeToken(token)) {
        pathArgIndices.push(i);
      }
    }
    if (pathArgIndices.length > 0) {
      destinationTokenIndex = pathArgIndices[pathArgIndices.length - 1];
    }
  }
  let expectWriteNext = false;
  for (let i = 0; i < segment.length; i += 1) {
    const token = segment[i];
    if (isBashOutputRedirectOperator(token)) {
      expectWriteNext = true;
      continue;
    }
    if (isBashInputRedirectOperator(token)) {
      expectWriteNext = false;
      continue;
    }
    if (isBashOutputOptionExpectingValue(token)) {
      expectWriteNext = true;
      continue;
    }
    const embeddedOutputRedirect = token.match(/^(?:&>>|&>|\d*>>|\d*>\||\d*>|>>|>\||>)(.+)$/);
    if (embeddedOutputRedirect) {
      const violation2 = checkBashPathAccess(embeddedOutputRedirect[1], "write", context);
      if (violation2) return violation2;
      continue;
    }
    const embeddedInputRedirect = token.match(/^(?:\d*<<|\d*<|<<|<)(.+)$/);
    if (embeddedInputRedirect) {
      const violation2 = checkBashPathAccess(embeddedInputRedirect[1], "read", context);
      if (violation2) return violation2;
      continue;
    }
    const embeddedLongOutput = token.match(/^--(?:output|out|outfile|output-file)=(.+)$/);
    if (embeddedLongOutput) {
      const violation2 = checkBashPathAccess(embeddedLongOutput[1], "write", context);
      if (violation2) return violation2;
      continue;
    }
    const embeddedShortOutput = token.match(/^-o(.+)$/);
    if (embeddedShortOutput) {
      const violation2 = checkBashPathAccess(embeddedShortOutput[1], "write", context);
      if (violation2) return violation2;
      continue;
    }
    const eqIndex = token.indexOf("=");
    if (eqIndex > 0) {
      const key = token.slice(0, eqIndex);
      const value = token.slice(eqIndex + 1);
      if (key.startsWith("-") && isPathLikeToken(value)) {
        const violation2 = checkBashPathAccess(value, "read", context);
        if (violation2) return violation2;
      }
    }
    if (!isPathLikeToken(token)) {
      expectWriteNext = false;
      continue;
    }
    const access = i === destinationTokenIndex || expectWriteNext ? "write" : "read";
    const violation = checkBashPathAccess(token, access, context);
    if (violation) return violation;
    expectWriteNext = false;
  }
  return null;
}
function findBashCommandPathViolation(command, context) {
  if (!command) return null;
  const tokens = tokenizeBashCommand(command);
  const segments = splitBashTokensIntoSegments(tokens);
  for (const segment of segments) {
    const violation = findBashPathViolationInSegment(segment, context);
    if (violation) {
      return violation;
    }
  }
  return null;
}

// src/core/security/BlocklistChecker.ts
function isCommandBlocked(command, patterns, enableBlocklist) {
  if (!enableBlocklist) {
    return false;
  }
  return patterns.some((pattern) => {
    try {
      return new RegExp(pattern, "i").test(command);
    } catch (e) {
      return command.toLowerCase().includes(pattern.toLowerCase());
    }
  });
}

// src/core/tools/toolInput.ts
function getPathFromToolInput(toolName, toolInput) {
  switch (toolName) {
    case TOOL_READ:
    case TOOL_WRITE:
    case TOOL_EDIT:
    case TOOL_NOTEBOOK_EDIT:
      return toolInput.file_path || toolInput.notebook_path || null;
    case TOOL_GLOB:
      return toolInput.path || toolInput.pattern || null;
    case TOOL_GREP:
      return toolInput.path || null;
    case TOOL_LS:
      return toolInput.path || null;
    default:
      return null;
  }
}

// src/core/types/chat.ts
var VIEW_TYPE_CLAUDIAN = "claudian-view";

// src/core/types/models.ts
var DEFAULT_CLAUDE_MODELS = [
  { value: "haiku", label: "Haiku", description: "Fast and efficient" },
  { value: "sonnet", label: "Sonnet", description: "Balanced performance" },
  { value: "opus", label: "Opus", description: "Most capable" }
];
var BETA_1M_CONTEXT = "context-1m-2025-08-07";
function resolveModelWithBetas(model, include1MBeta = false) {
  if (!model || typeof model !== "string") {
    throw new Error("resolveModelWithBetas: model is required and must be a non-empty string");
  }
  if (include1MBeta) {
    return {
      model,
      betas: [BETA_1M_CONTEXT]
    };
  }
  return { model };
}
var THINKING_BUDGETS = [
  { value: "off", label: "Off", tokens: 0 },
  { value: "low", label: "Low", tokens: 4e3 },
  { value: "medium", label: "Med", tokens: 8e3 },
  { value: "high", label: "High", tokens: 16e3 },
  { value: "xhigh", label: "Ultra", tokens: 32e3 }
];
var DEFAULT_THINKING_BUDGET = {
  "haiku": "off",
  "sonnet": "low",
  "opus": "medium"
};

// src/core/types/settings.ts
var UNIX_BLOCKED_COMMANDS = [
  "rm -rf",
  "chmod 777",
  "chmod -R 777"
];
var WINDOWS_BLOCKED_COMMANDS = [
  // CMD commands
  "del /s /q",
  "rd /s /q",
  "rmdir /s /q",
  "format",
  "diskpart",
  // PowerShell Remove-Item variants (full and abbreviated flags)
  "Remove-Item -Recurse -Force",
  "Remove-Item -Force -Recurse",
  "Remove-Item -r -fo",
  "Remove-Item -fo -r",
  "Remove-Item -Recurse",
  "Remove-Item -r",
  // PowerShell aliases for Remove-Item
  "ri -Recurse",
  "ri -r",
  "ri -Force",
  "ri -fo",
  "rm -r -fo",
  "rm -Recurse",
  "rm -Force",
  "del -Recurse",
  "del -Force",
  "erase -Recurse",
  "erase -Force",
  // PowerShell directory removal aliases
  "rd -Recurse",
  "rmdir -Recurse",
  // Dangerous disk/volume commands
  "Format-Volume",
  "Clear-Disk",
  "Initialize-Disk",
  "Remove-Partition"
];
function getDefaultBlockedCommands() {
  return {
    unix: [...UNIX_BLOCKED_COMMANDS],
    windows: [...WINDOWS_BLOCKED_COMMANDS]
  };
}
function getCurrentPlatformKey() {
  return process.platform === "win32" ? "windows" : "unix";
}
function getCurrentPlatformBlockedCommands(commands) {
  return commands[getCurrentPlatformKey()];
}
function getBashToolBlockedCommands(commands) {
  if (process.platform === "win32") {
    return Array.from(/* @__PURE__ */ new Set([...commands.unix, ...commands.windows]));
  }
  return getCurrentPlatformBlockedCommands(commands);
}
function getCliPlatformKey() {
  switch (process.platform) {
    case "darwin":
      return "macos";
    case "win32":
      return "windows";
    default:
      return "linux";
  }
}
function createPermissionRule(rule) {
  return rule;
}
var DEFAULT_SETTINGS = {
  // User preferences
  userName: "",
  // Security
  enableBlocklist: true,
  blockedCommands: getDefaultBlockedCommands(),
  permissionMode: "yolo",
  // Model & thinking
  model: "haiku",
  thinkingBudget: "off",
  enableAutoTitleGeneration: true,
  titleGenerationModel: "",
  // Empty = auto (ANTHROPIC_DEFAULT_HAIKU_MODEL or claude-haiku-4-5)
  show1MModel: false,
  // Hidden by default
  // Content settings
  excludedTags: [],
  mediaFolder: "",
  systemPrompt: "",
  allowedExportPaths: ["~/Desktop", "~/Downloads"],
  persistentExternalContextPaths: [],
  // Environment
  environmentVariables: "",
  envSnippets: [],
  // UI settings
  keyboardNavigation: {
    scrollUpKey: "w",
    scrollDownKey: "s",
    focusInputKey: "i"
  },
  // Internationalization
  locale: "en",
  // Default to English
  // CLI paths
  claudeCliPath: "",
  // Legacy field (empty = not migrated)
  claudeCliPathsByHost: {},
  // Per-device paths keyed by hostname
  loadUserClaudeSettings: true,
  // Default on for compatibility
  lastClaudeModel: "haiku",
  lastCustomModel: "",
  lastEnvHash: "",
  // Slash commands (loaded separately)
  slashCommands: [],
  // Claude Code plugins
  enabledPlugins: [],
  // UI preferences
  maxTabs: 3
  // Default to 3 tabs (safe resource usage)
};
var DEFAULT_CC_SETTINGS = {
  $schema: "https://json.schemastore.org/claude-code-settings.json",
  permissions: {
    allow: [],
    deny: [],
    ask: []
  }
};
var DEFAULT_CC_PERMISSIONS = {
  allow: [],
  deny: [],
  ask: []
};
function legacyPermissionToCCRule(legacy) {
  const pattern = legacy.pattern.trim();
  if (!pattern || pattern === "*" || pattern.startsWith("{")) {
    return createPermissionRule(legacy.toolName);
  }
  return createPermissionRule(`${legacy.toolName}(${pattern})`);
}
function legacyPermissionsToCCPermissions(legacyPermissions) {
  const allow = [];
  for (const perm of legacyPermissions) {
    if (perm.scope === "always") {
      allow.push(legacyPermissionToCCRule(perm));
    }
  }
  return {
    allow: [...new Set(allow)],
    // Deduplicate
    deny: [],
    ask: []
  };
}
function parseCCPermissionRule(rule) {
  const match = rule.match(/^(\w+)(?:\((.+)\))?$/);
  if (!match) {
    return { tool: rule };
  }
  const [, tool, pattern] = match;
  return { tool, pattern };
}

// src/utils/env.ts
var fs3 = __toESM(require("fs"));
var os2 = __toESM(require("os"));
var path4 = __toESM(require("path"));
var isWindows = process.platform === "win32";
var PATH_SEPARATOR = isWindows ? ";" : ":";
var NODE_EXECUTABLE = isWindows ? "node.exe" : "node";
function getHomeDir() {
  return process.env.HOME || process.env.USERPROFILE || "";
}
function getExtraBinaryPaths() {
  const home = getHomeDir();
  if (isWindows) {
    const paths = [];
    const localAppData = process.env.LOCALAPPDATA;
    const appData = process.env.APPDATA;
    const programFiles = process.env.ProgramFiles || "C:\\Program Files";
    const programFilesX86 = process.env["ProgramFiles(x86)"] || "C:\\Program Files (x86)";
    const programData = process.env.ProgramData || "C:\\ProgramData";
    if (appData) {
      paths.push(path4.join(appData, "npm"));
    }
    if (localAppData) {
      paths.push(path4.join(localAppData, "Programs", "nodejs"));
      paths.push(path4.join(localAppData, "Programs", "node"));
    }
    paths.push(path4.join(programFiles, "nodejs"));
    paths.push(path4.join(programFilesX86, "nodejs"));
    const nvmSymlink = process.env.NVM_SYMLINK;
    if (nvmSymlink) {
      paths.push(nvmSymlink);
    }
    const nvmHome = process.env.NVM_HOME;
    if (nvmHome) {
      paths.push(nvmHome);
    } else if (appData) {
      paths.push(path4.join(appData, "nvm"));
    }
    const voltaHome = process.env.VOLTA_HOME;
    if (voltaHome) {
      paths.push(path4.join(voltaHome, "bin"));
    } else if (home) {
      paths.push(path4.join(home, ".volta", "bin"));
    }
    const fnmMultishell = process.env.FNM_MULTISHELL_PATH;
    if (fnmMultishell) {
      paths.push(fnmMultishell);
    }
    const fnmDir = process.env.FNM_DIR;
    if (fnmDir) {
      paths.push(fnmDir);
    } else if (localAppData) {
      paths.push(path4.join(localAppData, "fnm"));
    }
    const chocolateyInstall = process.env.ChocolateyInstall;
    if (chocolateyInstall) {
      paths.push(path4.join(chocolateyInstall, "bin"));
    } else {
      paths.push(path4.join(programData, "chocolatey", "bin"));
    }
    const scoopDir = process.env.SCOOP;
    if (scoopDir) {
      paths.push(path4.join(scoopDir, "shims"));
      paths.push(path4.join(scoopDir, "apps", "nodejs", "current", "bin"));
      paths.push(path4.join(scoopDir, "apps", "nodejs", "current"));
    } else if (home) {
      paths.push(path4.join(home, "scoop", "shims"));
      paths.push(path4.join(home, "scoop", "apps", "nodejs", "current", "bin"));
      paths.push(path4.join(home, "scoop", "apps", "nodejs", "current"));
    }
    paths.push(path4.join(programFiles, "Docker", "Docker", "resources", "bin"));
    if (home) {
      paths.push(path4.join(home, ".local", "bin"));
    }
    return paths;
  } else {
    const paths = [
      "/usr/local/bin",
      "/opt/homebrew/bin",
      // macOS ARM Homebrew
      "/usr/bin",
      "/bin"
    ];
    const voltaHome = process.env.VOLTA_HOME;
    if (voltaHome) {
      paths.push(path4.join(voltaHome, "bin"));
    }
    const asdfRoot = process.env.ASDF_DATA_DIR || process.env.ASDF_DIR;
    if (asdfRoot) {
      paths.push(path4.join(asdfRoot, "shims"));
      paths.push(path4.join(asdfRoot, "bin"));
    }
    const fnmMultishell = process.env.FNM_MULTISHELL_PATH;
    if (fnmMultishell) {
      paths.push(fnmMultishell);
    }
    const fnmDir = process.env.FNM_DIR;
    if (fnmDir) {
      paths.push(fnmDir);
    }
    if (home) {
      paths.push(path4.join(home, ".local", "bin"));
      paths.push(path4.join(home, ".docker", "bin"));
      paths.push(path4.join(home, ".volta", "bin"));
      paths.push(path4.join(home, ".asdf", "shims"));
      paths.push(path4.join(home, ".asdf", "bin"));
      paths.push(path4.join(home, ".fnm"));
      const nvmBin = process.env.NVM_BIN;
      if (nvmBin) {
        paths.push(nvmBin);
      }
    }
    return paths;
  }
}
function findNodeDirectory() {
  const searchPaths = getExtraBinaryPaths();
  const currentPath = process.env.PATH || "";
  const pathDirs = parsePathEntries(currentPath);
  const allPaths = [...searchPaths, ...pathDirs];
  for (const dir of allPaths) {
    if (!dir) continue;
    try {
      const nodePath = path4.join(dir, NODE_EXECUTABLE);
      if (fs3.existsSync(nodePath)) {
        const stat = fs3.statSync(nodePath);
        if (stat.isFile()) {
          return dir;
        }
      }
    } catch (e) {
    }
  }
  return null;
}
function cliPathRequiresNode(cliPath) {
  const jsExtensions = [".js", ".mjs", ".cjs", ".ts", ".tsx", ".jsx"];
  const lower = cliPath.toLowerCase();
  if (jsExtensions.some((ext) => lower.endsWith(ext))) {
    return true;
  }
  try {
    if (!fs3.existsSync(cliPath)) {
      return false;
    }
    const stat = fs3.statSync(cliPath);
    if (!stat.isFile()) {
      return false;
    }
    let fd = null;
    try {
      fd = fs3.openSync(cliPath, "r");
      const buffer = Buffer.alloc(200);
      const bytesRead = fs3.readSync(fd, buffer, 0, buffer.length, 0);
      const header = buffer.slice(0, bytesRead).toString("utf8");
      return header.startsWith("#!") && header.toLowerCase().includes("node");
    } finally {
      if (fd !== null) {
        try {
          fs3.closeSync(fd);
        } catch (e) {
        }
      }
    }
  } catch (e) {
    return false;
  }
}
function getEnhancedPath(additionalPaths, cliPath) {
  const extraPaths = getExtraBinaryPaths().filter((p) => p);
  const currentPath = process.env.PATH || "";
  const segments = [];
  if (additionalPaths) {
    segments.push(...parsePathEntries(additionalPaths));
  }
  let cliDirHasNode = false;
  if (cliPath) {
    try {
      const cliDir = path4.dirname(cliPath);
      const nodeInCliDir = path4.join(cliDir, NODE_EXECUTABLE);
      if (fs3.existsSync(nodeInCliDir)) {
        const stat = fs3.statSync(nodeInCliDir);
        if (stat.isFile()) {
          segments.push(cliDir);
          cliDirHasNode = true;
        }
      }
    } catch (e) {
    }
  }
  if (cliPath && cliPathRequiresNode(cliPath) && !cliDirHasNode) {
    const nodeDir = findNodeDirectory();
    if (nodeDir) {
      segments.push(nodeDir);
    }
  }
  segments.push(...extraPaths);
  if (currentPath) {
    segments.push(...parsePathEntries(currentPath));
  }
  const seen = /* @__PURE__ */ new Set();
  const unique = segments.filter((p) => {
    const normalized = isWindows ? p.toLowerCase() : p;
    if (seen.has(normalized)) return false;
    seen.add(normalized);
    return true;
  });
  return unique.join(PATH_SEPARATOR);
}
function parseEnvironmentVariables(input) {
  const result = {};
  for (const line of input.split(/\r?\n/)) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) continue;
    const eqIndex = trimmed.indexOf("=");
    if (eqIndex > 0) {
      const key = trimmed.substring(0, eqIndex).trim();
      let value = trimmed.substring(eqIndex + 1).trim();
      if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
        value = value.slice(1, -1);
      }
      if (key) {
        result[key] = value;
      }
    }
  }
  return result;
}
function getModelsFromEnvironment(envVars) {
  const modelMap = /* @__PURE__ */ new Map();
  const modelEnvEntries = [
    { type: "model", envKey: "ANTHROPIC_MODEL" },
    { type: "opus", envKey: "ANTHROPIC_DEFAULT_OPUS_MODEL" },
    { type: "sonnet", envKey: "ANTHROPIC_DEFAULT_SONNET_MODEL" },
    { type: "haiku", envKey: "ANTHROPIC_DEFAULT_HAIKU_MODEL" }
  ];
  for (const { type, envKey } of modelEnvEntries) {
    const modelValue = envVars[envKey];
    if (modelValue) {
      const label = modelValue.includes("/") ? modelValue.split("/").pop() || modelValue : modelValue.replace(/-/g, " ").replace(/\b\w/g, (l) => l.toUpperCase());
      if (!modelMap.has(modelValue)) {
        modelMap.set(modelValue, { types: [type], label });
      } else {
        modelMap.get(modelValue).types.push(type);
      }
    }
  }
  const models = [];
  const typePriority = { "model": 4, "haiku": 3, "sonnet": 2, "opus": 1 };
  const sortedEntries = Array.from(modelMap.entries()).sort(([, aInfo], [, bInfo]) => {
    const aPriority = Math.max(...aInfo.types.map((t2) => typePriority[t2] || 0));
    const bPriority = Math.max(...bInfo.types.map((t2) => typePriority[t2] || 0));
    return bPriority - aPriority;
  });
  for (const [modelValue, info] of sortedEntries) {
    const sortedTypes = info.types.sort(
      (a, b) => (typePriority[b] || 0) - (typePriority[a] || 0)
    );
    models.push({
      value: modelValue,
      label: info.label,
      description: `Custom model (${sortedTypes.join(", ")})`
    });
  }
  return models;
}
function getCurrentModelFromEnvironment(envVars) {
  if (envVars.ANTHROPIC_MODEL) {
    return envVars.ANTHROPIC_MODEL;
  }
  if (envVars.ANTHROPIC_DEFAULT_HAIKU_MODEL) {
    return envVars.ANTHROPIC_DEFAULT_HAIKU_MODEL;
  }
  if (envVars.ANTHROPIC_DEFAULT_SONNET_MODEL) {
    return envVars.ANTHROPIC_DEFAULT_SONNET_MODEL;
  }
  if (envVars.ANTHROPIC_DEFAULT_OPUS_MODEL) {
    return envVars.ANTHROPIC_DEFAULT_OPUS_MODEL;
  }
  return null;
}
function getHostnameKey() {
  return os2.hostname();
}

// src/core/types/mcp.ts
function getMcpServerType(config2) {
  if (config2.type === "sse") return "sse";
  if (config2.type === "http") return "http";
  if ("url" in config2) return "http";
  return "stdio";
}
function isValidMcpServerConfig(obj) {
  if (!obj || typeof obj !== "object") return false;
  const config2 = obj;
  if (config2.command && typeof config2.command === "string") return true;
  if (config2.url && typeof config2.url === "string") return true;
  return false;
}
var DEFAULT_MCP_SERVER = {
  enabled: true,
  contextSaving: true
};

// src/core/hooks/SecurityHooks.ts
function createBlocklistHook(getContext) {
  return {
    matcher: TOOL_BASH,
    hooks: [
      async (hookInput) => {
        var _a;
        const input = hookInput;
        const command = ((_a = input.tool_input) == null ? void 0 : _a.command) || "";
        const context = getContext();
        const bashToolCommands = getBashToolBlockedCommands(context.blockedCommands);
        if (isCommandBlocked(command, bashToolCommands, context.enableBlocklist)) {
          new import_obsidian.Notice("Command blocked by security policy");
          return {
            continue: false,
            hookSpecificOutput: {
              hookEventName: "PreToolUse",
              permissionDecision: "deny",
              permissionDecisionReason: `Command blocked by blocklist: ${command}`
            }
          };
        }
        return { continue: true };
      }
    ]
  };
}
function createVaultRestrictionHook(context) {
  return {
    hooks: [
      async (hookInput) => {
        var _a;
        const input = hookInput;
        const toolName = input.tool_name;
        if (toolName === TOOL_BASH) {
          const command = ((_a = input.tool_input) == null ? void 0 : _a.command) || "";
          const pathCheckContext = {
            getPathAccessType: (p) => context.getPathAccessType(p)
          };
          const violation = findBashCommandPathViolation(command, pathCheckContext);
          if (violation) {
            const reason = violation.type === "export_path_read" ? `Access denied: Command path "${violation.path}" is in an allowed export directory, but export paths are write-only.` : `Access denied: Command path "${violation.path}" is outside the vault. Agent is restricted to vault directory only.`;
            return {
              continue: false,
              hookSpecificOutput: {
                hookEventName: "PreToolUse",
                permissionDecision: "deny",
                permissionDecisionReason: reason
              }
            };
          }
          return { continue: true };
        }
        if (!isFileTool(toolName)) {
          return { continue: true };
        }
        const filePath = getPathFromToolInput(toolName, input.tool_input);
        if (filePath) {
          const accessType = context.getPathAccessType(filePath);
          if (accessType === "vault" || accessType === "readwrite" || accessType === "context") {
            return { continue: true };
          }
          if (isEditTool(toolName) && accessType === "export") {
            return { continue: true };
          }
          if (!isEditTool(toolName) && accessType === "export") {
            return {
              continue: false,
              hookSpecificOutput: {
                hookEventName: "PreToolUse",
                permissionDecision: "deny",
                permissionDecisionReason: `Access denied: Path "${filePath}" is in an allowed export directory, but export paths are write-only.`
              }
            };
          }
          return {
            continue: false,
            hookSpecificOutput: {
              hookEventName: "PreToolUse",
              permissionDecision: "deny",
              permissionDecisionReason: `Access denied: Path "${filePath}" is outside the vault. Agent is restricted to vault directory only.`
            }
          };
        }
        return { continue: true };
      }
    ]
  };
}

// src/core/mcp/McpServerManager.ts
var McpServerManager = class {
  constructor(storage) {
    this.servers = [];
    this.storage = storage;
  }
  /** Load servers from storage. */
  async loadServers() {
    this.servers = await this.storage.load();
  }
  /** Get all loaded servers. */
  getServers() {
    return this.servers;
  }
  /** Get enabled servers count. */
  getEnabledCount() {
    return this.servers.filter((s) => s.enabled).length;
  }
  /**
   * Get servers to include in SDK options.
   *
   * A server is included if:
   * - It is enabled AND
   * - Either context-saving is disabled OR the server is @-mentioned
   *
   * @param mentionedNames Set of server names that were @-mentioned in the prompt
   */
  getActiveServers(mentionedNames) {
    const result = {};
    for (const server of this.servers) {
      if (!server.enabled) continue;
      if (server.contextSaving && !mentionedNames.has(server.name)) {
        continue;
      }
      result[server.name] = server.config;
    }
    return result;
  }
  /**
   * Get disabled MCP tools formatted for SDK disallowedTools option.
   *
   * Only returns disabled tools from servers that would be active (same filter as getActiveServers).
   *
   * @param mentionedNames Set of server names that were @-mentioned in the prompt
   */
  getDisallowedMcpTools(mentionedNames) {
    const disallowed = /* @__PURE__ */ new Set();
    for (const server of this.servers) {
      if (!server.enabled) continue;
      if (server.contextSaving && !mentionedNames.has(server.name)) {
        continue;
      }
      if (!server.disabledTools || server.disabledTools.length === 0) continue;
      for (const tool of server.disabledTools) {
        const normalized = tool.trim();
        if (!normalized) continue;
        disallowed.add(`mcp__${server.name}__${normalized}`);
      }
    }
    return Array.from(disallowed);
  }
  /**
   * Get all disabled MCP tools from ALL enabled servers (ignoring @-mentions).
   *
   * Used for persistent queries to pre-register all disabled tools upfront,
   * so @-mentioning servers doesn't require cold start.
   */
  getAllDisallowedMcpTools() {
    const disallowed = /* @__PURE__ */ new Set();
    for (const server of this.servers) {
      try {
        if (!server.enabled) continue;
        if (!server.disabledTools || server.disabledTools.length === 0) continue;
        for (const tool of server.disabledTools) {
          const normalized = tool.trim();
          if (!normalized) continue;
          disallowed.add(`mcp__${server.name}__${normalized}`);
        }
      } catch (e) {
      }
    }
    return Array.from(disallowed).sort();
  }
  /** Check if any MCP servers are configured. */
  hasServers() {
    return this.servers.length > 0;
  }
};

// src/utils/mcp.ts
function extractMcpMentions(text, validNames) {
  const mentions = /* @__PURE__ */ new Set();
  const regex = /@([a-zA-Z0-9._-]+)(?!\/)/g;
  let match;
  while ((match = regex.exec(text)) !== null) {
    const name = match[1];
    if (validNames.has(name)) {
      mentions.add(name);
    }
  }
  return mentions;
}
function transformMcpMentions(text, validNames) {
  if (validNames.size === 0) return text;
  const sortedNames = Array.from(validNames).sort((a, b) => b.length - a.length);
  const escapedNames = sortedNames.map(escapeRegExp).join("|");
  const pattern = new RegExp(
    `@(${escapedNames})(?! MCP)(?!/)(?![a-zA-Z0-9_-])(?!\\.[a-zA-Z0-9_-])`,
    "g"
  );
  return text.replace(pattern, "@$1 MCP");
}
function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function parseCommand(command, providedArgs) {
  if (providedArgs && providedArgs.length > 0) {
    return { cmd: command, args: providedArgs };
  }
  const parts = splitCommandString(command);
  if (parts.length === 0) {
    return { cmd: "", args: [] };
  }
  return { cmd: parts[0], args: parts.slice(1) };
}
function splitCommandString(cmdStr) {
  const parts = [];
  let current = "";
  let inQuote = false;
  let quoteChar = "";
  for (let i = 0; i < cmdStr.length; i++) {
    const char = cmdStr[i];
    if ((char === '"' || char === "'") && !inQuote) {
      inQuote = true;
      quoteChar = char;
      continue;
    }
    if (char === quoteChar && inQuote) {
      inQuote = false;
      quoteChar = "";
      continue;
    }
    if (/\s/.test(char) && !inQuote) {
      if (current) {
        parts.push(current);
        current = "";
      }
      continue;
    }
    current += char;
  }
  if (current) {
    parts.push(current);
  }
  return parts;
}
function parseSseEvent(raw) {
  const lines = raw.split(/\r?\n/);
  let event;
  const dataLines = [];
  for (const line of lines) {
    if (!line || line.startsWith(":")) continue;
    if (line.startsWith("event:")) {
      event = line.slice("event:".length).trim();
      continue;
    }
    if (line.startsWith("data:")) {
      dataLines.push(line.slice("data:".length).trimStart());
    }
  }
  if (!event && dataLines.length === 0) {
    return null;
  }
  return { event, data: dataLines.join("\n") };
}
async function consumeSseStream(body, onEvent) {
  const reader = body.getReader();
  const decoder = new TextDecoder();
  let buffer = "";
  try {
    let done = false;
    while (!done) {
      const result = await reader.read();
      done = result.done;
      const value = result.value;
      if (done) break;
      buffer += decoder.decode(value, { stream: true });
      const parts = buffer.split(/\r?\n\r?\n/);
      buffer = parts.pop() || "";
      for (const part of parts) {
        const event = parseSseEvent(part);
        if (event) {
          onEvent(event);
        }
      }
    }
  } catch (e) {
  } finally {
    reader.releaseLock();
  }
}
function parseRpcId(id) {
  if (typeof id === "number" && Number.isFinite(id)) return id;
  if (typeof id === "string" && id.trim()) {
    const asNumber = Number(id);
    if (Number.isFinite(asNumber)) return asNumber;
  }
  return null;
}
function tryParseJson(data) {
  if (!data) return null;
  try {
    return JSON.parse(data);
  } catch (e) {
    return null;
  }
}
function resolveSseEndpoint(data, baseUrl) {
  const payload = tryParseJson(data);
  if (payload && typeof payload === "object") {
    const record2 = payload;
    const endpoint = typeof record2.endpoint === "string" && record2.endpoint || typeof record2.messageEndpoint === "string" && record2.messageEndpoint || typeof record2.url === "string" && record2.url || typeof record2.messageUrl === "string" && record2.messageUrl;
    if (endpoint) {
      try {
        return new URL(endpoint, baseUrl);
      } catch (e) {
        return null;
      }
    }
  }
  const trimmed = data.trim();
  if (!trimmed) return null;
  try {
    return new URL(trimmed, baseUrl);
  } catch (e) {
    return null;
  }
}
function waitForRpcResponse(pending, id, timeoutMs) {
  return new Promise((resolve3, reject) => {
    const timer = setTimeout(() => {
      pending.delete(id);
      reject(new Error(`Response timeout (${timeoutMs}ms)`));
    }, timeoutMs);
    pending.set(id, (msg) => {
      clearTimeout(timer);
      pending.delete(id);
      resolve3(msg);
    });
  });
}
async function postJsonRpc(url, headers, payload, options = {}) {
  const requestHeaders = { ...headers };
  if (!requestHeaders["Content-Type"]) {
    requestHeaders["Content-Type"] = "application/json";
  }
  let controller = null;
  let timeoutId = null;
  let signal = options.signal;
  if (options.timeoutMs !== void 0 || options.signal) {
    controller = new AbortController();
    signal = controller.signal;
  }
  const abortHandler = () => controller == null ? void 0 : controller.abort();
  if (controller && options.signal) {
    if (options.signal.aborted) {
      controller.abort();
    } else {
      options.signal.addEventListener("abort", abortHandler, { once: true });
    }
  }
  if (controller && options.timeoutMs !== void 0) {
    timeoutId = setTimeout(() => controller == null ? void 0 : controller.abort(), options.timeoutMs);
  }
  const requestInit = {
    method: "POST",
    headers: requestHeaders,
    body: JSON.stringify(payload)
  };
  if (signal) {
    requestInit.signal = signal;
  }
  try {
    return await fetch(url.toString(), requestInit);
  } finally {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
    }
    if (controller && options.signal) {
      options.signal.removeEventListener("abort", abortHandler);
    }
  }
}

// src/core/mcp/McpService.ts
var McpService = class {
  constructor(manager) {
    this.manager = manager;
  }
  // ============================================
  // Delegated to McpServerManager (core)
  // ============================================
  /** Load servers from storage. */
  async loadServers() {
    return this.manager.loadServers();
  }
  /** Get all loaded servers. */
  getServers() {
    return this.manager.getServers();
  }
  /** Get enabled servers count. */
  getEnabledCount() {
    return this.manager.getEnabledCount();
  }
  /** Get servers to include in SDK options. */
  getActiveServers(mentionedNames) {
    return this.manager.getActiveServers(mentionedNames);
  }
  /** Check if any MCP servers are configured. */
  hasServers() {
    return this.manager.hasServers();
  }
  // ============================================
  // Feature-specific: @-mention detection & UI
  // ============================================
  /** Get all server names for @-mention validation. */
  getServerNames() {
    return this.manager.getServers().map((s) => s.name);
  }
  /** Get enabled server names for @-mention validation. */
  getEnabledServerNames() {
    return this.manager.getServers().filter((s) => s.enabled).map((s) => s.name);
  }
  /** Get servers with context-saving enabled (for @-mention autocomplete). */
  getContextSavingServers() {
    return this.manager.getServers().filter((s) => s.enabled && s.contextSaving);
  }
  /** Check if a server name is valid for @-mention. */
  isValidMcpMention(name) {
    return this.manager.getServers().some((s) => s.name === name && s.enabled && s.contextSaving);
  }
  /**
   * Extract MCP mentions from text.
   * Only matches against enabled servers with context-saving mode.
   */
  extractMentions(text) {
    const validNames = new Set(
      this.manager.getServers().filter((s) => s.enabled && s.contextSaving).map((s) => s.name)
    );
    return extractMcpMentions(text, validNames);
  }
  /** Check if any context-saving servers are enabled. */
  hasContextSavingServers() {
    return this.manager.getServers().some((s) => s.enabled && s.contextSaving);
  }
  /**
   * Transform MCP mentions in text by appending " MCP" after each valid @mention.
   * This is applied to API requests only, not shown in UI.
   */
  transformMentions(text) {
    const validNames = new Set(
      this.manager.getServers().filter((s) => s.enabled && s.contextSaving).map((s) => s.name)
    );
    return transformMcpMentions(text, validNames);
  }
  // ============================================
  // Access to underlying manager (for core layer)
  // ============================================
  /** Get the underlying server manager. */
  getManager() {
    return this.manager;
  }
};

// src/core/mcp/McpTester.ts
var import_child_process = require("child_process");
var http = __toESM(require("http"));
var https = __toESM(require("https"));
async function testMcpServer(server) {
  const type = getMcpServerType(server.config);
  try {
    if (type === "stdio") {
      return await testStdioServer(server);
    } else if (type === "sse") {
      return await testSseServer(server);
    } else {
      return await testHttpServer(server);
    }
  } catch (error2) {
    return {
      success: false,
      tools: [],
      error: error2 instanceof Error ? error2.message : "Unknown error"
    };
  }
}
async function testStdioServer(server) {
  const config2 = server.config;
  const { cmd, args } = parseCommand(config2.command, config2.args);
  return new Promise((resolve3) => {
    var _a, _b, _c, _d;
    let child = null;
    let stdout = "";
    let stderr = "";
    let resolved = false;
    let initReceived = false;
    let serverInfo = {};
    const cleanup = () => {
      if (child && !child.killed) {
        child.kill();
      }
    };
    const timeout = setTimeout(() => {
      if (!resolved) {
        resolved = true;
        cleanup();
        resolve3({
          success: false,
          tools: [],
          error: "Connection timeout (10s)"
        });
      }
    }, 1e4);
    try {
      if (!cmd) {
        clearTimeout(timeout);
        resolve3({
          success: false,
          tools: [],
          error: "Missing command"
        });
        return;
      }
      child = (0, import_child_process.spawn)(cmd, args, {
        env: { ...process.env, ...config2.env, PATH: getEnhancedPath((_a = config2.env) == null ? void 0 : _a.PATH) },
        stdio: ["pipe", "pipe", "pipe"]
      });
      (_b = child.stdout) == null ? void 0 : _b.on("data", (data) => {
        var _a2, _b2, _c2, _d2, _e;
        stdout += data.toString();
        const lines = stdout.split("\n");
        stdout = lines.pop() || "";
        for (const line of lines) {
          if (!line.trim()) continue;
          try {
            const msg = JSON.parse(line);
            if (msg.id === 1) {
              if (msg.error) {
                if (!resolved) {
                  resolved = true;
                  clearTimeout(timeout);
                  cleanup();
                  resolve3({
                    success: false,
                    tools: [],
                    error: msg.error.message || "Initialize failed"
                  });
                }
                return;
              }
              if (msg.result) {
                initReceived = true;
                serverInfo = {
                  name: (_a2 = msg.result.serverInfo) == null ? void 0 : _a2.name,
                  version: (_b2 = msg.result.serverInfo) == null ? void 0 : _b2.version
                };
                const initializedNotification = {
                  jsonrpc: "2.0",
                  method: "notifications/initialized"
                };
                (_c2 = child == null ? void 0 : child.stdin) == null ? void 0 : _c2.write(JSON.stringify(initializedNotification) + "\n");
                const toolsRequest = {
                  jsonrpc: "2.0",
                  id: 2,
                  method: "tools/list",
                  params: {}
                };
                (_d2 = child == null ? void 0 : child.stdin) == null ? void 0 : _d2.write(JSON.stringify(toolsRequest) + "\n");
              }
            }
            if (msg.id === 2) {
              if (!resolved) {
                resolved = true;
                clearTimeout(timeout);
                cleanup();
                if (msg.error) {
                  resolve3({
                    success: true,
                    serverName: serverInfo.name,
                    serverVersion: serverInfo.version,
                    tools: []
                  });
                  return;
                }
                const tools = (((_e = msg.result) == null ? void 0 : _e.tools) || []).map(
                  (t2) => ({
                    name: t2.name,
                    description: t2.description,
                    inputSchema: t2.inputSchema
                  })
                );
                resolve3({
                  success: true,
                  serverName: serverInfo.name,
                  serverVersion: serverInfo.version,
                  tools
                });
              }
              return;
            }
          } catch (e) {
          }
        }
      });
      (_c = child.stderr) == null ? void 0 : _c.on("data", (data) => {
        stderr += data.toString();
      });
      child.on("error", (error2) => {
        if (!resolved) {
          resolved = true;
          clearTimeout(timeout);
          resolve3({
            success: false,
            tools: [],
            error: `Failed to start: ${error2.message}`
          });
        }
      });
      child.on("close", (code) => {
        if (!resolved) {
          resolved = true;
          clearTimeout(timeout);
          if (initReceived) {
            resolve3({
              success: true,
              serverName: serverInfo.name,
              serverVersion: serverInfo.version,
              tools: []
            });
          } else if (code !== 0) {
            resolve3({
              success: false,
              tools: [],
              error: stderr || `Process exited with code ${code}`
            });
          }
        }
      });
      const initRequest = {
        jsonrpc: "2.0",
        id: 1,
        method: "initialize",
        params: {
          protocolVersion: "2024-11-05",
          capabilities: {},
          clientInfo: { name: "claudian-tester", version: "1.0.0" }
        }
      };
      (_d = child.stdin) == null ? void 0 : _d.write(JSON.stringify(initRequest) + "\n");
    } catch (error2) {
      resolved = true;
      clearTimeout(timeout);
      resolve3({
        success: false,
        tools: [],
        error: error2 instanceof Error ? error2.message : "Failed to spawn process"
      });
    }
  });
}
function httpRequest(url, headers, body) {
  return new Promise((resolve3, reject) => {
    const isHttps = url.protocol === "https:";
    const httpModule = isHttps ? https : http;
    const req = httpModule.request(
      {
        hostname: url.hostname,
        port: url.port || (isHttps ? 443 : 80),
        path: url.pathname + url.search,
        method: "POST",
        headers: {
          ...headers,
          "Content-Length": Buffer.byteLength(body)
        }
      },
      (res) => {
        let data = "";
        res.on("data", (chunk) => {
          data += chunk;
        });
        res.on("end", () => {
          resolve3({ statusCode: res.statusCode || 0, data });
        });
      }
    );
    req.on("error", reject);
    req.write(body);
    req.end();
  });
}
async function testHttpServer(server) {
  const config2 = server.config;
  return new Promise((resolve3) => {
    const timeout = setTimeout(() => {
      resolve3({
        success: false,
        tools: [],
        error: "Connection timeout (10s)"
      });
    }, 1e4);
    (async () => {
      var _a, _b;
      try {
        const url = new URL(config2.url);
        const headers = {
          "Content-Type": "application/json",
          Accept: "application/json, text/event-stream",
          ...config2.headers
        };
        const initRequest = JSON.stringify({
          jsonrpc: "2.0",
          id: 1,
          method: "initialize",
          params: {
            protocolVersion: "2024-11-05",
            capabilities: {},
            clientInfo: { name: "claudian-tester", version: "1.0.0" }
          }
        });
        const initResponse = await httpRequest(url, headers, initRequest);
        let serverName;
        let serverVersion;
        try {
          const initResult = JSON.parse(initResponse.data);
          if (initResult.error) {
            clearTimeout(timeout);
            resolve3({
              success: false,
              tools: [],
              error: initResult.error.message || "Server error"
            });
            return;
          }
          if ((_a = initResult.result) == null ? void 0 : _a.serverInfo) {
            serverName = initResult.result.serverInfo.name;
            serverVersion = initResult.result.serverInfo.version;
          }
        } catch (e) {
          clearTimeout(timeout);
          resolve3({
            success: false,
            tools: [],
            error: `Invalid JSON response: ${initResponse.data.slice(0, 200)}`
          });
          return;
        }
        const initializedNotification = JSON.stringify({
          jsonrpc: "2.0",
          method: "notifications/initialized"
        });
        httpRequest(url, headers, initializedNotification).catch(() => {
        });
        const toolsRequest = JSON.stringify({
          jsonrpc: "2.0",
          id: 2,
          method: "tools/list",
          params: {}
        });
        const toolsResponse = await httpRequest(url, headers, toolsRequest);
        try {
          const toolsResult = JSON.parse(toolsResponse.data);
          clearTimeout(timeout);
          if (toolsResult.error) {
            resolve3({
              success: true,
              serverName,
              serverVersion,
              tools: []
            });
            return;
          }
          const tools = (((_b = toolsResult.result) == null ? void 0 : _b.tools) || []).map(
            (t2) => ({
              name: t2.name,
              description: t2.description,
              inputSchema: t2.inputSchema
            })
          );
          resolve3({
            success: true,
            serverName,
            serverVersion,
            tools
          });
        } catch (e) {
          clearTimeout(timeout);
          resolve3({
            success: true,
            serverName,
            serverVersion,
            tools: []
          });
        }
      } catch (error2) {
        clearTimeout(timeout);
        resolve3({
          success: false,
          tools: [],
          error: error2 instanceof Error ? error2.message : "Request failed"
        });
      }
    })();
  });
}
async function testSseServer(server) {
  var _a, _b, _c, _d, _e;
  const config2 = server.config;
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), 1e4);
  try {
    const sseUrl = new URL(config2.url);
    const headers = {
      Accept: "text/event-stream",
      ...config2.headers
    };
    const response = await fetch(sseUrl.toString(), {
      method: "GET",
      headers,
      signal: controller.signal
    });
    if (!response.ok || !response.body) {
      clearTimeout(timeout);
      return {
        success: false,
        tools: [],
        error: `HTTP ${response.status}: ${response.statusText}`
      };
    }
    let endpointResolved = false;
    let resolveEndpoint = null;
    const endpointPromise = new Promise((resolve3) => {
      resolveEndpoint = resolve3;
    });
    const pending = /* @__PURE__ */ new Map();
    const streamPromise = consumeSseStream(response.body, (event) => {
      if (!endpointResolved) {
        const candidate = resolveSseEndpoint(event.data, sseUrl);
        if (candidate) {
          endpointResolved = true;
          resolveEndpoint == null ? void 0 : resolveEndpoint(candidate);
        }
      }
      const payload = tryParseJson(event.data);
      if (payload && typeof payload === "object") {
        const record2 = payload;
        const id = parseRpcId(record2.id);
        if (id !== null) {
          const handler = pending.get(id);
          if (handler) {
            handler(record2);
          }
        }
      }
    }).catch(() => {
    });
    let endpointTimeout = null;
    const endpointTimeoutPromise = new Promise((_, reject) => {
      endpointTimeout = setTimeout(() => reject(new Error("SSE endpoint not advertised")), 5e3);
    });
    let postUrl;
    try {
      postUrl = await Promise.race([endpointPromise, endpointTimeoutPromise]);
    } finally {
      if (endpointTimeout) clearTimeout(endpointTimeout);
    }
    const postOptions = { signal: controller.signal, timeoutMs: 8e3 };
    const initRequest = {
      jsonrpc: "2.0",
      id: 1,
      method: "initialize",
      params: {
        protocolVersion: "2024-11-05",
        capabilities: {},
        clientInfo: { name: "claudian-tester", version: "1.0.0" }
      }
    };
    const initResponsePromise = waitForRpcResponse(pending, 1, 8e3);
    initResponsePromise.catch(() => {
    });
    const initPost = await postJsonRpc(postUrl, (_a = config2.headers) != null ? _a : {}, initRequest, postOptions);
    if (initPost.status >= 400) {
      initResponsePromise.catch(() => {
      });
      clearTimeout(timeout);
      controller.abort();
      return {
        success: false,
        tools: [],
        error: `HTTP ${initPost.status}: ${initPost.statusText}`
      };
    }
    const initResponse = await initResponsePromise;
    const initError = initResponse.error;
    if (initError) {
      clearTimeout(timeout);
      controller.abort();
      return {
        success: false,
        tools: [],
        error: initError.message || "Initialize failed"
      };
    }
    const serverInfo = initResponse.result;
    const serverName = (_b = serverInfo == null ? void 0 : serverInfo.serverInfo) == null ? void 0 : _b.name;
    const serverVersion = (_c = serverInfo == null ? void 0 : serverInfo.serverInfo) == null ? void 0 : _c.version;
    await postJsonRpc(postUrl, (_d = config2.headers) != null ? _d : {}, {
      jsonrpc: "2.0",
      method: "notifications/initialized"
    }, postOptions).catch(() => {
    });
    const toolsResponsePromise = waitForRpcResponse(pending, 2, 8e3);
    toolsResponsePromise.catch(() => {
    });
    await postJsonRpc(postUrl, (_e = config2.headers) != null ? _e : {}, {
      jsonrpc: "2.0",
      id: 2,
      method: "tools/list",
      params: {}
    }, postOptions);
    let tools = [];
    try {
      const toolsResponse = await toolsResponsePromise;
      const toolsError = toolsResponse.error;
      if (!toolsError) {
        const result = toolsResponse.result;
        tools = ((result == null ? void 0 : result.tools) || []).map(
          (t2) => ({
            name: t2.name,
            description: t2.description,
            inputSchema: t2.inputSchema
          })
        );
      }
    } catch (e) {
    }
    clearTimeout(timeout);
    controller.abort();
    await streamPromise;
    return {
      success: true,
      serverName,
      serverVersion,
      tools
    };
  } catch (error2) {
    clearTimeout(timeout);
    controller.abort();
    return {
      success: false,
      tools: [],
      error: error2 instanceof Error ? error2.message : "Request failed"
    };
  }
}

// src/core/plugins/PluginManager.ts
var PluginManager = class {
  constructor(storage) {
    this.plugins = [];
    this.enabledPluginIds = /* @__PURE__ */ new Set();
    this.storage = storage;
  }
  /**
   * Get plugins that are both enabled and available.
   */
  getActivePlugins() {
    return this.plugins.filter((plugin) => plugin.enabled && plugin.status === "available");
  }
  /**
   * Set the list of enabled plugin IDs.
   * Can be called before or after loadPlugins() - enabled state is applied immediately
   * to any already-loaded plugins and remembered for future loads.
   */
  setEnabledPluginIds(ids) {
    this.enabledPluginIds = new Set(ids);
    for (const plugin of this.plugins) {
      plugin.enabled = this.enabledPluginIds.has(plugin.id);
    }
  }
  /**
   * Load plugins from the registry and apply enabled state.
   */
  async loadPlugins() {
    this.plugins = this.storage.loadPlugins();
    for (const plugin of this.plugins) {
      plugin.enabled = this.enabledPluginIds.has(plugin.id);
    }
  }
  /**
   * Get all discovered plugins.
   * Returns a copy of the plugins array (sorted by PluginStorage: project/local first, then user).
   */
  getPlugins() {
    return [...this.plugins];
  }
  /**
   * Get SDK plugin configs for enabled and available plugins.
   */
  getActivePluginConfigs() {
    return this.getActivePlugins().map((plugin) => ({
      type: "local",
      path: plugin.pluginPath
    }));
  }
  /**
   * Get IDs of plugins that are enabled but unavailable.
   * Use this for cleanup on startup.
   */
  getUnavailableEnabledPlugins() {
    return this.plugins.filter((plugin) => plugin.enabled && plugin.status !== "available").map((plugin) => plugin.id);
  }
  /**
   * Check if any plugins are enabled and available.
   */
  hasEnabledPlugins() {
    return this.getActivePlugins().length > 0;
  }
  /**
   * Get the count of enabled and available plugins.
   */
  getEnabledCount() {
    return this.getActivePlugins().length;
  }
  /**
   * Get a stable key representing active plugin configuration.
   * Used to detect changes that require restarting the persistent query.
   */
  getPluginsKey() {
    const activePlugins = this.getActivePlugins().sort((a, b) => a.id.localeCompare(b.id));
    if (activePlugins.length === 0) {
      return "";
    }
    return activePlugins.map((plugin) => `${plugin.id}:${plugin.pluginPath}`).join("|");
  }
  /**
   * Toggle a plugin's enabled state.
   * Returns the updated enabled IDs array for saving to settings.
   */
  togglePlugin(pluginId) {
    const plugin = this.plugins.find((p) => p.id === pluginId);
    if (!plugin) {
      return Array.from(this.enabledPluginIds);
    }
    if (plugin.enabled) {
      this.enabledPluginIds.delete(pluginId);
      plugin.enabled = false;
    } else {
      this.enabledPluginIds.add(pluginId);
      plugin.enabled = true;
    }
    return Array.from(this.enabledPluginIds);
  }
  /**
   * Enable a plugin by ID.
   * Returns the updated enabled IDs array for saving to settings.
   */
  enablePlugin(pluginId) {
    const plugin = this.plugins.find((p) => p.id === pluginId);
    if (plugin && !plugin.enabled) {
      this.enabledPluginIds.add(pluginId);
      plugin.enabled = true;
    }
    return Array.from(this.enabledPluginIds);
  }
  /**
   * Disable a plugin by ID.
   * Returns the updated enabled IDs array for saving to settings.
   */
  disablePlugin(pluginId) {
    const plugin = this.plugins.find((p) => p.id === pluginId);
    if (plugin && plugin.enabled) {
      this.enabledPluginIds.delete(pluginId);
      plugin.enabled = false;
    }
    return Array.from(this.enabledPluginIds);
  }
  /**
   * Check if there are any plugins available.
   */
  hasPlugins() {
    return this.plugins.length > 0;
  }
  /**
   * Get install paths for enabled and available plugins.
   * Returns array of { pluginName, commandsPath } for each active plugin.
   * Note: Actual command existence is verified by loadPluginCommands().
   */
  getPluginCommandPaths() {
    return this.getActivePlugins().map((plugin) => ({
      pluginName: plugin.name,
      commandsPath: plugin.installPath
      // The commands subdirectory is appended by loadPluginCommands()
    }));
  }
};

// src/core/plugins/PluginStorage.ts
var fs4 = __toESM(require("fs"));
var os3 = __toESM(require("os"));
var path5 = __toESM(require("path"));

// src/utils/slashCommand.ts
function formatSlashCommandWarnings(errors) {
  const maxItems = 3;
  const head = errors.slice(0, maxItems);
  const more = errors.length > maxItems ? `
...and ${errors.length - maxItems} more` : "";
  return `Slash command expansion warnings:
- ${head.join("\n- ")}${more}`;
}
function parseSlashCommandContent(content) {
  var _a, _b;
  const frontmatterPattern = /^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/;
  const match = content.match(frontmatterPattern);
  if (!match) {
    return { promptContent: content };
  }
  const yamlContent = match[1];
  const promptContent = match[2];
  const result = { promptContent };
  const lines = yamlContent.split(/\r?\n/);
  let arrayKey = null;
  let arrayItems = [];
  let blockScalarKey = null;
  let blockScalarStyle = null;
  let blockScalarLines = [];
  let blockScalarIndent = null;
  const flushArray = () => {
    if (arrayKey === "allowed-tools") {
      result.allowedTools = arrayItems;
    }
    arrayKey = null;
    arrayItems = [];
  };
  const flushBlockScalar = () => {
    if (!blockScalarKey) return;
    let value;
    if (blockScalarStyle === "literal") {
      value = blockScalarLines.join("\n");
    } else {
      value = blockScalarLines.join("\n").replace(/(?<!\n)\n(?!\n)/g, " ").trim();
    }
    switch (blockScalarKey) {
      case "description":
        result.description = value;
        break;
      case "argument-hint":
        result.argumentHint = value;
        break;
      case "model":
        result.model = value;
        break;
    }
    blockScalarKey = null;
    blockScalarStyle = null;
    blockScalarLines = [];
    blockScalarIndent = null;
  };
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmedLine = line.trim();
    if (blockScalarKey) {
      if (trimmedLine === "") {
        blockScalarLines.push("");
        continue;
      }
      const leadingSpaces = (_b = (_a = line.match(/^(\s*)/)) == null ? void 0 : _a[1].length) != null ? _b : 0;
      if (blockScalarIndent === null) {
        if (leadingSpaces === 0) {
          flushBlockScalar();
        } else {
          blockScalarIndent = leadingSpaces;
          const content2 = line.slice(blockScalarIndent);
          blockScalarLines.push(content2);
          continue;
        }
      } else if (leadingSpaces >= blockScalarIndent) {
        const content2 = line.slice(blockScalarIndent);
        blockScalarLines.push(content2);
        continue;
      } else {
        flushBlockScalar();
      }
    }
    if (arrayKey) {
      if (trimmedLine.startsWith("- ")) {
        arrayItems.push(unquoteYamlString(trimmedLine.slice(2).trim()));
        continue;
      }
      if (trimmedLine === "") {
        continue;
      }
      flushArray();
    }
    const colonIndex = line.indexOf(":");
    if (colonIndex <= 0) {
      continue;
    }
    const key = line.slice(0, colonIndex).trim();
    const value = line.slice(colonIndex + 1).trim();
    const blockScalarMatch = value.match(/^([|>])([+-])?$/);
    if (blockScalarMatch && (key === "description" || key === "argument-hint" || key === "model")) {
      blockScalarKey = key;
      blockScalarStyle = blockScalarMatch[1] === "|" ? "literal" : "folded";
      blockScalarLines = [];
      blockScalarIndent = null;
      continue;
    }
    switch (key) {
      case "description":
        result.description = unquoteYamlString(value);
        break;
      case "argument-hint":
        result.argumentHint = unquoteYamlString(value);
        break;
      case "model":
        result.model = unquoteYamlString(value);
        break;
      case "allowed-tools":
        if (!value) {
          arrayKey = key;
          arrayItems = [];
          break;
        }
        if (value.startsWith("[") && value.endsWith("]")) {
          result.allowedTools = value.slice(1, -1).split(",").map((s) => unquoteYamlString(s.trim())).filter(Boolean);
          break;
        }
        result.allowedTools = [unquoteYamlString(value)].filter(Boolean);
        break;
    }
  }
  if (blockScalarKey) {
    flushBlockScalar();
  }
  if (arrayKey) {
    flushArray();
  }
  return result;
}
function unquoteYamlString(value) {
  if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
    return value.slice(1, -1);
  }
  return value;
}

// src/core/plugins/PluginStorage.ts
var INSTALLED_PLUGINS_PATH = path5.join(os3.homedir(), ".claude", "plugins", "installed_plugins.json");
var PLUGIN_MANIFEST_FILE = "plugin.json";
var MARKETPLACE_MANIFEST_FILE = "marketplace.json";
var PLUGIN_DIR_NAME = ".claude-plugin";
function isValidPluginEntry(entry) {
  if (typeof entry !== "object" || entry === null) return false;
  const e = entry;
  return typeof e.installPath === "string" && typeof e.version === "string" && typeof e.installedAt === "string" && (e.scope === void 0 || ["user", "project", "local"].includes(e.scope));
}
function parseInstalledPluginsFile(content) {
  try {
    const data = JSON.parse(content);
    if (typeof data !== "object" || data === null) {
      return { data: null, error: "Invalid format: expected object at root" };
    }
    if (typeof data.version !== "number") {
      return { data: null, error: "Invalid format: missing or invalid version field" };
    }
    if (typeof data.plugins !== "object" || data.plugins === null) {
      return { data: null, error: "Invalid format: missing or invalid plugins field" };
    }
    for (const [pluginId, entries] of Object.entries(data.plugins)) {
      if (!Array.isArray(entries)) {
        continue;
      }
      data.plugins[pluginId] = entries.filter((entry) => isValidPluginEntry(entry));
    }
    return { data };
  } catch (err) {
    const message = err instanceof Error ? err.message : "Unknown parse error";
    return { data: null, error: `JSON parse error: ${message}` };
  }
}
function readJsonFile(filePath) {
  try {
    if (!fs4.existsSync(filePath)) return { data: null };
    const content = fs4.readFileSync(filePath, "utf-8");
    return { data: JSON.parse(content) };
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : String(err);
    return { data: null, error: errorMessage };
  }
}
var NUMERIC_IDENTIFIER_RE = /^[0-9]+$/;
function parseSemver(version2) {
  const trimmed = version2.trim();
  const normalized = trimmed.startsWith("v") || trimmed.startsWith("V") ? trimmed.slice(1) : trimmed;
  const [coreAndPre] = normalized.split("+", 1);
  const [corePart, prereleasePart] = coreAndPre.split("-", 2);
  if (!corePart) {
    return { core: [], prerelease: [], valid: false };
  }
  const coreSegments = corePart.split(".");
  const core = [];
  for (const segment of coreSegments) {
    if (!segment || !NUMERIC_IDENTIFIER_RE.test(segment)) {
      return { core: [], prerelease: [], valid: false };
    }
    core.push(Number(segment));
  }
  const prerelease = prereleasePart ? prereleasePart.split(".").map((id) => NUMERIC_IDENTIFIER_RE.test(id) ? Number(id) : id) : [];
  return { core, prerelease, valid: true };
}
function comparePrerelease(a, b) {
  if (a.length === 0 && b.length === 0) return 0;
  if (a.length === 0) return 1;
  if (b.length === 0) return -1;
  const maxLen = Math.max(a.length, b.length);
  for (let i = 0; i < maxLen; i++) {
    const aId = a[i];
    const bId = b[i];
    if (aId === void 0) return -1;
    if (bId === void 0) return 1;
    if (aId === bId) continue;
    const aIsNumber = typeof aId === "number";
    const bIsNumber = typeof bId === "number";
    if (aIsNumber && bIsNumber) {
      return aId > bId ? 1 : -1;
    }
    if (aIsNumber !== bIsNumber) {
      return aIsNumber ? -1 : 1;
    }
    return String(aId).localeCompare(String(bId));
  }
  return 0;
}
function compareSemver(a, b) {
  var _a, _b;
  const parsedA = parseSemver(a);
  const parsedB = parseSemver(b);
  if (!parsedA.valid || !parsedB.valid) {
    return a.localeCompare(b, void 0, { numeric: true, sensitivity: "base" });
  }
  const maxLen = Math.max(3, parsedA.core.length, parsedB.core.length);
  for (let i = 0; i < maxLen; i++) {
    const aVal = (_a = parsedA.core[i]) != null ? _a : 0;
    const bVal = (_b = parsedB.core[i]) != null ? _b : 0;
    if (aVal > bVal) return 1;
    if (aVal < bVal) return -1;
  }
  return comparePrerelease(parsedA.prerelease, parsedB.prerelease);
}
function pickNewestEntry(entries) {
  if (entries.length === 0) return null;
  if (entries.length === 1) return entries[0];
  return entries.reduce((newest, current) => {
    var _a, _b;
    const newestDate = (_a = newest.lastUpdated) != null ? _a : newest.installedAt;
    const currentDate = (_b = current.lastUpdated) != null ? _b : current.installedAt;
    if (currentDate > newestDate) return current;
    if (currentDate < newestDate) return newest;
    return compareSemver(current.version, newest.version) > 0 ? current : newest;
  });
}
function determineScope(entry) {
  var _a, _b;
  if (!entry.projectPath) return (_a = entry.scope) != null ? _a : "user";
  const homeDir = normalizePathForComparison(os3.homedir());
  const entryPath = normalizePathForComparison(entry.projectPath);
  if (entryPath === homeDir) {
    return "user";
  }
  return (_b = entry.scope) != null ? _b : "project";
}
function determinePluginStatus(installPathExists, manifestError) {
  if (!installPathExists) {
    return "unavailable";
  }
  if (manifestError) {
    return "invalid-manifest";
  }
  return "available";
}
function shouldIncludeEntry(entry, vaultPath) {
  const scope = determineScope(entry);
  if (scope === "user") {
    return true;
  }
  if (!entry.projectPath) return false;
  const normalizedVault = normalizePathForComparison(vaultPath);
  const normalizedProjectPath = normalizePathForComparison(entry.projectPath);
  return normalizedVault === normalizedProjectPath || normalizedVault.startsWith(normalizedProjectPath + "/");
}
function loadPluginManifest(installPath, pluginId) {
  const pluginDir = path5.join(installPath, PLUGIN_DIR_NAME);
  if (!fs4.existsSync(pluginDir)) {
    return {
      manifest: null,
      pluginPath: "",
      error: "Plugin directory not found"
    };
  }
  const singleManifestPath = path5.join(pluginDir, PLUGIN_MANIFEST_FILE);
  if (fs4.existsSync(singleManifestPath)) {
    const { data: manifest, error: error2 } = readJsonFile(singleManifestPath);
    if (manifest) {
      return {
        manifest,
        pluginPath: pluginDir
      };
    }
    if (error2) {
      return {
        manifest: null,
        pluginPath: "",
        error: `Failed to read plugin.json: ${error2}`
      };
    }
  }
  const marketplaceManifestPath = path5.join(pluginDir, MARKETPLACE_MANIFEST_FILE);
  if (fs4.existsSync(marketplaceManifestPath)) {
    const { data: marketplaceManifest, error: error2 } = readJsonFile(marketplaceManifestPath);
    if (error2) {
      return {
        manifest: null,
        pluginPath: "",
        error: `Failed to read marketplace.json: ${error2}`
      };
    }
    if (marketplaceManifest == null ? void 0 : marketplaceManifest.plugins) {
      const pluginName = pluginId.replace(/@.*$/, "");
      const matchingPlugin = marketplaceManifest.plugins.find((p) => {
        const normalizedName = p.name.toLowerCase().replace(/\s+/g, "-");
        return normalizedName === pluginName.toLowerCase();
      });
      if (matchingPlugin) {
        const pluginPath = matchingPlugin.source ? path5.join(pluginDir, matchingPlugin.source) : pluginDir;
        return {
          manifest: {
            name: matchingPlugin.name,
            description: matchingPlugin.description
          },
          pluginPath
        };
      }
      if (marketplaceManifest.plugins.length > 0) {
        const firstPlugin = marketplaceManifest.plugins[0];
        const pluginPath = firstPlugin.source ? path5.join(pluginDir, firstPlugin.source) : pluginDir;
        return {
          manifest: {
            name: firstPlugin.name,
            description: firstPlugin.description
          },
          pluginPath
        };
      }
    }
  }
  return {
    manifest: null,
    pluginPath: "",
    error: "Invalid or missing manifest"
  };
}
var PluginStorage = class {
  constructor(vaultPath) {
    this.vaultPath = vaultPath;
  }
  /**
   * Load all plugins from the global registry.
   * Filters by projectPath against the current vault.
   */
  loadPlugins() {
    var _a;
    const content = this.readInstalledPluginsFile();
    if (!content) {
      return [];
    }
    const { data: pluginsFile } = parseInstalledPluginsFile(content);
    if (!pluginsFile) {
      return [];
    }
    const plugins = [];
    for (const [pluginId, entries] of Object.entries(pluginsFile.plugins)) {
      const applicableEntries = entries.filter(
        (entry2) => shouldIncludeEntry(entry2, this.vaultPath)
      );
      if (applicableEntries.length === 0) {
        continue;
      }
      const entry = pickNewestEntry(applicableEntries);
      if (!entry) continue;
      const { manifest, pluginPath, error: error2 } = loadPluginManifest(entry.installPath, pluginId);
      const scope = determineScope(entry);
      const installPathExists = fs4.existsSync(entry.installPath);
      const status = determinePluginStatus(installPathExists, error2);
      const errorMessage = !installPathExists ? "Plugin directory not found" : error2;
      plugins.push({
        id: pluginId,
        name: (_a = manifest == null ? void 0 : manifest.name) != null ? _a : pluginId,
        description: manifest == null ? void 0 : manifest.description,
        version: entry.version,
        installPath: entry.installPath,
        pluginPath: pluginPath || entry.installPath,
        scope,
        projectPath: entry.projectPath,
        enabled: false,
        // Will be set by PluginManager
        status,
        error: errorMessage
      });
    }
    return plugins.sort((a, b) => {
      const scopeOrder = { local: 0, project: 1, user: 2 };
      return scopeOrder[a.scope] - scopeOrder[b.scope];
    });
  }
  /**
   * Read the installed_plugins.json file.
   */
  readInstalledPluginsFile() {
    try {
      if (!fs4.existsSync(INSTALLED_PLUGINS_PATH)) {
        return null;
      }
      return fs4.readFileSync(INSTALLED_PLUGINS_PATH, "utf-8");
    } catch (e) {
      return null;
    }
  }
};
function loadPluginCommands(installPath, pluginName) {
  const commandsDir = path5.join(installPath, "commands");
  const commands = [];
  if (!fs4.existsSync(commandsDir)) {
    return commands;
  }
  try {
    const files = listMarkdownFilesRecursive(commandsDir);
    for (const filePath of files) {
      try {
        const content = fs4.readFileSync(filePath, "utf-8");
        const command = parsePluginCommandFile(content, filePath, commandsDir, pluginName);
        if (command) {
          commands.push(command);
        }
      } catch (e) {
      }
    }
  } catch (e) {
  }
  return commands;
}
function listMarkdownFilesRecursive(dir) {
  const files = [];
  if (!fs4.existsSync(dir)) {
    return files;
  }
  const entries = fs4.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = path5.join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...listMarkdownFilesRecursive(fullPath));
    } else if (entry.isFile() && entry.name.endsWith(".md")) {
      files.push(fullPath);
    }
  }
  return files;
}
function parsePluginCommandFile(content, filePath, commandsDir, pluginName) {
  const parsed = parseSlashCommandContent(content);
  const relativePath = path5.relative(commandsDir, filePath);
  const nameWithoutExt = relativePath.replace(/\.md$/, "").replace(/\\/g, "/");
  const name = `${pluginName.toLowerCase().replace(/\s+/g, "-")}:${nameWithoutExt}`;
  const escapedName = name.replace(/-/g, "-_").replace(/:/g, "--");
  const id = `plugin-${escapedName}`;
  return {
    id,
    name,
    description: parsed.description,
    argumentHint: parsed.argumentHint,
    allowedTools: parsed.allowedTools,
    model: parsed.model,
    content: parsed.promptContent
  };
}

// src/core/storage/migrationConstants.ts
var CLAUDIAN_ONLY_FIELDS = /* @__PURE__ */ new Set([
  // User preferences
  "userName",
  // Security settings
  "enableBlocklist",
  "blockedCommands",
  "permissionMode",
  "lastNonPlanPermissionMode",
  // Model & thinking
  "model",
  "thinkingBudget",
  "enableAutoTitleGeneration",
  "titleGenerationModel",
  // Content settings
  "excludedTags",
  "mediaFolder",
  "systemPrompt",
  "allowedExportPaths",
  "persistentExternalContextPaths",
  // Environment (Claudian uses string format + snippets)
  "environmentVariables",
  "envSnippets",
  // UI settings
  "keyboardNavigation",
  // CLI paths
  "claudeCliPath",
  "claudeCliPaths",
  "loadUserClaudeSettings",
  // Deprecated fields (removed completely, not migrated)
  "allowedContextPaths",
  "showToolUse",
  "toolCallExpandedByDefault",
  // Claude Code plugins
  "enabledPlugins"
]);
function convertEnvObjectToString(env) {
  if (!env || typeof env !== "object") {
    return "";
  }
  return Object.entries(env).filter(([key, value]) => typeof key === "string" && typeof value === "string").map(([key, value]) => `${key}=${value}`).join("\n");
}
function mergeEnvironmentVariables(existing, additional) {
  const envMap = /* @__PURE__ */ new Map();
  for (const line of existing.split("\n")) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) continue;
    const eqIndex = trimmed.indexOf("=");
    if (eqIndex > 0) {
      const key = trimmed.slice(0, eqIndex);
      const value = trimmed.slice(eqIndex + 1);
      envMap.set(key, value);
    }
  }
  for (const line of additional.split("\n")) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) continue;
    const eqIndex = trimmed.indexOf("=");
    if (eqIndex > 0) {
      const key = trimmed.slice(0, eqIndex);
      const value = trimmed.slice(eqIndex + 1);
      envMap.set(key, value);
    }
  }
  return Array.from(envMap.entries()).map(([key, value]) => `${key}=${value}`).join("\n");
}

// src/core/storage/CCSettingsStorage.ts
var CC_SETTINGS_PATH = ".claude/settings.json";
var CC_SETTINGS_SCHEMA = "https://json.schemastore.org/claude-code-settings.json";
function hasClaudianOnlyFields(data) {
  return Object.keys(data).some((key) => CLAUDIAN_ONLY_FIELDS.has(key));
}
function isLegacyPermissionsFormat(data) {
  if (!data || typeof data !== "object") return false;
  const obj = data;
  if (!Array.isArray(obj.permissions)) return false;
  if (obj.permissions.length === 0) return false;
  const first = obj.permissions[0];
  return typeof first === "object" && first !== null && "toolName" in first && "pattern" in first;
}
function normalizePermissions(permissions) {
  if (!permissions || typeof permissions !== "object") {
    return { ...DEFAULT_CC_PERMISSIONS };
  }
  const p = permissions;
  return {
    allow: Array.isArray(p.allow) ? p.allow.filter((r) => typeof r === "string").map((r) => r) : [],
    deny: Array.isArray(p.deny) ? p.deny.filter((r) => typeof r === "string").map((r) => r) : [],
    ask: Array.isArray(p.ask) ? p.ask.filter((r) => typeof r === "string").map((r) => r) : [],
    defaultMode: typeof p.defaultMode === "string" ? p.defaultMode : void 0,
    additionalDirectories: Array.isArray(p.additionalDirectories) ? p.additionalDirectories.filter((d) => typeof d === "string") : void 0
  };
}
var CCSettingsStorage = class {
  constructor(adapter) {
    this.adapter = adapter;
  }
  /**
   * Load CC settings from .claude/settings.json.
   * Returns default settings if file doesn't exist.
   * Throws if file exists but cannot be read or parsed.
   */
  async load() {
    if (!await this.adapter.exists(CC_SETTINGS_PATH)) {
      return { ...DEFAULT_CC_SETTINGS };
    }
    const content = await this.adapter.read(CC_SETTINGS_PATH);
    const stored = JSON.parse(content);
    if (isLegacyPermissionsFormat(stored)) {
      const legacyPerms = stored.permissions;
      const ccPerms = legacyPermissionsToCCPermissions(legacyPerms);
      return {
        $schema: CC_SETTINGS_SCHEMA,
        ...stored,
        permissions: ccPerms
      };
    }
    return {
      $schema: CC_SETTINGS_SCHEMA,
      ...stored,
      permissions: normalizePermissions(stored.permissions)
    };
  }
  /**
   * Save CC settings to .claude/settings.json.
   * Preserves unknown fields for CC compatibility.
   *
   * @param stripClaudianFields - If true, remove Claudian-only fields (only during migration)
   */
  async save(settings11, stripClaudianFields = false) {
    var _a;
    let existing = {};
    if (await this.adapter.exists(CC_SETTINGS_PATH)) {
      try {
        const content2 = await this.adapter.read(CC_SETTINGS_PATH);
        const parsed = JSON.parse(content2);
        if (stripClaudianFields && (isLegacyPermissionsFormat(parsed) || hasClaudianOnlyFields(parsed))) {
          existing = {};
          for (const [key, value] of Object.entries(parsed)) {
            if (!CLAUDIAN_ONLY_FIELDS.has(key)) {
              existing[key] = value;
            }
          }
          if (Array.isArray(existing.permissions)) {
            delete existing.permissions;
          }
        } else {
          existing = parsed;
        }
      } catch (e) {
      }
    }
    const merged = {
      ...existing,
      $schema: CC_SETTINGS_SCHEMA,
      permissions: (_a = settings11.permissions) != null ? _a : { ...DEFAULT_CC_PERMISSIONS }
    };
    const content = JSON.stringify(merged, null, 2);
    await this.adapter.write(CC_SETTINGS_PATH, content);
  }
  /**
   * Check if settings file exists.
   */
  async exists() {
    return this.adapter.exists(CC_SETTINGS_PATH);
  }
  /**
   * Get permissions from CC settings.
   */
  async getPermissions() {
    var _a;
    const settings11 = await this.load();
    return (_a = settings11.permissions) != null ? _a : { ...DEFAULT_CC_PERMISSIONS };
  }
  /**
   * Update permissions in CC settings.
   */
  async updatePermissions(permissions) {
    const settings11 = await this.load();
    settings11.permissions = permissions;
    await this.save(settings11);
  }
  /**
   * Add a rule to the allow list.
   */
  async addAllowRule(rule) {
    var _a, _b;
    const permissions = await this.getPermissions();
    if (!((_a = permissions.allow) == null ? void 0 : _a.includes(rule))) {
      permissions.allow = [...(_b = permissions.allow) != null ? _b : [], rule];
      await this.updatePermissions(permissions);
    }
  }
  /**
   * Add a rule to the deny list.
   */
  async addDenyRule(rule) {
    var _a, _b;
    const permissions = await this.getPermissions();
    if (!((_a = permissions.deny) == null ? void 0 : _a.includes(rule))) {
      permissions.deny = [...(_b = permissions.deny) != null ? _b : [], rule];
      await this.updatePermissions(permissions);
    }
  }
  /**
   * Add a rule to the ask list.
   */
  async addAskRule(rule) {
    var _a, _b;
    const permissions = await this.getPermissions();
    if (!((_a = permissions.ask) == null ? void 0 : _a.includes(rule))) {
      permissions.ask = [...(_b = permissions.ask) != null ? _b : [], rule];
      await this.updatePermissions(permissions);
    }
  }
  /**
   * Remove a rule from all lists.
   */
  async removeRule(rule) {
    var _a, _b, _c;
    const permissions = await this.getPermissions();
    permissions.allow = (_a = permissions.allow) == null ? void 0 : _a.filter((r) => r !== rule);
    permissions.deny = (_b = permissions.deny) == null ? void 0 : _b.filter((r) => r !== rule);
    permissions.ask = (_c = permissions.ask) == null ? void 0 : _c.filter((r) => r !== rule);
    await this.updatePermissions(permissions);
  }
};

// src/core/storage/ClaudianSettingsStorage.ts
var CLAUDIAN_SETTINGS_PATH = ".claude/claudian-settings.json";
function normalizeCommandList(value, fallback) {
  if (!Array.isArray(value)) {
    return [...fallback];
  }
  return value.filter((item) => typeof item === "string").map((item) => item.trim()).filter((item) => item.length > 0);
}
function normalizeBlockedCommands(value) {
  const defaults = getDefaultBlockedCommands();
  if (Array.isArray(value)) {
    return {
      unix: normalizeCommandList(value, defaults.unix),
      windows: [...defaults.windows]
    };
  }
  if (!value || typeof value !== "object") {
    return defaults;
  }
  const candidate = value;
  return {
    unix: normalizeCommandList(candidate.unix, defaults.unix),
    windows: normalizeCommandList(candidate.windows, defaults.windows)
  };
}
function normalizeHostnameCliPaths(value) {
  if (!value || typeof value !== "object") {
    return {};
  }
  const result = {};
  for (const [key, val] of Object.entries(value)) {
    if (typeof val === "string" && val.trim()) {
      result[key] = val.trim();
    }
  }
  return result;
}
var ClaudianSettingsStorage = class {
  constructor(adapter) {
    this.adapter = adapter;
  }
  /**
  * Load Claudian settings from .claude/claudian-settings.json.
  * Returns default settings if file doesn't exist.
  * Throws if file exists but cannot be read or parsed.
  */
  async load() {
    if (!await this.adapter.exists(CLAUDIAN_SETTINGS_PATH)) {
      return this.getDefaults();
    }
    const content = await this.adapter.read(CLAUDIAN_SETTINGS_PATH);
    const stored = JSON.parse(content);
    const { activeConversationId: _activeConversationId, ...storedWithoutLegacy } = stored;
    const blockedCommands = normalizeBlockedCommands(stored.blockedCommands);
    const hostnameCliPaths = normalizeHostnameCliPaths(stored.claudeCliPathsByHost);
    const legacyCliPath = typeof stored.claudeCliPath === "string" ? stored.claudeCliPath : "";
    return {
      ...this.getDefaults(),
      ...storedWithoutLegacy,
      blockedCommands,
      claudeCliPath: legacyCliPath,
      claudeCliPathsByHost: hostnameCliPaths
    };
  }
  /**
   * Save Claudian settings to .claude/claudian-settings.json.
   */
  async save(settings11) {
    const content = JSON.stringify(settings11, null, 2);
    await this.adapter.write(CLAUDIAN_SETTINGS_PATH, content);
  }
  /**
   * Check if settings file exists.
   */
  async exists() {
    return this.adapter.exists(CLAUDIAN_SETTINGS_PATH);
  }
  /**
   * Update specific fields in settings.
   */
  async update(updates) {
    const current = await this.load();
    await this.save({ ...current, ...updates });
  }
  /**
   * Read legacy activeConversationId from claudian-settings.json, if present.
   * Used only for one-time migration to tabManagerState.
   */
  async getLegacyActiveConversationId() {
    if (!await this.adapter.exists(CLAUDIAN_SETTINGS_PATH)) {
      return null;
    }
    const content = await this.adapter.read(CLAUDIAN_SETTINGS_PATH);
    const stored = JSON.parse(content);
    const value = stored.activeConversationId;
    if (typeof value === "string") {
      return value;
    }
    return null;
  }
  /**
   * Remove legacy activeConversationId from claudian-settings.json.
   */
  async clearLegacyActiveConversationId() {
    if (!await this.adapter.exists(CLAUDIAN_SETTINGS_PATH)) {
      return;
    }
    const content = await this.adapter.read(CLAUDIAN_SETTINGS_PATH);
    const stored = JSON.parse(content);
    if (!("activeConversationId" in stored)) {
      return;
    }
    delete stored.activeConversationId;
    const nextContent = JSON.stringify(stored, null, 2);
    await this.adapter.write(CLAUDIAN_SETTINGS_PATH, nextContent);
  }
  /**
   * Update last used model.
   */
  async setLastModel(model, isCustom) {
    if (isCustom) {
      await this.update({ lastCustomModel: model });
    } else {
      await this.update({ lastClaudeModel: model });
    }
  }
  /**
   * Update environment hash.
   */
  async setLastEnvHash(hash) {
    await this.update({ lastEnvHash: hash });
  }
  /**
   * Get default settings (excluding separately loaded fields).
   */
  getDefaults() {
    const {
      slashCommands: _,
      ...defaults
    } = DEFAULT_SETTINGS;
    return defaults;
  }
};

// src/core/storage/McpStorage.ts
var MCP_CONFIG_PATH = ".claude/mcp.json";
var McpStorage = class _McpStorage {
  constructor(adapter) {
    this.adapter = adapter;
  }
  /** Load MCP servers from .claude/mcp.json. */
  async load() {
    var _a, _b, _c, _d, _e;
    try {
      if (!await this.adapter.exists(MCP_CONFIG_PATH)) {
        return [];
      }
      const content = await this.adapter.read(MCP_CONFIG_PATH);
      const file = JSON.parse(content);
      if (!file.mcpServers || typeof file.mcpServers !== "object") {
        return [];
      }
      const claudianMeta = (_b = (_a = file._claudian) == null ? void 0 : _a.servers) != null ? _b : {};
      const servers = [];
      for (const [name, config2] of Object.entries(file.mcpServers)) {
        if (!isValidMcpServerConfig(config2)) {
          continue;
        }
        const meta = (_c = claudianMeta[name]) != null ? _c : {};
        const disabledTools = Array.isArray(meta.disabledTools) ? meta.disabledTools.filter((tool) => typeof tool === "string") : void 0;
        const normalizedDisabledTools = disabledTools && disabledTools.length > 0 ? disabledTools : void 0;
        servers.push({
          name,
          config: config2,
          enabled: (_d = meta.enabled) != null ? _d : DEFAULT_MCP_SERVER.enabled,
          contextSaving: (_e = meta.contextSaving) != null ? _e : DEFAULT_MCP_SERVER.contextSaving,
          disabledTools: normalizedDisabledTools,
          description: meta.description
        });
      }
      return servers;
    } catch (e) {
      return [];
    }
  }
  /** Save MCP servers to .claude/mcp.json. */
  async save(servers) {
    var _a;
    const mcpServers = {};
    const claudianServers = {};
    for (const server of servers) {
      mcpServers[server.name] = server.config;
      const meta = {};
      if (server.enabled !== DEFAULT_MCP_SERVER.enabled) {
        meta.enabled = server.enabled;
      }
      if (server.contextSaving !== DEFAULT_MCP_SERVER.contextSaving) {
        meta.contextSaving = server.contextSaving;
      }
      const normalizedDisabledTools = (_a = server.disabledTools) == null ? void 0 : _a.map((tool) => tool.trim()).filter((tool) => tool.length > 0);
      if (normalizedDisabledTools && normalizedDisabledTools.length > 0) {
        meta.disabledTools = normalizedDisabledTools;
      }
      if (server.description) {
        meta.description = server.description;
      }
      if (Object.keys(meta).length > 0) {
        claudianServers[server.name] = meta;
      }
    }
    let existing = null;
    if (await this.adapter.exists(MCP_CONFIG_PATH)) {
      try {
        const raw = await this.adapter.read(MCP_CONFIG_PATH);
        const parsed = JSON.parse(raw);
        if (parsed && typeof parsed === "object") {
          existing = parsed;
        }
      } catch (e) {
        existing = null;
      }
    }
    const file = existing ? { ...existing } : {};
    file.mcpServers = mcpServers;
    const existingClaudian = existing && typeof existing._claudian === "object" ? existing._claudian : null;
    if (Object.keys(claudianServers).length > 0) {
      file._claudian = { ...existingClaudian != null ? existingClaudian : {}, servers: claudianServers };
    } else if (existingClaudian) {
      const { servers: _servers, ...rest } = existingClaudian;
      if (Object.keys(rest).length > 0) {
        file._claudian = rest;
      } else {
        delete file._claudian;
      }
    } else {
      delete file._claudian;
    }
    const content = JSON.stringify(file, null, 2);
    await this.adapter.write(MCP_CONFIG_PATH, content);
  }
  /** Check if config file exists. */
  async exists() {
    return this.adapter.exists(MCP_CONFIG_PATH);
  }
  /**
   * Parse pasted JSON (supports multiple formats).
   *
   * Formats supported:
   * 1. Full Claude Code format: { "mcpServers": { "name": {...} } }
   * 2. Single server with name: { "name": { "command": "..." } }
   * 3. Single server without name: { "command": "..." }
   */
  static parseClipboardConfig(json) {
    try {
      const parsed = JSON.parse(json);
      if (!parsed || typeof parsed !== "object") {
        throw new Error("Invalid JSON object");
      }
      if (parsed.mcpServers && typeof parsed.mcpServers === "object") {
        const servers2 = [];
        for (const [name, config2] of Object.entries(parsed.mcpServers)) {
          if (isValidMcpServerConfig(config2)) {
            servers2.push({ name, config: config2 });
          }
        }
        if (servers2.length === 0) {
          throw new Error("No valid server configs found in mcpServers");
        }
        return { servers: servers2, needsName: false };
      }
      if (isValidMcpServerConfig(parsed)) {
        return {
          servers: [{ name: "", config: parsed }],
          needsName: true
        };
      }
      const entries = Object.entries(parsed);
      if (entries.length === 1) {
        const [name, config2] = entries[0];
        if (isValidMcpServerConfig(config2)) {
          return {
            servers: [{ name, config: config2 }],
            needsName: false
          };
        }
      }
      const servers = [];
      for (const [name, config2] of entries) {
        if (isValidMcpServerConfig(config2)) {
          servers.push({ name, config: config2 });
        }
      }
      if (servers.length > 0) {
        return { servers, needsName: false };
      }
      throw new Error("Invalid MCP configuration format");
    } catch (error2) {
      if (error2 instanceof SyntaxError) {
        throw new Error("Invalid JSON");
      }
      throw error2;
    }
  }
  /**
   * Try to parse clipboard content as MCP config.
   * Returns null if not valid MCP config.
   */
  static tryParseClipboardConfig(text) {
    const trimmed = text.trim();
    if (!trimmed.startsWith("{")) {
      return null;
    }
    try {
      return _McpStorage.parseClipboardConfig(trimmed);
    } catch (e) {
      return null;
    }
  }
};

// src/core/storage/SessionStorage.ts
var SESSIONS_PATH = ".claude/sessions";
var SessionStorage = class {
  constructor(adapter) {
    this.adapter = adapter;
  }
  /** Load a conversation from its JSONL file. */
  async loadConversation(id) {
    const filePath = this.getFilePath(id);
    try {
      if (!await this.adapter.exists(filePath)) {
        return null;
      }
      const content = await this.adapter.read(filePath);
      return this.parseJSONL(content);
    } catch (e) {
      return null;
    }
  }
  /** Save a conversation to its JSONL file. */
  async saveConversation(conversation) {
    const filePath = this.getFilePath(conversation.id);
    const content = this.serializeToJSONL(conversation);
    await this.adapter.write(filePath, content);
  }
  /** Delete a conversation's JSONL file. */
  async deleteConversation(id) {
    const filePath = this.getFilePath(id);
    await this.adapter.delete(filePath);
  }
  /** List all conversation metadata (without loading full messages). */
  async listConversations() {
    const metas = [];
    try {
      const files = await this.adapter.listFiles(SESSIONS_PATH);
      for (const filePath of files) {
        if (!filePath.endsWith(".jsonl")) continue;
        try {
          const meta = await this.loadMetaOnly(filePath);
          if (meta) {
            metas.push(meta);
          }
        } catch (e) {
        }
      }
      metas.sort((a, b) => b.updatedAt - a.updatedAt);
    } catch (e) {
    }
    return metas;
  }
  /** Load all conversations (full data). Returns conversations and count of failed loads. */
  async loadAllConversations() {
    const conversations = [];
    let failedCount = 0;
    try {
      const files = await this.adapter.listFiles(SESSIONS_PATH);
      for (const filePath of files) {
        if (!filePath.endsWith(".jsonl")) continue;
        try {
          const content = await this.adapter.read(filePath);
          const conversation = this.parseJSONL(content);
          if (conversation) {
            conversations.push(conversation);
          } else {
            failedCount++;
          }
        } catch (e) {
          failedCount++;
        }
      }
      conversations.sort((a, b) => b.updatedAt - a.updatedAt);
    } catch (e) {
    }
    return { conversations, failedCount };
  }
  /** Check if any sessions exist. */
  async hasSessions() {
    const files = await this.adapter.listFiles(SESSIONS_PATH);
    return files.some((f) => f.endsWith(".jsonl"));
  }
  /** Get the file path for a conversation. */
  getFilePath(id) {
    return `${SESSIONS_PATH}/${id}.jsonl`;
  }
  /** Load only metadata from a session file (first line). */
  async loadMetaOnly(filePath) {
    const content = await this.adapter.read(filePath);
    const firstLine = content.split(/\r?\n/)[0];
    if (!firstLine) return null;
    try {
      const record2 = JSON.parse(firstLine);
      if (record2.type !== "meta") return null;
      const lines = content.split(/\r?\n/).filter((l) => l.trim());
      const messageCount = lines.length - 1;
      let preview = "New conversation";
      for (let i = 1; i < lines.length; i++) {
        try {
          const msgRecord = JSON.parse(lines[i]);
          if (msgRecord.type === "message" && msgRecord.message.role === "user") {
            const content2 = msgRecord.message.content;
            preview = content2.substring(0, 50) + (content2.length > 50 ? "..." : "");
            break;
          }
        } catch (e) {
          continue;
        }
      }
      return {
        id: record2.id,
        title: record2.title,
        createdAt: record2.createdAt,
        updatedAt: record2.updatedAt,
        lastResponseAt: record2.lastResponseAt,
        messageCount,
        preview,
        titleGenerationStatus: record2.titleGenerationStatus
      };
    } catch (e) {
      return null;
    }
  }
  /** Parse JSONL content into a Conversation object. */
  parseJSONL(content) {
    const lines = content.split(/\r?\n/).filter((l) => l.trim());
    if (lines.length === 0) return null;
    let meta = null;
    const messages = [];
    for (const line of lines) {
      try {
        const record2 = JSON.parse(line);
        if (record2.type === "meta") {
          meta = record2;
        } else if (record2.type === "message") {
          messages.push(record2.message);
        }
      } catch (e) {
      }
    }
    if (!meta) return null;
    return {
      id: meta.id,
      title: meta.title,
      createdAt: meta.createdAt,
      updatedAt: meta.updatedAt,
      lastResponseAt: meta.lastResponseAt,
      sessionId: meta.sessionId,
      messages,
      currentNote: meta.currentNote,
      usage: meta.usage,
      titleGenerationStatus: meta.titleGenerationStatus
    };
  }
  /** Serialize a Conversation to JSONL format. */
  serializeToJSONL(conversation) {
    const lines = [];
    const meta = {
      type: "meta",
      id: conversation.id,
      title: conversation.title,
      createdAt: conversation.createdAt,
      updatedAt: conversation.updatedAt,
      lastResponseAt: conversation.lastResponseAt,
      sessionId: conversation.sessionId,
      currentNote: conversation.currentNote,
      usage: conversation.usage,
      titleGenerationStatus: conversation.titleGenerationStatus
    };
    lines.push(JSON.stringify(meta));
    for (const message of conversation.messages) {
      const storedMessage = this.prepareMessageForStorage(message);
      const record2 = {
        type: "message",
        message: storedMessage
      };
      lines.push(JSON.stringify(record2));
    }
    return lines.join("\n");
  }
  /** Prepare a message for storage. */
  prepareMessageForStorage(message) {
    return message;
  }
  // ============================================
  // SDK-Native Session Metadata (Phase 1)
  // ============================================
  /**
   * Detects if a session uses SDK-native storage.
   * A session is "native" if no legacy JSONL file exists.
   *
   * Legacy sessions have id.jsonl (and optionally id.meta.json).
   * Native sessions have only id.meta.json or no files yet (SDK stores messages).
   */
  async isNativeSession(id) {
    const legacyPath = `${SESSIONS_PATH}/${id}.jsonl`;
    const legacyExists = await this.adapter.exists(legacyPath);
    return !legacyExists;
  }
  /** Get the metadata file path for a session. */
  getMetadataPath(id) {
    return `${SESSIONS_PATH}/${id}.meta.json`;
  }
  /** Save session metadata overlay for SDK-native storage. */
  async saveMetadata(metadata) {
    const filePath = this.getMetadataPath(metadata.id);
    const content = JSON.stringify(metadata, null, 2);
    await this.adapter.write(filePath, content);
  }
  /** Load session metadata for SDK-native storage. */
  async loadMetadata(id) {
    const filePath = this.getMetadataPath(id);
    try {
      if (!await this.adapter.exists(filePath)) {
        return null;
      }
      const content = await this.adapter.read(filePath);
      return JSON.parse(content);
    } catch (e) {
      return null;
    }
  }
  /** Delete session metadata. */
  async deleteMetadata(id) {
    const filePath = this.getMetadataPath(id);
    await this.adapter.delete(filePath);
  }
  /** List all native session metadata (.meta.json files without .jsonl counterparts). */
  async listNativeMetadata() {
    const metas = [];
    try {
      const files = await this.adapter.listFiles(SESSIONS_PATH);
      const metaFiles = files.filter((f) => f.endsWith(".meta.json"));
      for (const filePath of metaFiles) {
        const fileName = filePath.split("/").pop() || "";
        const id = fileName.replace(".meta.json", "");
        const legacyPath = `${SESSIONS_PATH}/${id}.jsonl`;
        const legacyExists = await this.adapter.exists(legacyPath);
        if (legacyExists) {
          continue;
        }
        try {
          const content = await this.adapter.read(filePath);
          const meta = JSON.parse(content);
          metas.push(meta);
        } catch (e) {
        }
      }
    } catch (e) {
    }
    return metas;
  }
  /**
   * List all conversations, merging legacy JSONL and native metadata sources.
   * Legacy conversations take precedence if both exist.
   */
  async listAllConversations() {
    const metas = [];
    const legacyMetas = await this.listConversations();
    metas.push(...legacyMetas);
    const nativeMetas = await this.listNativeMetadata();
    const legacyIds = new Set(legacyMetas.map((m) => m.id));
    for (const meta of nativeMetas) {
      if (!legacyIds.has(meta.id)) {
        metas.push({
          id: meta.id,
          title: meta.title,
          createdAt: meta.createdAt,
          updatedAt: meta.updatedAt,
          lastResponseAt: meta.lastResponseAt,
          messageCount: 0,
          // Native sessions don't track message count in metadata
          preview: "SDK session",
          // SDK stores messages, we don't parse them for preview
          titleGenerationStatus: meta.titleGenerationStatus,
          isNative: true
        });
      }
    }
    return metas.sort(
      (a, b) => {
        var _a, _b;
        return ((_a = b.lastResponseAt) != null ? _a : b.createdAt) - ((_b = a.lastResponseAt) != null ? _b : a.createdAt);
      }
    );
  }
  /** Convert a Conversation to SessionMetadata for native storage. */
  toSessionMetadata(conversation) {
    const toolDiffData = this.extractToolDiffData(conversation.messages);
    return {
      id: conversation.id,
      title: conversation.title,
      titleGenerationStatus: conversation.titleGenerationStatus,
      createdAt: conversation.createdAt,
      updatedAt: conversation.updatedAt,
      lastResponseAt: conversation.lastResponseAt,
      sessionId: conversation.sessionId,
      sdkSessionId: conversation.sdkSessionId,
      previousSdkSessionIds: conversation.previousSdkSessionIds,
      currentNote: conversation.currentNote,
      externalContextPaths: conversation.externalContextPaths,
      enabledMcpServers: conversation.enabledMcpServers,
      usage: conversation.usage,
      legacyCutoffAt: conversation.legacyCutoffAt,
      toolDiffData: Object.keys(toolDiffData).length > 0 ? toolDiffData : void 0
    };
  }
  /**
   * Extracts toolDiffData from messages for persistence.
   * Only collects diffData from Write/Edit tool calls that have it.
   */
  extractToolDiffData(messages) {
    const result = {};
    for (const msg of messages) {
      if (msg.role !== "assistant" || !msg.toolCalls) continue;
      for (const toolCall of msg.toolCalls) {
        if (toolCall.diffData) {
          result[toolCall.id] = toolCall.diffData;
        }
      }
    }
    return result;
  }
};

// src/core/storage/SlashCommandStorage.ts
var COMMANDS_PATH = ".claude/commands";
var SlashCommandStorage = class {
  constructor(adapter) {
    this.adapter = adapter;
  }
  /** Load all commands from .claude/commands/ recursively. */
  async loadAll() {
    const commands = [];
    try {
      const files = await this.adapter.listFilesRecursive(COMMANDS_PATH);
      for (const filePath of files) {
        if (!filePath.endsWith(".md")) continue;
        try {
          const command = await this.loadFromFile(filePath);
          if (command) {
            commands.push(command);
          }
        } catch (e) {
        }
      }
    } catch (e) {
    }
    return commands;
  }
  /** Load a single command from a file path. */
  async loadFromFile(filePath) {
    try {
      const content = await this.adapter.read(filePath);
      return this.parseFile(content, filePath);
    } catch (e) {
      return null;
    }
  }
  /** Save a command to its file. */
  async save(command) {
    const filePath = this.getFilePath(command);
    const content = this.serializeCommand(command);
    await this.adapter.write(filePath, content);
  }
  /** Delete a command file by ID. */
  async delete(commandId) {
    const files = await this.adapter.listFilesRecursive(COMMANDS_PATH);
    for (const filePath of files) {
      if (!filePath.endsWith(".md")) continue;
      const id = this.filePathToId(filePath);
      if (id === commandId) {
        await this.adapter.delete(filePath);
        return;
      }
    }
  }
  /** Check if any commands exist. */
  async hasCommands() {
    const files = await this.adapter.listFilesRecursive(COMMANDS_PATH);
    return files.some((f) => f.endsWith(".md"));
  }
  /** Get the file path for a command. */
  getFilePath(command) {
    const safeName = command.name.replace(/[^a-zA-Z0-9_/-]/g, "-");
    return `${COMMANDS_PATH}/${safeName}.md`;
  }
  /** Parse a command file into a SlashCommand object. */
  parseFile(content, filePath) {
    const parsed = parseSlashCommandContent(content);
    const id = this.filePathToId(filePath);
    const name = this.filePathToName(filePath);
    return {
      id,
      name,
      description: parsed.description,
      argumentHint: parsed.argumentHint,
      allowedTools: parsed.allowedTools,
      model: parsed.model,
      content: parsed.promptContent
    };
  }
  /** Convert a file path to a command ID (reversible encoding). */
  filePathToId(filePath) {
    const relativePath = filePath.replace(`${COMMANDS_PATH}/`, "").replace(/\.md$/, "");
    const escaped = relativePath.replace(/-/g, "-_").replace(/\//g, "--");
    return `cmd-${escaped}`;
  }
  /** Convert a file path to a command name. */
  filePathToName(filePath) {
    return filePath.replace(`${COMMANDS_PATH}/`, "").replace(/\.md$/, "");
  }
  /** Serialize a command to Markdown with YAML frontmatter. */
  serializeCommand(command) {
    const lines = ["---"];
    if (command.description) {
      lines.push(`description: ${this.yamlString(command.description)}`);
    }
    if (command.argumentHint) {
      lines.push(`argument-hint: ${this.yamlString(command.argumentHint)}`);
    }
    if (command.allowedTools && command.allowedTools.length > 0) {
      lines.push("allowed-tools:");
      for (const tool of command.allowedTools) {
        lines.push(`  - ${tool}`);
      }
    }
    if (command.model) {
      lines.push(`model: ${command.model}`);
    }
    if (lines.length === 1) {
      lines.push("");
    }
    lines.push("---");
    const parsed = parseSlashCommandContent(command.content);
    lines.push(parsed.promptContent);
    return lines.join("\n");
  }
  /** Quote a YAML string if needed. */
  yamlString(value) {
    if (value.includes(":") || value.includes("#") || value.includes("\n") || value.startsWith(" ") || value.endsWith(" ")) {
      return `"${value.replace(/"/g, '\\"')}"`;
    }
    return value;
  }
};

// src/core/storage/VaultFileAdapter.ts
var VaultFileAdapter = class {
  constructor(app) {
    this.app = app;
  }
  /** Check if a file or folder exists. */
  async exists(path9) {
    return this.app.vault.adapter.exists(path9);
  }
  /** Read file contents as string. */
  async read(path9) {
    return this.app.vault.adapter.read(path9);
  }
  /** Write content to a file, creating parent directories if needed. */
  async write(path9, content) {
    const folder = path9.substring(0, path9.lastIndexOf("/"));
    if (folder && !await this.exists(folder)) {
      await this.ensureFolder(folder);
    }
    await this.app.vault.adapter.write(path9, content);
  }
  /** Append content to a file. Creates the file if it doesn't exist. */
  async append(path9, content) {
    const folder = path9.substring(0, path9.lastIndexOf("/"));
    if (folder && !await this.exists(folder)) {
      await this.ensureFolder(folder);
    }
    if (await this.exists(path9)) {
      const existing = await this.read(path9);
      await this.app.vault.adapter.write(path9, existing + content);
    } else {
      await this.app.vault.adapter.write(path9, content);
    }
  }
  /** Delete a file if it exists. */
  async delete(path9) {
    if (await this.exists(path9)) {
      await this.app.vault.adapter.remove(path9);
    }
  }
  /** List files in a folder. Returns relative paths from the folder. */
  async listFiles(folder) {
    if (!await this.exists(folder)) {
      return [];
    }
    const listing = await this.app.vault.adapter.list(folder);
    return listing.files;
  }
  /** List subfolders in a folder. Returns relative paths from the folder. */
  async listFolders(folder) {
    if (!await this.exists(folder)) {
      return [];
    }
    const listing = await this.app.vault.adapter.list(folder);
    return listing.folders;
  }
  /** Recursively list all files in a folder and subfolders. */
  async listFilesRecursive(folder) {
    const allFiles = [];
    const processFolder = async (currentFolder) => {
      if (!await this.exists(currentFolder)) return;
      const listing = await this.app.vault.adapter.list(currentFolder);
      allFiles.push(...listing.files);
      for (const subfolder of listing.folders) {
        await processFolder(subfolder);
      }
    };
    await processFolder(folder);
    return allFiles;
  }
  /** Ensure a folder exists, creating it and parent folders if needed. */
  async ensureFolder(path9) {
    if (await this.exists(path9)) return;
    const parts = path9.split("/").filter(Boolean);
    let current = "";
    for (const part of parts) {
      current = current ? `${current}/${part}` : part;
      if (!await this.exists(current)) {
        await this.app.vault.adapter.mkdir(current);
      }
    }
  }
  /** Rename/move a file. */
  async rename(oldPath, newPath) {
    await this.app.vault.adapter.rename(oldPath, newPath);
  }
  /** Get file stats (mtime, size). Returns null if file doesn't exist or on error. */
  async stat(path9) {
    try {
      const stat = await this.app.vault.adapter.stat(path9);
      if (!stat) return null;
      return { mtime: stat.mtime, size: stat.size };
    } catch (e) {
      return null;
    }
  }
};

// src/core/storage/StorageService.ts
var CLAUDE_PATH = ".claude";
var StorageService = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = plugin.app;
    this.adapter = new VaultFileAdapter(this.app);
    this.ccSettings = new CCSettingsStorage(this.adapter);
    this.claudianSettings = new ClaudianSettingsStorage(this.adapter);
    this.commands = new SlashCommandStorage(this.adapter);
    this.sessions = new SessionStorage(this.adapter);
    this.mcp = new McpStorage(this.adapter);
  }
  /**
   * Initialize storage, running migrations if needed.
   */
  async initialize() {
    await this.ensureDirectories();
    await this.runMigrations();
    const cc = await this.ccSettings.load();
    const claudian = await this.claudianSettings.load();
    return { cc, claudian };
  }
  /**
   * Run all necessary migrations.
   */
  async runMigrations() {
    const ccExists = await this.ccSettings.exists();
    const claudianExists = await this.claudianSettings.exists();
    const dataJson = await this.loadDataJson();
    if (ccExists && !claudianExists) {
      await this.migrateFromOldSettingsJson();
    }
    if (dataJson) {
      const hasState = this.hasStateToMigrate(dataJson);
      const hasLegacyContent = this.hasLegacyContentToMigrate(dataJson);
      if (hasState) {
        await this.migrateFromDataJson(dataJson);
      }
      let legacyContentHadErrors = false;
      if (hasLegacyContent) {
        const result = await this.migrateLegacyDataJsonContent(dataJson);
        legacyContentHadErrors = result.hadErrors;
      }
      if ((hasState || hasLegacyContent) && !legacyContentHadErrors) {
        await this.clearLegacyDataJson();
      }
    }
  }
  /**
   * Check if data.json has state fields that need migration.
   */
  hasStateToMigrate(data) {
    return data.lastEnvHash !== void 0 || data.lastClaudeModel !== void 0 || data.lastCustomModel !== void 0;
  }
  /**
   * Check if data.json has legacy content (slash commands or conversations).
   */
  hasLegacyContentToMigrate(data) {
    var _a, _b, _c, _d;
    return ((_b = (_a = data.slashCommands) == null ? void 0 : _a.length) != null ? _b : 0) > 0 || ((_d = (_c = data.conversations) == null ? void 0 : _c.length) != null ? _d : 0) > 0;
  }
  /**
   * Migrate from old settings.json (with Claudian fields) to split format.
   *
   * Handles:
   * - Legacy Claudian fields (userName, model, etc.)  claudian-settings.json
   * - Legacy permissions array  CC permissions object
   * - CC env object  Claudian environmentVariables string
   * - Preserves existing CC permissions if already in CC format
   */
  async migrateFromOldSettingsJson() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
    const content = await this.adapter.read(CC_SETTINGS_PATH);
    const oldSettings = JSON.parse(content);
    const hasClaudianFields = Array.from(CLAUDIAN_ONLY_FIELDS).some(
      (field) => oldSettings[field] !== void 0
    );
    if (!hasClaudianFields) {
      return;
    }
    let environmentVariables = (_a = oldSettings.environmentVariables) != null ? _a : "";
    if (oldSettings.env && typeof oldSettings.env === "object") {
      const envFromCC = convertEnvObjectToString(oldSettings.env);
      if (envFromCC) {
        environmentVariables = mergeEnvironmentVariables(environmentVariables, envFromCC);
      }
    }
    const claudianFields = {
      userName: (_b = oldSettings.userName) != null ? _b : DEFAULT_SETTINGS.userName,
      enableBlocklist: (_c = oldSettings.enableBlocklist) != null ? _c : DEFAULT_SETTINGS.enableBlocklist,
      blockedCommands: normalizeBlockedCommands(oldSettings.blockedCommands),
      model: (_d = oldSettings.model) != null ? _d : DEFAULT_SETTINGS.model,
      thinkingBudget: (_e = oldSettings.thinkingBudget) != null ? _e : DEFAULT_SETTINGS.thinkingBudget,
      permissionMode: (_f = oldSettings.permissionMode) != null ? _f : DEFAULT_SETTINGS.permissionMode,
      excludedTags: (_g = oldSettings.excludedTags) != null ? _g : DEFAULT_SETTINGS.excludedTags,
      mediaFolder: (_h = oldSettings.mediaFolder) != null ? _h : DEFAULT_SETTINGS.mediaFolder,
      environmentVariables,
      // Merged from both sources
      envSnippets: (_i = oldSettings.envSnippets) != null ? _i : DEFAULT_SETTINGS.envSnippets,
      systemPrompt: (_j = oldSettings.systemPrompt) != null ? _j : DEFAULT_SETTINGS.systemPrompt,
      allowedExportPaths: (_k = oldSettings.allowedExportPaths) != null ? _k : DEFAULT_SETTINGS.allowedExportPaths,
      persistentExternalContextPaths: DEFAULT_SETTINGS.persistentExternalContextPaths,
      keyboardNavigation: (_l = oldSettings.keyboardNavigation) != null ? _l : DEFAULT_SETTINGS.keyboardNavigation,
      claudeCliPath: (_m = oldSettings.claudeCliPath) != null ? _m : DEFAULT_SETTINGS.claudeCliPath,
      claudeCliPathsByHost: DEFAULT_SETTINGS.claudeCliPathsByHost,
      // Migration to hostname-based handled in main.ts
      loadUserClaudeSettings: (_n = oldSettings.loadUserClaudeSettings) != null ? _n : DEFAULT_SETTINGS.loadUserClaudeSettings,
      enableAutoTitleGeneration: (_o = oldSettings.enableAutoTitleGeneration) != null ? _o : DEFAULT_SETTINGS.enableAutoTitleGeneration,
      titleGenerationModel: (_p = oldSettings.titleGenerationModel) != null ? _p : DEFAULT_SETTINGS.titleGenerationModel,
      lastClaudeModel: DEFAULT_SETTINGS.lastClaudeModel,
      lastCustomModel: DEFAULT_SETTINGS.lastCustomModel,
      lastEnvHash: DEFAULT_SETTINGS.lastEnvHash
    };
    await this.claudianSettings.save(claudianFields);
    const savedClaudian = await this.claudianSettings.load();
    if (!savedClaudian || savedClaudian.userName === void 0) {
      throw new Error("Failed to verify claudian-settings.json was saved correctly");
    }
    let ccPermissions;
    if (isLegacyPermissionsFormat(oldSettings)) {
      ccPermissions = legacyPermissionsToCCPermissions(oldSettings.permissions);
    } else if (oldSettings.permissions && typeof oldSettings.permissions === "object" && !Array.isArray(oldSettings.permissions)) {
      const existingPerms = oldSettings.permissions;
      ccPermissions = {
        allow: (_q = existingPerms.allow) != null ? _q : [],
        deny: (_r = existingPerms.deny) != null ? _r : [],
        ask: (_s = existingPerms.ask) != null ? _s : [],
        defaultMode: existingPerms.defaultMode,
        additionalDirectories: existingPerms.additionalDirectories
      };
    } else {
      ccPermissions = { ...DEFAULT_CC_PERMISSIONS };
    }
    const ccSettings = {
      $schema: "https://json.schemastore.org/claude-code-settings.json",
      permissions: ccPermissions
    };
    await this.ccSettings.save(ccSettings, true);
  }
  /**
   * Migrate state from data.json to claudian-settings.json.
   */
  async migrateFromDataJson(dataJson) {
    const claudian = await this.claudianSettings.load();
    if (dataJson.lastEnvHash !== void 0 && !claudian.lastEnvHash) {
      claudian.lastEnvHash = dataJson.lastEnvHash;
    }
    if (dataJson.lastClaudeModel !== void 0 && !claudian.lastClaudeModel) {
      claudian.lastClaudeModel = dataJson.lastClaudeModel;
    }
    if (dataJson.lastCustomModel !== void 0 && !claudian.lastCustomModel) {
      claudian.lastCustomModel = dataJson.lastCustomModel;
    }
    await this.claudianSettings.save(claudian);
  }
  /**
   * Migrate slash commands and conversations from legacy data.json.
   */
  async migrateLegacyDataJsonContent(dataJson) {
    let hadErrors = false;
    if (dataJson.slashCommands && dataJson.slashCommands.length > 0) {
      for (const command of dataJson.slashCommands) {
        try {
          const filePath = this.commands.getFilePath(command);
          if (await this.adapter.exists(filePath)) {
            continue;
          }
          await this.commands.save(command);
        } catch (e) {
          hadErrors = true;
        }
      }
    }
    if (dataJson.conversations && dataJson.conversations.length > 0) {
      for (const conversation of dataJson.conversations) {
        try {
          const filePath = this.sessions.getFilePath(conversation.id);
          if (await this.adapter.exists(filePath)) {
            continue;
          }
          await this.sessions.saveConversation(conversation);
        } catch (e) {
          hadErrors = true;
        }
      }
    }
    return { hadErrors };
  }
  /**
   * Clear legacy data.json after successful migration.
   */
  async clearLegacyDataJson() {
    const dataJson = await this.loadDataJson();
    if (!dataJson) {
      return;
    }
    const cleaned = { ...dataJson };
    delete cleaned.lastEnvHash;
    delete cleaned.lastClaudeModel;
    delete cleaned.lastCustomModel;
    delete cleaned.conversations;
    delete cleaned.slashCommands;
    delete cleaned.migrationVersion;
    if (Object.keys(cleaned).length === 0) {
      await this.plugin.saveData({});
      return;
    }
    await this.plugin.saveData(cleaned);
  }
  /**
   * Load legacy data.json content.
   */
  async loadDataJson() {
    try {
      const data = await this.plugin.loadData();
      return data || null;
    } catch (e) {
      return null;
    }
  }
  /**
   * Ensure all required directories exist.
   */
  async ensureDirectories() {
    await this.adapter.ensureFolder(CLAUDE_PATH);
    await this.adapter.ensureFolder(COMMANDS_PATH);
    await this.adapter.ensureFolder(SESSIONS_PATH);
  }
  /**
   * Get the vault file adapter for direct file operations.
   */
  getAdapter() {
    return this.adapter;
  }
  // ============================================================================
  // Convenience methods for common operations
  // ============================================================================
  /**
   * Get CC permissions.
   */
  async getPermissions() {
    return this.ccSettings.getPermissions();
  }
  /**
   * Update CC permissions.
   */
  async updatePermissions(permissions) {
    return this.ccSettings.updatePermissions(permissions);
  }
  /**
   * Add a rule to allow list.
   */
  async addAllowRule(rule) {
    return this.ccSettings.addAllowRule(createPermissionRule(rule));
  }
  /**
   * Add a rule to deny list.
   */
  async addDenyRule(rule) {
    return this.ccSettings.addDenyRule(createPermissionRule(rule));
  }
  /**
   * Remove a permission rule from all lists.
   */
  async removePermissionRule(rule) {
    return this.ccSettings.removeRule(createPermissionRule(rule));
  }
  /**
   * Update Claudian settings.
   */
  async updateClaudianSettings(updates) {
    return this.claudianSettings.update(updates);
  }
  /**
   * Save Claudian settings.
   */
  async saveClaudianSettings(settings11) {
    return this.claudianSettings.save(settings11);
  }
  /**
   * Load Claudian settings.
   */
  async loadClaudianSettings() {
    return this.claudianSettings.load();
  }
  /**
   * Get legacy activeConversationId from storage (claudian-settings.json or data.json).
   */
  async getLegacyActiveConversationId() {
    const fromSettings = await this.claudianSettings.getLegacyActiveConversationId();
    if (fromSettings) {
      return fromSettings;
    }
    const dataJson = await this.loadDataJson();
    if (dataJson && typeof dataJson.activeConversationId === "string") {
      return dataJson.activeConversationId;
    }
    return null;
  }
  /**
   * Remove legacy activeConversationId from storage after migration.
   */
  async clearLegacyActiveConversationId() {
    await this.claudianSettings.clearLegacyActiveConversationId();
    const dataJson = await this.loadDataJson();
    if (!dataJson || !("activeConversationId" in dataJson)) {
      return;
    }
    const cleaned = { ...dataJson };
    delete cleaned.activeConversationId;
    await this.plugin.saveData(cleaned);
  }
  // ============================================================================
  // Tab Manager State Persistence
  // ============================================================================
  /**
   * Get tab manager state from data.json with runtime validation.
   */
  async getTabManagerState() {
    try {
      const data = await this.plugin.loadData();
      if (data == null ? void 0 : data.tabManagerState) {
        return this.validateTabManagerState(data.tabManagerState);
      }
      return null;
    } catch (e) {
      return null;
    }
  }
  /**
   * Validates and sanitizes tab manager state from storage.
   * Returns null if the data is invalid or corrupted.
   */
  validateTabManagerState(data) {
    if (!data || typeof data !== "object") {
      return null;
    }
    const state = data;
    if (!Array.isArray(state.openTabs)) {
      return null;
    }
    const validatedTabs = [];
    for (const tab of state.openTabs) {
      if (!tab || typeof tab !== "object") {
        continue;
      }
      const tabObj = tab;
      if (typeof tabObj.tabId !== "string") {
        continue;
      }
      validatedTabs.push({
        tabId: tabObj.tabId,
        conversationId: typeof tabObj.conversationId === "string" ? tabObj.conversationId : null
      });
    }
    const activeTabId = typeof state.activeTabId === "string" ? state.activeTabId : null;
    return {
      openTabs: validatedTabs,
      activeTabId
    };
  }
  /**
   * Set tab manager state in data.json.
   */
  async setTabManagerState(state) {
    try {
      const data = await this.plugin.loadData() || {};
      data.tabManagerState = state;
      await this.plugin.saveData(data);
    } catch (e) {
    }
  }
};

// src/features/chat/ClaudianView.ts
var import_obsidian20 = require("obsidian");

// src/features/chat/constants.ts
var LOGO_SVG = {
  viewBox: "0 -.01 39.5 39.53",
  width: "18",
  height: "18",
  path: "m7.75 26.27 7.77-4.36.13-.38-.13-.21h-.38l-1.3-.08-4.44-.12-3.85-.16-3.73-.2-.94-.2-.88-1.16.09-.58.79-.53 1.13.1 2.5.17 3.75.26 2.72.16 4.03.42h.64l.09-.26-.22-.16-.17-.16-3.88-2.63-4.2-2.78-2.2-1.6-1.19-.81-.6-.76-.26-1.66 1.08-1.19 1.45.1.37.1 1.47 1.13 3.14 2.43 4.1 3.02.6.5.24-.17.03-.12-.27-.45-2.23-4.03-2.38-4.1-1.06-1.7-.28-1.02c-.1-.42-.17-.77-.17-1.2l1.23-1.67.68-.22 1.64.22.69.6 1.02 2.33 1.65 3.67 2.56 4.99.75 1.48.4 1.37.15.42h.26v-.24l.21-2.81.39-3.45.38-4.44.13-1.25.62-1.5 1.23-.81.96.46.79 1.13-.11.73-.47 3.05-.92 4.78-.6 3.2h.35l.4-.4 1.62-2.15 2.72-3.4 1.2-1.35 1.4-1.49.9-.71h1.7l1.25 1.86-.56 1.92-1.75 2.22-1.45 1.88-2.08 2.8-1.3 2.24.12.18.31-.03 4.7-1 2.54-.46 3.03-.52 1.37.64.15.65-.54 1.33-3.24.8-3.8.76-5.66 1.34-.07.05.08.1 2.55.24 1.09.06h2.67l4.97.37 1.3.86.78 1.05-.13.8-2 1.02-2.7-.64-6.3-1.5-2.16-.54h-.3v.18l1.8 1.76 3.3 2.98 4.13 3.84.21.95-.53.75-.56-.08-3.63-2.73-1.4-1.23-3.17-2.67h-.21v.28l.73 1.07 3.86 5.8.2 1.78-.28.58-1 .35-1.1-.2-2.26-3.17-2.33-3.57-1.88-3.2-.23.13-1.11 11.95-.52.61-1.2.46-1-.76-.53-1.23.53-2.43.64-3.17.52-2.52.47-3.13.28-1.04-.02-.07-.23.03-2.36 3.24-3.59 4.85-2.84 3.04-.68.27-1.18-.61.11-1.09.66-.97 3.93-5 2.37-3.1 1.53-1.79-.01-.26h-.09l-10.44 6.78-1.86.24-.8-.75.1-1.23.38-.4 3.14-2.16z",
  fill: "#d97757"
};
var FLAVOR_TEXTS = [
  // Classic
  "Thinking...",
  "Pondering...",
  "Processing...",
  "Analyzing...",
  "Considering...",
  "Working on it...",
  "One moment...",
  "On it...",
  // Thoughtful
  "Ruminating...",
  "Contemplating...",
  "Reflecting...",
  "Mulling it over...",
  "Let me think...",
  "Hmm...",
  "Cogitating...",
  "Deliberating...",
  "Weighing options...",
  "Gathering thoughts...",
  // Playful
  "Brewing ideas...",
  "Connecting dots...",
  "Assembling thoughts...",
  "Spinning up neurons...",
  "Loading brilliance...",
  "Consulting the oracle...",
  "Summoning knowledge...",
  "Crunching thoughts...",
  "Dusting off neurons...",
  "Wrangling ideas...",
  "Herding thoughts...",
  "Juggling concepts...",
  "Untangling this...",
  "Piecing it together...",
  // Cozy
  "Sipping coffee...",
  "Warming up...",
  "Getting cozy with this...",
  "Settling in...",
  "Making tea...",
  "Grabbing a snack...",
  // Technical
  "Parsing...",
  "Compiling thoughts...",
  "Running inference...",
  "Querying the void...",
  "Defragmenting brain...",
  "Allocating memory...",
  "Optimizing...",
  "Indexing...",
  "Syncing neurons...",
  // Zen
  "Breathing...",
  "Finding clarity...",
  "Channeling focus...",
  "Centering...",
  "Aligning chakras...",
  "Meditating on this...",
  // Whimsical
  "Asking the stars...",
  "Reading tea leaves...",
  "Shaking the magic 8-ball...",
  "Consulting ancient scrolls...",
  "Decoding the matrix...",
  "Communing with the ether...",
  "Peering into the abyss...",
  "Channeling the cosmos...",
  // Action
  "Diving in...",
  "Rolling up sleeves...",
  "Getting to work...",
  "Tackling this...",
  "On the case...",
  "Investigating...",
  "Exploring...",
  "Digging deeper...",
  // Casual
  "Bear with me...",
  "Hang tight...",
  "Just a sec...",
  "Working my magic...",
  "Almost there...",
  "Give me a moment..."
];

// node_modules/@anthropic-ai/claude-agent-sdk/sdk.mjs
var import_path4 = require("path");
var import_url = require("url");
var import_events = require("events");
var import_child_process2 = require("child_process");
var import_readline = require("readline");
var fs5 = __toESM(require("fs"), 1);
var import_promises = require("fs/promises");
var import_path5 = require("path");
var import_os = require("os");
var import_path6 = require("path");
var import_process = require("process");
var import_fs = require("fs");
var import_crypto = require("crypto");
var import_crypto2 = require("crypto");
var import_fs2 = require("fs");
var import_path7 = require("path");
var import_crypto3 = require("crypto");
var import_path8 = require("path");
var import_url2 = require("url");
var import_meta = {};
var __create2 = Object.create;
var __getProtoOf2 = Object.getPrototypeOf;
var __defProp2 = Object.defineProperty;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __toESM2 = (mod, isNodeMode, target) => {
  target = mod != null ? __create2(__getProtoOf2(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames2(mod))
    if (!__hasOwnProp2.call(to, key))
      __defProp2(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var require_code = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
  class _CodeOrName {
  }
  exports._CodeOrName = _CodeOrName;
  exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class Name extends _CodeOrName {
    constructor(s) {
      super();
      if (!exports.IDENTIFIER.test(s))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports.Name = Name;
  class _Code extends _CodeOrName {
    constructor(code) {
      super();
      this._items = typeof code === "string" ? [code] : code;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a;
      return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
    }
    get names() {
      var _a;
      return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c) => {
        if (c instanceof Name)
          names[c.str] = (names[c.str] || 0) + 1;
        return names;
      }, {});
    }
  }
  exports._Code = _Code;
  exports.nil = new _Code("");
  function _(strs, ...args) {
    const code = [strs[0]];
    let i = 0;
    while (i < args.length) {
      addCodeArg(code, args[i]);
      code.push(strs[++i]);
    }
    return new _Code(code);
  }
  exports._ = _;
  var plus = new _Code("+");
  function str(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i = 0;
    while (i < args.length) {
      expr.push(plus);
      addCodeArg(expr, args[i]);
      expr.push(plus, safeStringify(strs[++i]));
    }
    optimize(expr);
    return new _Code(expr);
  }
  exports.str = str;
  function addCodeArg(code, arg) {
    if (arg instanceof _Code)
      code.push(...arg._items);
    else if (arg instanceof Name)
      code.push(arg);
    else
      code.push(interpolate(arg));
  }
  exports.addCodeArg = addCodeArg;
  function optimize(expr) {
    let i = 1;
    while (i < expr.length - 1) {
      if (expr[i] === plus) {
        const res = mergeExprItems(expr[i - 1], expr[i + 1]);
        if (res !== void 0) {
          expr.splice(i - 1, 3, res);
          continue;
        }
        expr[i++] = "+";
      }
      i++;
    }
  }
  function mergeExprItems(a, b) {
    if (b === '""')
      return a;
    if (a === '""')
      return b;
    if (typeof a == "string") {
      if (b instanceof Name || a[a.length - 1] !== '"')
        return;
      if (typeof b != "string")
        return `${a.slice(0, -1)}${b}"`;
      if (b[0] === '"')
        return a.slice(0, -1) + b.slice(1);
      return;
    }
    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
      return `"${a}${b.slice(1)}`;
    return;
  }
  function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
  }
  exports.strConcat = strConcat;
  function interpolate(x) {
    return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
  }
  function stringify(x) {
    return new _Code(safeStringify(x));
  }
  exports.stringify = stringify;
  function safeStringify(x) {
    return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  exports.safeStringify = safeStringify;
  function getProperty(key) {
    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
  }
  exports.getProperty = getProperty;
  function getEsmExportName(key) {
    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
      return new _Code(`${key}`);
    }
    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
  }
  exports.getEsmExportName = getEsmExportName;
  function regexpCode(rx) {
    return new _Code(rx.toString());
  }
  exports.regexpCode = regexpCode;
});
var require_scope = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
  var code_1 = require_code();
  class ValueError extends Error {
    constructor(name) {
      super(`CodeGen: "code" for ${name} not defined`);
      this.value = name.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
  exports.varKinds = {
    const: new code_1.Name("const"),
    let: new code_1.Name("let"),
    var: new code_1.Name("var")
  };
  class Scope {
    constructor({ prefixes, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
      return new code_1.Name(this._newName(prefix));
    }
    _newName(prefix) {
      const ng = this._names[prefix] || this._nameGroup(prefix);
      return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
      var _a, _b;
      if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
        throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
      }
      return this._names[prefix] = { prefix, index: 0 };
    }
  }
  exports.Scope = Scope;
  class ValueScopeName extends code_1.Name {
    constructor(prefix, nameStr) {
      super(nameStr);
      this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
      this.value = value;
      this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
    }
  }
  exports.ValueScopeName = ValueScopeName;
  var line = (0, code_1._)`\n`;
  class ValueScope extends Scope {
    constructor(opts) {
      super(opts);
      this._values = {};
      this._scope = opts.scope;
      this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
    }
    get() {
      return this._scope;
    }
    name(prefix) {
      return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
      var _a;
      if (value.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const name = this.toName(nameOrPrefix);
      const { prefix } = name;
      const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
      let vs = this._values[prefix];
      if (vs) {
        const _name = vs.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs = this._values[prefix] = /* @__PURE__ */ new Map();
      }
      vs.set(valueKey, name);
      const s = this._scope[prefix] || (this._scope[prefix] = []);
      const itemIndex = s.length;
      s[itemIndex] = value.ref;
      name.setValue(value, { property: prefix, itemIndex });
      return name;
    }
    getValue(prefix, keyOrRef) {
      const vs = this._values[prefix];
      if (!vs)
        return;
      return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
      return this._reduceValues(values, (name) => {
        if (name.scopePath === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return (0, code_1._)`${scopeName}${name.scopePath}`;
      });
    }
    scopeCode(values = this._values, usedValues, getCode) {
      return this._reduceValues(values, (name) => {
        if (name.value === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return name.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
      let code = code_1.nil;
      for (const prefix in values) {
        const vs = values[prefix];
        if (!vs)
          continue;
        const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
        vs.forEach((name) => {
          if (nameSet.has(name))
            return;
          nameSet.set(name, UsedValueState.Started);
          let c = valueCode(name);
          if (c) {
            const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
            code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
          } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
            code = (0, code_1._)`${code}${c}${this.opts._n}`;
          } else {
            throw new ValueError(name);
          }
          nameSet.set(name, UsedValueState.Completed);
        });
      }
      return code;
    }
  }
  exports.ValueScope = ValueScope;
});
var require_codegen = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
  var code_1 = require_code();
  var scope_1 = require_scope();
  var code_2 = require_code();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = require_scope();
  Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports.operators = {
    GT: new code_1._Code(">"),
    GTE: new code_1._Code(">="),
    LT: new code_1._Code("<"),
    LTE: new code_1._Code("<="),
    EQ: new code_1._Code("==="),
    NEQ: new code_1._Code("!=="),
    NOT: new code_1._Code("!"),
    OR: new code_1._Code("||"),
    AND: new code_1._Code("&&"),
    ADD: new code_1._Code("+")
  };
  class Node {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }
  class Def extends Node {
    constructor(varKind, name, rhs) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.rhs = rhs;
    }
    render({ es5, _n }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names, constants) {
      if (!names[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names, constants);
      return this;
    }
    get names() {
      return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
    }
  }
  class Assign extends Node {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n }) {
      return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names, constants) {
      if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names, constants);
      return this;
    }
    get names() {
      const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
      return addExprNames(names, this.rhs);
    }
  }
  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
    }
  }
  class Label extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      return `${this.label}:` + _n;
    }
  }
  class Break extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n;
    }
  }
  class Throw extends Node {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render({ _n }) {
      return `throw ${this.error};` + _n;
    }
    get names() {
      return this.error.names;
    }
  }
  class AnyCode extends Node {
    constructor(code) {
      super();
      this.code = code;
    }
    render({ _n }) {
      return `${this.code};` + _n;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(names, constants) {
      this.code = optimizeExpr(this.code, names, constants);
      return this;
    }
    get names() {
      return this.code instanceof code_1._CodeOrName ? this.code.names : {};
    }
  }
  class ParentNode extends Node {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts) {
      return this.nodes.reduce((code, n) => code + n.render(opts), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i].optimizeNodes();
        if (Array.isArray(n))
          nodes.splice(i, 1, ...n);
        else if (n)
          nodes[i] = n;
        else
          nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    optimizeNames(names, constants) {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i];
        if (n.optimizeNames(names, constants))
          continue;
        subtractNames(names, n.names);
        nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((names, n) => addNames(names, n.names), {});
    }
  }
  class BlockNode extends ParentNode {
    render(opts) {
      return "{" + opts._n + super.render(opts) + "}" + opts._n;
    }
  }
  class Root extends ParentNode {
  }
  class Else extends BlockNode {
  }
  Else.kind = "else";
  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts) {
      let code = `if(${this.condition})` + super.render(opts);
      if (this.else)
        code += "else " + this.else.render(opts);
      return code;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e = this.else;
      if (e) {
        const ns = e.optimizeNodes();
        e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
      }
      if (e) {
        if (cond === false)
          return e instanceof If ? e : e.nodes;
        if (this.nodes.length)
          return this;
        return new If(not(cond), e instanceof If ? [e] : e.nodes);
      }
      if (cond === false || !this.nodes.length)
        return;
      return this;
    }
    optimizeNames(names, constants) {
      var _a;
      this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
      if (!(super.optimizeNames(names, constants) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names, constants);
      return this;
    }
    get names() {
      const names = super.names;
      addExprNames(names, this.condition);
      if (this.else)
        addNames(names, this.else.names);
      return names;
    }
  }
  If.kind = "if";
  class For extends BlockNode {
  }
  For.kind = "for";
  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts) {
      return `for(${this.iteration})` + super.render(opts);
    }
    optimizeNames(names, constants) {
      if (!super.optimizeNames(names, constants))
        return;
      this.iteration = optimizeExpr(this.iteration, names, constants);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }
  class ForRange extends For {
    constructor(varKind, name, from, to) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.from = from;
      this.to = to;
    }
    render(opts) {
      const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
      const { name, from, to } = this;
      return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
    }
    get names() {
      const names = addExprNames(super.names, this.from);
      return addExprNames(names, this.to);
    }
  }
  class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
      super();
      this.loop = loop;
      this.varKind = varKind;
      this.name = name;
      this.iterable = iterable;
    }
    render(opts) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
    }
    optimizeNames(names, constants) {
      if (!super.optimizeNames(names, constants))
        return;
      this.iterable = optimizeExpr(this.iterable, names, constants);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }
  class Func extends BlockNode {
    constructor(name, args, async) {
      super();
      this.name = name;
      this.args = args;
      this.async = async;
    }
    render(opts) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts);
    }
  }
  Func.kind = "func";
  class Return extends ParentNode {
    render(opts) {
      return "return " + super.render(opts);
    }
  }
  Return.kind = "return";
  class Try extends BlockNode {
    render(opts) {
      let code = "try" + super.render(opts);
      if (this.catch)
        code += this.catch.render(opts);
      if (this.finally)
        code += this.finally.render(opts);
      return code;
    }
    optimizeNodes() {
      var _a, _b;
      super.optimizeNodes();
      (_a = this.catch) === null || _a === void 0 || _a.optimizeNodes();
      (_b = this.finally) === null || _b === void 0 || _b.optimizeNodes();
      return this;
    }
    optimizeNames(names, constants) {
      var _a, _b;
      super.optimizeNames(names, constants);
      (_a = this.catch) === null || _a === void 0 || _a.optimizeNames(names, constants);
      (_b = this.finally) === null || _b === void 0 || _b.optimizeNames(names, constants);
      return this;
    }
    get names() {
      const names = super.names;
      if (this.catch)
        addNames(names, this.catch.names);
      if (this.finally)
        addNames(names, this.finally.names);
      return names;
    }
  }
  class Catch extends BlockNode {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render(opts) {
      return `catch(${this.error})` + super.render(opts);
    }
  }
  Catch.kind = "catch";
  class Finally extends BlockNode {
    render(opts) {
      return "finally" + super.render(opts);
    }
  }
  Finally.kind = "finally";
  class CodeGen {
    constructor(extScope, opts = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = { ...opts, _n: opts.lines ? `
` : "" };
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    name(prefix) {
      return this._scope.name(prefix);
    }
    scopeName(prefix) {
      return this._extScope.name(prefix);
    }
    scopeValue(prefixOrName, value) {
      const name = this._extScope.value(prefixOrName, value);
      const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
      vs.add(name);
      return name;
    }
    getScopeValue(prefix, keyOrRef) {
      return this._extScope.getValue(prefix, keyOrRef);
    }
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
      const name = this._scope.toName(nameOrPrefix);
      if (rhs !== void 0 && constant)
        this._constants[name.str] = rhs;
      this._leafNode(new Def(varKind, name, rhs));
      return name;
    }
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
    }
    code(c) {
      if (typeof c == "function")
        c();
      else if (c !== code_1.nil)
        this._leafNode(new AnyCode(c));
      return this;
    }
    object(...keyValues) {
      const code = ["{"];
      for (const [key, value] of keyValues) {
        if (code.length > 1)
          code.push(",");
        code.push(key);
        if (key !== value || this.opts.es5) {
          code.push(":");
          (0, code_1.addCodeArg)(code, value);
        }
      }
      code.push("}");
      return new code_1._Code(code);
    }
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    else() {
      return this._elseNode(new Else());
    }
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node, forBody) {
      this._blockNode(node);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
    }
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
          this.var(name, (0, code_1._)`${arr}[${i}]`);
          forBody(name);
        });
      }
      return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
      }
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    endFor() {
      return this._endBlockNode(For);
    }
    label(label) {
      return this._leafNode(new Label(label));
    }
    break(label) {
      return this._leafNode(new Break(label));
    }
    return(value) {
      const node = new Return();
      this._blockNode(node);
      this.code(value);
      if (node.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node = new Try();
      this._blockNode(node);
      this.code(tryBody);
      if (catchCode) {
        const error2 = this.name("e");
        this._currNode = node.catch = new Catch(error2);
        catchCode(error2);
      }
      if (finallyCode) {
        this._currNode = node.finally = new Finally();
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    throw(error2) {
      return this._leafNode(new Throw(error2));
    }
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    func(name, args = code_1.nil, async, funcBody) {
      this._blockNode(new Func(name, args, async));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n = 1) {
      while (n-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node) {
      this._currNode.nodes.push(node);
      return this;
    }
    _blockNode(node) {
      this._currNode.nodes.push(node);
      this._nodes.push(node);
    }
    _endBlockNode(N1, N2) {
      const n = this._currNode;
      if (n instanceof N1 || N2 && n instanceof N2) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node) {
      const n = this._currNode;
      if (!(n instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n.else = node;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns = this._nodes;
      return ns[ns.length - 1];
    }
    set _currNode(node) {
      const ns = this._nodes;
      ns[ns.length - 1] = node;
    }
  }
  exports.CodeGen = CodeGen;
  function addNames(names, from) {
    for (const n in from)
      names[n] = (names[n] || 0) + (from[n] || 0);
    return names;
  }
  function addExprNames(names, from) {
    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
  }
  function optimizeExpr(expr, names, constants) {
    if (expr instanceof code_1.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_1._Code(expr._items.reduce((items, c) => {
      if (c instanceof code_1.Name)
        c = replaceName(c);
      if (c instanceof code_1._Code)
        items.push(...c._items);
      else
        items.push(c);
      return items;
    }, []));
    function replaceName(n) {
      const c = constants[n.str];
      if (c === void 0 || names[n.str] !== 1)
        return n;
      delete names[n.str];
      return c;
    }
    function canOptimize(e) {
      return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
    }
  }
  function subtractNames(names, from) {
    for (const n in from)
      names[n] = (names[n] || 0) - (from[n] || 0);
  }
  function not(x) {
    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
  }
  exports.not = not;
  var andCode = mappend(exports.operators.AND);
  function and(...args) {
    return args.reduce(andCode);
  }
  exports.and = and;
  var orCode = mappend(exports.operators.OR);
  function or(...args) {
    return args.reduce(orCode);
  }
  exports.or = or;
  function mappend(op) {
    return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
  }
  function par(x) {
    return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
  }
});
var require_util = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
  var codegen_1 = require_codegen();
  var code_1 = require_code();
  function toHash(arr) {
    const hash = {};
    for (const item of arr)
      hash[item] = true;
    return hash;
  }
  exports.toHash = toHash;
  function alwaysValidSchema(it, schema) {
    if (typeof schema == "boolean")
      return schema;
    if (Object.keys(schema).length === 0)
      return true;
    checkUnknownRules(it, schema);
    return !schemaHasRules(schema, it.self.RULES.all);
  }
  exports.alwaysValidSchema = alwaysValidSchema;
  function checkUnknownRules(it, schema = it.schema) {
    const { opts, self: self2 } = it;
    if (!opts.strictSchema)
      return;
    if (typeof schema === "boolean")
      return;
    const rules = self2.RULES.keywords;
    for (const key in schema) {
      if (!rules[key])
        checkStrictMode(it, `unknown keyword: "${key}"`);
    }
  }
  exports.checkUnknownRules = checkUnknownRules;
  function schemaHasRules(schema, rules) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (rules[key])
        return true;
    return false;
  }
  exports.schemaHasRules = schemaHasRules;
  function schemaHasRulesButRef(schema, RULES) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (key !== "$ref" && RULES.all[key])
        return true;
    return false;
  }
  exports.schemaHasRulesButRef = schemaHasRulesButRef;
  function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
    if (!$data) {
      if (typeof schema == "number" || typeof schema == "boolean")
        return schema;
      if (typeof schema == "string")
        return (0, codegen_1._)`${schema}`;
    }
    return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
  }
  exports.schemaRefOrVal = schemaRefOrVal;
  function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
  }
  exports.unescapeFragment = unescapeFragment;
  function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
  }
  exports.escapeFragment = escapeFragment;
  function escapeJsonPointer(str) {
    if (typeof str == "number")
      return `${str}`;
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  exports.escapeJsonPointer = escapeJsonPointer;
  function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  exports.unescapeJsonPointer = unescapeJsonPointer;
  function eachItem(xs, f) {
    if (Array.isArray(xs)) {
      for (const x of xs)
        f(x);
    } else {
      f(xs);
    }
  }
  exports.eachItem = eachItem;
  function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues: mergeValues3, resultToName }) {
    return (gen, from, to, toName) => {
      const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues3(from, to);
      return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
    };
  }
  exports.mergeEvaluated = {
    props: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
        gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
      }),
      mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
        if (from === true) {
          gen.assign(to, true);
        } else {
          gen.assign(to, (0, codegen_1._)`${to} || {}`);
          setEvaluated(gen, to, from);
        }
      }),
      mergeValues: (from, to) => from === true ? true : { ...from, ...to },
      resultToName: evaluatedPropsToName
    }),
    items: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
      mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
      mergeValues: (from, to) => from === true ? true : Math.max(from, to),
      resultToName: (gen, items) => gen.var("items", items)
    })
  };
  function evaluatedPropsToName(gen, ps) {
    if (ps === true)
      return gen.var("props", true);
    const props = gen.var("props", (0, codegen_1._)`{}`);
    if (ps !== void 0)
      setEvaluated(gen, props, ps);
    return props;
  }
  exports.evaluatedPropsToName = evaluatedPropsToName;
  function setEvaluated(gen, props, ps) {
    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
  }
  exports.setEvaluated = setEvaluated;
  var snippets = {};
  function useFunc(gen, f) {
    return gen.scopeValue("func", {
      ref: f,
      code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
    });
  }
  exports.useFunc = useFunc;
  var Type;
  (function(Type2) {
    Type2[Type2["Num"] = 0] = "Num";
    Type2[Type2["Str"] = 1] = "Str";
  })(Type || (exports.Type = Type = {}));
  function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    if (dataProp instanceof codegen_1.Name) {
      const isNumber = dataPropType === Type.Num;
      return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
  }
  exports.getErrorPath = getErrorPath;
  function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
    if (!mode)
      return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
      throw new Error(msg);
    it.self.logger.warn(msg);
  }
  exports.checkStrictMode = checkStrictMode;
});
var require_names = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var names = {
    data: new codegen_1.Name("data"),
    valCxt: new codegen_1.Name("valCxt"),
    instancePath: new codegen_1.Name("instancePath"),
    parentData: new codegen_1.Name("parentData"),
    parentDataProperty: new codegen_1.Name("parentDataProperty"),
    rootData: new codegen_1.Name("rootData"),
    dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
    vErrors: new codegen_1.Name("vErrors"),
    errors: new codegen_1.Name("errors"),
    this: new codegen_1.Name("this"),
    self: new codegen_1.Name("self"),
    scope: new codegen_1.Name("scope"),
    json: new codegen_1.Name("json"),
    jsonPos: new codegen_1.Name("jsonPos"),
    jsonLen: new codegen_1.Name("jsonLen"),
    jsonPart: new codegen_1.Name("jsonPart")
  };
  exports.default = names;
});
var require_errors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var names_1 = require_names();
  exports.keywordError = {
    message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
  };
  exports.keyword$DataError = {
    message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
  };
  function reportError(cxt, error2 = exports.keywordError, errorPaths, overrideAllErrors) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen, errObj);
    } else {
      returnErrors(it, (0, codegen_1._)`[${errObj}]`);
    }
  }
  exports.reportError = reportError;
  function reportExtraError(cxt, error2 = exports.keywordError, errorPaths) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it, names_1.default.vErrors);
    }
  }
  exports.reportExtraError = reportExtraError;
  function resetErrorsCount(gen, errsCount) {
    gen.assign(names_1.default.errors, errsCount);
    gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
  }
  exports.resetErrorsCount = resetErrorsCount;
  function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
    if (errsCount === void 0)
      throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_1.default.errors, (i) => {
      gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
      gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
      gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
      if (it.opts.verbose) {
        gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
        gen.assign((0, codegen_1._)`${err}.data`, data);
      }
    });
  }
  exports.extendErrors = extendErrors;
  function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
    gen.code((0, codegen_1._)`${names_1.default.errors}++`);
  }
  function returnErrors(it, errs) {
    const { gen, validateName, schemaEnv } = it;
    if (schemaEnv.$async) {
      gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
      gen.return(false);
    }
  }
  var E = {
    keyword: new codegen_1.Name("keyword"),
    schemaPath: new codegen_1.Name("schemaPath"),
    params: new codegen_1.Name("params"),
    propertyName: new codegen_1.Name("propertyName"),
    message: new codegen_1.Name("message"),
    schema: new codegen_1.Name("schema"),
    parentSchema: new codegen_1.Name("parentSchema")
  };
  function errorObjectCode(cxt, error2, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return (0, codegen_1._)`{}`;
    return errorObject(cxt, error2, errorPaths);
  }
  function errorObject(cxt, error2, errorPaths = {}) {
    const { gen, it } = cxt;
    const keyValues = [
      errorInstancePath(it, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error2, keyValues);
    return gen.object(...keyValues);
  }
  function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
  }
  function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
    if (schemaPath) {
      schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
    }
    return [E.schemaPath, schPath];
  }
  function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword, data, schemaValue, it } = cxt;
    const { opts, propertyName, topSchemaRef, schemaPath } = it;
    keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
    if (opts.messages) {
      keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts.verbose) {
      keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
    }
    if (propertyName)
      keyValues.push([E.propertyName, propertyName]);
  }
});
var require_boolSchema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
  var errors_1 = require_errors();
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var boolError = {
    message: "boolean schema is false"
  };
  function topBoolOrEmptySchema(it) {
    const { gen, schema, validateName } = it;
    if (schema === false) {
      falseSchemaError(it, false);
    } else if (typeof schema == "object" && schema.$async === true) {
      gen.return(names_1.default.data);
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, null);
      gen.return(true);
    }
  }
  exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
  function boolOrEmptySchema(it, valid) {
    const { gen, schema } = it;
    if (schema === false) {
      gen.var(valid, false);
      falseSchemaError(it);
    } else {
      gen.var(valid, true);
    }
  }
  exports.boolOrEmptySchema = boolOrEmptySchema;
  function falseSchemaError(it, overrideAllErrors) {
    const { gen, data } = it;
    const cxt = {
      gen,
      keyword: "false schema",
      data,
      schema: false,
      schemaCode: false,
      schemaValue: false,
      params: {},
      it
    };
    (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
  }
});
var require_rules = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRules = exports.isJSONType = void 0;
  var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
  var jsonTypes = new Set(_jsonTypes);
  function isJSONType(x) {
    return typeof x == "string" && jsonTypes.has(x);
  }
  exports.isJSONType = isJSONType;
  function getRules() {
    const groups = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...groups, integer: true, boolean: true, null: true },
      rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  exports.getRules = getRules;
});
var require_applicability = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
  function schemaHasRulesForType({ schema, self: self2 }, type) {
    const group = self2.RULES.types[type];
    return group && group !== true && shouldUseGroup(schema, group);
  }
  exports.schemaHasRulesForType = schemaHasRulesForType;
  function shouldUseGroup(schema, group) {
    return group.rules.some((rule) => shouldUseRule(schema, rule));
  }
  exports.shouldUseGroup = shouldUseGroup;
  function shouldUseRule(schema, rule) {
    var _a;
    return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
  }
  exports.shouldUseRule = shouldUseRule;
});
var require_dataType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
  var rules_1 = require_rules();
  var applicability_1 = require_applicability();
  var errors_1 = require_errors();
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var DataType;
  (function(DataType2) {
    DataType2[DataType2["Correct"] = 0] = "Correct";
    DataType2[DataType2["Wrong"] = 1] = "Wrong";
  })(DataType || (exports.DataType = DataType = {}));
  function getSchemaTypes(schema) {
    const types = getJSONTypes(schema.type);
    const hasNull = types.includes("null");
    if (hasNull) {
      if (schema.nullable === false)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!types.length && schema.nullable !== void 0) {
        throw new Error('"nullable" cannot be used without "type"');
      }
      if (schema.nullable === true)
        types.push("null");
    }
    return types;
  }
  exports.getSchemaTypes = getSchemaTypes;
  function getJSONTypes(ts) {
    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
    if (types.every(rules_1.isJSONType))
      return types;
    throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
  }
  exports.getJSONTypes = getJSONTypes;
  function coerceAndCheckDataType(it, types) {
    const { gen, data, opts } = it;
    const coerceTo = coerceToTypes(types, opts.coerceTypes);
    const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
    if (checkTypes) {
      const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
      gen.if(wrongType, () => {
        if (coerceTo.length)
          coerceData(it, types, coerceTo);
        else
          reportTypeError(it);
      });
    }
    return checkTypes;
  }
  exports.coerceAndCheckDataType = coerceAndCheckDataType;
  var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(types, coerceTypes) {
    return coerceTypes ? types.filter((t2) => COERCIBLE.has(t2) || coerceTypes === "array" && t2 === "array") : [];
  }
  function coerceData(it, types, coerceTo) {
    const { gen, data, opts } = it;
    const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
    const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
    if (opts.coerceTypes === "array") {
      gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
    }
    gen.if((0, codegen_1._)`${coerced} !== undefined`);
    for (const t2 of coerceTo) {
      if (COERCIBLE.has(t2) || t2 === "array" && opts.coerceTypes === "array") {
        coerceSpecificType(t2);
      }
    }
    gen.else();
    reportTypeError(it);
    gen.endIf();
    gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
      gen.assign(data, coerced);
      assignParentData(it, coerced);
    });
    function coerceSpecificType(t2) {
      switch (t2) {
        case "string":
          gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
          return;
        case "number":
          gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
          return;
        case "integer":
          gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
          return;
        case "boolean":
          gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
          return;
        case "null":
          gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
          gen.assign(coerced, null);
          return;
        case "array":
          gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
      }
    }
  }
  function assignParentData({ gen, parentData, parentDataProperty }, expr) {
    gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
  }
  function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
    let cond;
    switch (dataType) {
      case "null":
        return (0, codegen_1._)`${data} ${EQ} null`;
      case "array":
        cond = (0, codegen_1._)`Array.isArray(${data})`;
        break;
      case "object":
        cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
        break;
      case "integer":
        cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
        break;
      case "number":
        cond = numCond();
        break;
      default:
        return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
    }
    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
    function numCond(_cond = codegen_1.nil) {
      return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
    }
  }
  exports.checkDataType = checkDataType;
  function checkDataTypes(dataTypes, data, strictNums, correct) {
    if (dataTypes.length === 1) {
      return checkDataType(dataTypes[0], data, strictNums, correct);
    }
    let cond;
    const types = (0, util_1.toHash)(dataTypes);
    if (types.array && types.object) {
      const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
      cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
      delete types.null;
      delete types.array;
      delete types.object;
    } else {
      cond = codegen_1.nil;
    }
    if (types.number)
      delete types.integer;
    for (const t2 in types)
      cond = (0, codegen_1.and)(cond, checkDataType(t2, data, strictNums, correct));
    return cond;
  }
  exports.checkDataTypes = checkDataTypes;
  var typeError = {
    message: ({ schema }) => `must be ${schema}`,
    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
  };
  function reportTypeError(it) {
    const cxt = getTypeErrorContext(it);
    (0, errors_1.reportError)(cxt, typeError);
  }
  exports.reportTypeError = reportTypeError;
  function getTypeErrorContext(it) {
    const { gen, data, schema } = it;
    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
    return {
      gen,
      keyword: "type",
      data,
      schema: schema.type,
      schemaCode,
      schemaValue: schemaCode,
      parentSchema: schema,
      params: {},
      it
    };
  }
});
var require_defaults = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assignDefaults = void 0;
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  function assignDefaults(it, ty) {
    const { properties, items } = it.schema;
    if (ty === "object" && properties) {
      for (const key in properties) {
        assignDefault(it, key, properties[key].default);
      }
    } else if (ty === "array" && Array.isArray(items)) {
      items.forEach((sch, i) => assignDefault(it, i, sch.default));
    }
  }
  exports.assignDefaults = assignDefaults;
  function assignDefault(it, prop, defaultValue) {
    const { gen, compositeRule, data, opts } = it;
    if (defaultValue === void 0)
      return;
    const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
    if (compositeRule) {
      (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
      return;
    }
    let condition = (0, codegen_1._)`${childData} === undefined`;
    if (opts.useDefaults === "empty") {
      condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
    }
    gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
  }
});
var require_code2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var names_1 = require_names();
  var util_2 = require_util();
  function checkReportMissingProp(cxt, prop) {
    const { gen, data, it } = cxt;
    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
      cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
      cxt.error();
    });
  }
  exports.checkReportMissingProp = checkReportMissingProp;
  function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
  }
  exports.checkMissingProp = checkMissingProp;
  function reportMissingProp(cxt, missing) {
    cxt.setParams({ missingProperty: missing }, true);
    cxt.error();
  }
  exports.reportMissingProp = reportMissingProp;
  function hasPropFunc(gen) {
    return gen.scopeValue("func", {
      ref: Object.prototype.hasOwnProperty,
      code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
    });
  }
  exports.hasPropFunc = hasPropFunc;
  function isOwnProperty(gen, data, property) {
    return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
  }
  exports.isOwnProperty = isOwnProperty;
  function propertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
    return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
  }
  exports.propertyInData = propertyInData;
  function noPropertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
  }
  exports.noPropertyInData = noPropertyInData;
  function allSchemaProperties(schemaMap) {
    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
  }
  exports.allSchemaProperties = allSchemaProperties;
  function schemaProperties(it, schemaMap) {
    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
  }
  exports.schemaProperties = schemaProperties;
  function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
    const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
    const valCxt = [
      [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
      [names_1.default.parentData, it.parentData],
      [names_1.default.parentDataProperty, it.parentDataProperty],
      [names_1.default.rootData, names_1.default.rootData]
    ];
    if (it.opts.dynamicRef)
      valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
    const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
    return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
  }
  exports.callValidateCode = callValidateCode;
  var newRegExp = (0, codegen_1._)`new RegExp`;
  function usePattern({ gen, it: { opts } }, pattern) {
    const u = opts.unicodeRegExp ? "u" : "";
    const { regExp } = opts.code;
    const rx = regExp(pattern, u);
    return gen.scopeValue("pattern", {
      key: rx.toString(),
      ref: rx,
      code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
    });
  }
  exports.usePattern = usePattern;
  function validateArray(cxt) {
    const { gen, data, keyword, it } = cxt;
    const valid = gen.name("valid");
    if (it.allErrors) {
      const validArr = gen.let("valid", true);
      validateItems(() => gen.assign(validArr, false));
      return validArr;
    }
    gen.var(valid, true);
    validateItems(() => gen.break());
    return valid;
    function validateItems(notValid) {
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      gen.forRange("i", 0, len, (i) => {
        cxt.subschema({
          keyword,
          dataProp: i,
          dataPropType: util_1.Type.Num
        }, valid);
        gen.if((0, codegen_1.not)(valid), notValid);
      });
    }
  }
  exports.validateArray = validateArray;
  function validateUnion(cxt) {
    const { gen, schema, keyword, it } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
    if (alwaysValid && !it.opts.unevaluated)
      return;
    const valid = gen.let("valid", false);
    const schValid = gen.name("_valid");
    gen.block(() => schema.forEach((_sch, i) => {
      const schCxt = cxt.subschema({
        keyword,
        schemaProp: i,
        compositeRule: true
      }, schValid);
      gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
      const merged = cxt.mergeValidEvaluated(schCxt, schValid);
      if (!merged)
        gen.if((0, codegen_1.not)(valid));
    }));
    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
  }
  exports.validateUnion = validateUnion;
});
var require_keyword = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var code_1 = require_code2();
  var errors_1 = require_errors();
  function macroKeywordCode(cxt, def) {
    const { gen, keyword, schema, parentSchema, it } = cxt;
    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
    const schemaRef = useKeyword(gen, keyword, macroSchema);
    if (it.opts.validateSchema !== false)
      it.self.validateSchema(macroSchema, true);
    const valid = gen.name("valid");
    cxt.subschema({
      schema: macroSchema,
      schemaPath: codegen_1.nil,
      errSchemaPath: `${it.errSchemaPath}/${keyword}`,
      topSchemaRef: schemaRef,
      compositeRule: true
    }, valid);
    cxt.pass(valid, () => cxt.error(true));
  }
  exports.macroKeywordCode = macroKeywordCode;
  function funcKeywordCode(cxt, def) {
    var _a;
    const { gen, keyword, schema, parentSchema, $data, it } = cxt;
    checkAsyncKeyword(it, def);
    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
    const validateRef = useKeyword(gen, keyword, validate);
    const valid = gen.let("valid");
    cxt.block$data(valid, validateKeyword);
    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
    function validateKeyword() {
      if (def.errors === false) {
        assignValid();
        if (def.modifying)
          modifyData(cxt);
        reportErrs(() => cxt.error());
      } else {
        const ruleErrs = def.async ? validateAsync() : validateSync();
        if (def.modifying)
          modifyData(cxt);
        reportErrs(() => addErrs(cxt, ruleErrs));
      }
    }
    function validateAsync() {
      const ruleErrs = gen.let("ruleErrs", null);
      gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
      return ruleErrs;
    }
    function validateSync() {
      const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
      gen.assign(validateErrs, null);
      assignValid(codegen_1.nil);
      return validateErrs;
    }
    function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
      const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
      const passSchema = !("compile" in def && !$data || def.schema === false);
      gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
    }
    function reportErrs(errors3) {
      var _a2;
      gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors3);
    }
  }
  exports.funcKeywordCode = funcKeywordCode;
  function modifyData(cxt) {
    const { gen, data, it } = cxt;
    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
  }
  function addErrs(cxt, errs) {
    const { gen } = cxt;
    gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
      gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      (0, errors_1.extendErrors)(cxt);
    }, () => cxt.error());
  }
  function checkAsyncKeyword({ schemaEnv }, def) {
    if (def.async && !schemaEnv.$async)
      throw new Error("async keyword in sync schema");
  }
  function useKeyword(gen, keyword, result) {
    if (result === void 0)
      throw new Error(`keyword "${keyword}" failed to compile`);
    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
  }
  function validSchemaType(schema, schemaType, allowUndefined = false) {
    return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
  }
  exports.validSchemaType = validSchemaType;
  function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {
    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
      throw new Error("ajv implementation error");
    }
    const deps = def.dependencies;
    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
      throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
    }
    if (def.validateSchema) {
      const valid = def.validateSchema(schema[keyword]);
      if (!valid) {
        const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
        if (opts.validateSchema === "log")
          self2.logger.error(msg);
        else
          throw new Error(msg);
      }
    }
  }
  exports.validateKeywordUsage = validateKeywordUsage;
});
var require_subschema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
    if (keyword !== void 0 && schema !== void 0) {
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    }
    if (keyword !== void 0) {
      const sch = it.schema[keyword];
      return schemaProp === void 0 ? {
        schema: sch,
        schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`
      } : {
        schema: sch[schemaProp],
        schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
        errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
      };
    }
    if (schema !== void 0) {
      if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      }
      return {
        schema,
        schemaPath,
        topSchemaRef,
        errSchemaPath
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  exports.getSubschema = getSubschema;
  function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
    if (data !== void 0 && dataProp !== void 0) {
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    }
    const { gen } = it;
    if (dataProp !== void 0) {
      const { errorPath, dataPathArr, opts } = it;
      const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
      dataContextProps(nextData);
      subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
      subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
      subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
    }
    if (data !== void 0) {
      const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
      dataContextProps(nextData);
      if (propertyName !== void 0)
        subschema.propertyName = propertyName;
    }
    if (dataTypes)
      subschema.dataTypes = dataTypes;
    function dataContextProps(_nextData) {
      subschema.data = _nextData;
      subschema.dataLevel = it.dataLevel + 1;
      subschema.dataTypes = [];
      it.definedProperties = /* @__PURE__ */ new Set();
      subschema.parentData = it.data;
      subschema.dataNames = [...it.dataNames, _nextData];
    }
  }
  exports.extendSubschemaData = extendSubschemaData;
  function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
    if (compositeRule !== void 0)
      subschema.compositeRule = compositeRule;
    if (createErrors !== void 0)
      subschema.createErrors = createErrors;
    if (allErrors !== void 0)
      subschema.allErrors = allErrors;
    subschema.jtdDiscriminator = jtdDiscriminator;
    subschema.jtdMetadata = jtdMetadata;
  }
  exports.extendSubschemaMode = extendSubschemaMode;
});
var require_fast_deep_equal = __commonJS((exports, module2) => {
  module2.exports = function equal(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor)
        return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length; i-- !== 0; )
          if (!equal(a[i], b[i]))
            return false;
        return true;
      }
      if (a.constructor === RegExp)
        return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf)
        return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString)
        return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length)
        return false;
      for (i = length; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
          return false;
      for (i = length; i-- !== 0; ) {
        var key = keys[i];
        if (!equal(a[key], b[key]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
});
var require_json_schema_traverse = __commonJS((exports, module2) => {
  var traverse = module2.exports = function(schema, opts, cb) {
    if (typeof opts == "function") {
      cb = opts;
      opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == "function" ? cb : cb.pre || function() {
    };
    var post = cb.post || function() {
    };
    _traverse(opts, pre, post, schema, "", schema);
  };
  traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true,
    if: true,
    then: true,
    else: true
  };
  traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
  };
  traverse.propsKeywords = {
    $defs: true,
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
  };
  traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
  };
  function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == "object" && !Array.isArray(schema)) {
      pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      for (var key in schema) {
        var sch = schema[key];
        if (Array.isArray(sch)) {
          if (key in traverse.arrayKeywords) {
            for (var i = 0; i < sch.length; i++)
              _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
          }
        } else if (key in traverse.propsKeywords) {
          if (sch && typeof sch == "object") {
            for (var prop in sch)
              _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
          }
        } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
          _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
      }
      post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
  }
  function escapeJsonPtr(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
});
var require_resolve = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
  var util_1 = require_util();
  var equal = require_fast_deep_equal();
  var traverse = require_json_schema_traverse();
  var SIMPLE_INLINED = /* @__PURE__ */ new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function inlineRef(schema, limit = true) {
    if (typeof schema == "boolean")
      return true;
    if (limit === true)
      return !hasRef(schema);
    if (!limit)
      return false;
    return countKeys(schema) <= limit;
  }
  exports.inlineRef = inlineRef;
  var REF_KEYWORDS = /* @__PURE__ */ new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function hasRef(schema) {
    for (const key in schema) {
      if (REF_KEYWORDS.has(key))
        return true;
      const sch = schema[key];
      if (Array.isArray(sch) && sch.some(hasRef))
        return true;
      if (typeof sch == "object" && hasRef(sch))
        return true;
    }
    return false;
  }
  function countKeys(schema) {
    let count = 0;
    for (const key in schema) {
      if (key === "$ref")
        return Infinity;
      count++;
      if (SIMPLE_INLINED.has(key))
        continue;
      if (typeof schema[key] == "object") {
        (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
      }
      if (count === Infinity)
        return Infinity;
    }
    return count;
  }
  function getFullPath(resolver, id = "", normalize2) {
    if (normalize2 !== false)
      id = normalizeId(id);
    const p = resolver.parse(id);
    return _getFullPath(resolver, p);
  }
  exports.getFullPath = getFullPath;
  function _getFullPath(resolver, p) {
    const serialized = resolver.serialize(p);
    return serialized.split("#")[0] + "#";
  }
  exports._getFullPath = _getFullPath;
  var TRAILING_SLASH_HASH = /#\/?$/;
  function normalizeId(id) {
    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
  }
  exports.normalizeId = normalizeId;
  function resolveUrl(resolver, baseId, id) {
    id = normalizeId(id);
    return resolver.resolve(baseId, id);
  }
  exports.resolveUrl = resolveUrl;
  var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
  function getSchemaRefs(schema, baseId) {
    if (typeof schema == "boolean")
      return {};
    const { schemaId, uriResolver } = this.opts;
    const schId = normalizeId(schema[schemaId] || baseId);
    const baseIds = { "": schId };
    const pathPrefix = getFullPath(uriResolver, schId, false);
    const localRefs = {};
    const schemaRefs = /* @__PURE__ */ new Set();
    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
      if (parentJsonPtr === void 0)
        return;
      const fullPath = pathPrefix + jsonPtr;
      let innerBaseId = baseIds[parentJsonPtr];
      if (typeof sch[schemaId] == "string")
        innerBaseId = addRef.call(this, sch[schemaId]);
      addAnchor.call(this, sch.$anchor);
      addAnchor.call(this, sch.$dynamicAnchor);
      baseIds[jsonPtr] = innerBaseId;
      function addRef(ref) {
        const _resolve = this.opts.uriResolver.resolve;
        ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
        if (schemaRefs.has(ref))
          throw ambiguos(ref);
        schemaRefs.add(ref);
        let schOrRef = this.refs[ref];
        if (typeof schOrRef == "string")
          schOrRef = this.refs[schOrRef];
        if (typeof schOrRef == "object") {
          checkAmbiguosRef(sch, schOrRef.schema, ref);
        } else if (ref !== normalizeId(fullPath)) {
          if (ref[0] === "#") {
            checkAmbiguosRef(sch, localRefs[ref], ref);
            localRefs[ref] = sch;
          } else {
            this.refs[ref] = fullPath;
          }
        }
        return ref;
      }
      function addAnchor(anchor) {
        if (typeof anchor == "string") {
          if (!ANCHOR.test(anchor))
            throw new Error(`invalid anchor "${anchor}"`);
          addRef.call(this, `#${anchor}`);
        }
      }
    });
    return localRefs;
    function checkAmbiguosRef(sch1, sch2, ref) {
      if (sch2 !== void 0 && !equal(sch1, sch2))
        throw ambiguos(ref);
    }
    function ambiguos(ref) {
      return new Error(`reference "${ref}" resolves to more than one schema`);
    }
  }
  exports.getSchemaRefs = getSchemaRefs;
});
var require_validate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
  var boolSchema_1 = require_boolSchema();
  var dataType_1 = require_dataType();
  var applicability_1 = require_applicability();
  var dataType_2 = require_dataType();
  var defaults_1 = require_defaults();
  var keyword_1 = require_keyword();
  var subschema_1 = require_subschema();
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var resolve_1 = require_resolve();
  var util_1 = require_util();
  var errors_1 = require_errors();
  function validateFunctionCode(it) {
    if (isSchemaObj(it)) {
      checkKeywords(it);
      if (schemaCxtHasRules(it)) {
        topSchemaObjCode(it);
        return;
      }
    }
    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
  }
  exports.validateFunctionCode = validateFunctionCode;
  function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
    if (opts.code.es5) {
      gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
        gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
        destructureValCxtES5(gen, opts);
        gen.code(body);
      });
    } else {
      gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
    }
  }
  function destructureValCxt(opts) {
    return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
  }
  function destructureValCxtES5(gen, opts) {
    gen.if(names_1.default.valCxt, () => {
      gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
      gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
      gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
      gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
      if (opts.dynamicRef)
        gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
    }, () => {
      gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
      gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
      gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
      gen.var(names_1.default.rootData, names_1.default.data);
      if (opts.dynamicRef)
        gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
    });
  }
  function topSchemaObjCode(it) {
    const { schema, opts, gen } = it;
    validateFunction(it, () => {
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      checkNoDefault(it);
      gen.let(names_1.default.vErrors, null);
      gen.let(names_1.default.errors, 0);
      if (opts.unevaluated)
        resetEvaluated(it);
      typeAndKeywords(it);
      returnResults(it);
    });
    return;
  }
  function resetEvaluated(it) {
    const { gen, validateName } = it;
    it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
    gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
    gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
  }
  function funcSourceUrl(schema, opts) {
    const schId = typeof schema == "object" && schema[opts.schemaId];
    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
  }
  function subschemaCode(it, valid) {
    if (isSchemaObj(it)) {
      checkKeywords(it);
      if (schemaCxtHasRules(it)) {
        subSchemaObjCode(it, valid);
        return;
      }
    }
    (0, boolSchema_1.boolOrEmptySchema)(it, valid);
  }
  function schemaCxtHasRules({ schema, self: self2 }) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (self2.RULES.all[key])
        return true;
    return false;
  }
  function isSchemaObj(it) {
    return typeof it.schema != "boolean";
  }
  function subSchemaObjCode(it, valid) {
    const { schema, gen, opts } = it;
    if (opts.$comment && schema.$comment)
      commentKeyword(it);
    updateContext(it);
    checkAsyncSchema(it);
    const errsCount = gen.const("_errs", names_1.default.errors);
    typeAndKeywords(it, errsCount);
    gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
  }
  function checkKeywords(it) {
    (0, util_1.checkUnknownRules)(it);
    checkRefsAndKeywords(it);
  }
  function typeAndKeywords(it, errsCount) {
    if (it.opts.jtd)
      return schemaKeywords(it, [], false, errsCount);
    const types = (0, dataType_1.getSchemaTypes)(it.schema);
    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
    schemaKeywords(it, types, !checkedTypes, errsCount);
  }
  function checkRefsAndKeywords(it) {
    const { schema, errSchemaPath, opts, self: self2 } = it;
    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
      self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
    }
  }
  function checkNoDefault(it) {
    const { schema, opts } = it;
    if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
      (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
    }
  }
  function updateContext(it) {
    const schId = it.schema[it.opts.schemaId];
    if (schId)
      it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
  }
  function checkAsyncSchema(it) {
    if (it.schema.$async && !it.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
    const msg = schema.$comment;
    if (opts.$comment === true) {
      gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
    } else if (typeof opts.$comment == "function") {
      const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
      const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
      gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
    }
  }
  function returnResults(it) {
    const { gen, schemaEnv, validateName, ValidationError, opts } = it;
    if (schemaEnv.$async) {
      gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
      if (opts.unevaluated)
        assignEvaluated(it);
      gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
    }
  }
  function assignEvaluated({ gen, evaluated, props, items }) {
    if (props instanceof codegen_1.Name)
      gen.assign((0, codegen_1._)`${evaluated}.props`, props);
    if (items instanceof codegen_1.Name)
      gen.assign((0, codegen_1._)`${evaluated}.items`, items);
  }
  function schemaKeywords(it, types, typeErrors, errsCount) {
    const { gen, schema, data, allErrors, opts, self: self2 } = it;
    const { RULES } = self2;
    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
      gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
      return;
    }
    if (!opts.jtd)
      checkStrictTypes(it, types);
    gen.block(() => {
      for (const group of RULES.rules)
        groupKeywords(group);
      groupKeywords(RULES.post);
    });
    function groupKeywords(group) {
      if (!(0, applicability_1.shouldUseGroup)(schema, group))
        return;
      if (group.type) {
        gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
        iterateKeywords(it, group);
        if (types.length === 1 && types[0] === group.type && typeErrors) {
          gen.else();
          (0, dataType_2.reportTypeError)(it);
        }
        gen.endIf();
      } else {
        iterateKeywords(it, group);
      }
      if (!allErrors)
        gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
    }
  }
  function iterateKeywords(it, group) {
    const { gen, schema, opts: { useDefaults } } = it;
    if (useDefaults)
      (0, defaults_1.assignDefaults)(it, group.type);
    gen.block(() => {
      for (const rule of group.rules) {
        if ((0, applicability_1.shouldUseRule)(schema, rule)) {
          keywordCode(it, rule.keyword, rule.definition, group.type);
        }
      }
    });
  }
  function checkStrictTypes(it, types) {
    if (it.schemaEnv.meta || !it.opts.strictTypes)
      return;
    checkContextTypes(it, types);
    if (!it.opts.allowUnionTypes)
      checkMultipleTypes(it, types);
    checkKeywordTypes(it, it.dataTypes);
  }
  function checkContextTypes(it, types) {
    if (!types.length)
      return;
    if (!it.dataTypes.length) {
      it.dataTypes = types;
      return;
    }
    types.forEach((t2) => {
      if (!includesType(it.dataTypes, t2)) {
        strictTypesError(it, `type "${t2}" not allowed by context "${it.dataTypes.join(",")}"`);
      }
    });
    narrowSchemaTypes(it, types);
  }
  function checkMultipleTypes(it, ts) {
    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
      strictTypesError(it, "use allowUnionTypes to allow union type keyword");
    }
  }
  function checkKeywordTypes(it, ts) {
    const rules = it.self.RULES.all;
    for (const keyword in rules) {
      const rule = rules[keyword];
      if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
        const { type } = rule.definition;
        if (type.length && !type.some((t2) => hasApplicableType(ts, t2))) {
          strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
        }
      }
    }
  }
  function hasApplicableType(schTs, kwdT) {
    return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
  }
  function includesType(ts, t2) {
    return ts.includes(t2) || t2 === "integer" && ts.includes("number");
  }
  function narrowSchemaTypes(it, withTypes) {
    const ts = [];
    for (const t2 of it.dataTypes) {
      if (includesType(withTypes, t2))
        ts.push(t2);
      else if (withTypes.includes("integer") && t2 === "number")
        ts.push("integer");
    }
    it.dataTypes = ts;
  }
  function strictTypesError(it, msg) {
    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
    msg += ` at "${schemaPath}" (strictTypes)`;
    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
  }
  class KeywordCxt {
    constructor(it, def, keyword) {
      (0, keyword_1.validateKeywordUsage)(it, def, keyword);
      this.gen = it.gen;
      this.allErrors = it.allErrors;
      this.keyword = keyword;
      this.data = it.data;
      this.schema = it.schema[keyword];
      this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
      this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
      this.schemaType = def.schemaType;
      this.parentSchema = it.schema;
      this.params = {};
      this.it = it;
      this.def = def;
      if (this.$data) {
        this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
      } else {
        this.schemaCode = this.schemaValue;
        if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
          throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
        }
      }
      if ("code" in def ? def.trackErrors : def.errors !== false) {
        this.errsCount = it.gen.const("_errs", names_1.default.errors);
      }
    }
    result(condition, successAction, failAction) {
      this.failResult((0, codegen_1.not)(condition), successAction, failAction);
    }
    failResult(condition, successAction, failAction) {
      this.gen.if(condition);
      if (failAction)
        failAction();
      else
        this.error();
      if (successAction) {
        this.gen.else();
        successAction();
        if (this.allErrors)
          this.gen.endIf();
      } else {
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
    }
    pass(condition, failAction) {
      this.failResult((0, codegen_1.not)(condition), void 0, failAction);
    }
    fail(condition) {
      if (condition === void 0) {
        this.error();
        if (!this.allErrors)
          this.gen.if(false);
        return;
      }
      this.gen.if(condition);
      this.error();
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
    fail$data(condition) {
      if (!this.$data)
        return this.fail(condition);
      const { schemaCode } = this;
      this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
    }
    error(append, errorParams, errorPaths) {
      if (errorParams) {
        this.setParams(errorParams);
        this._error(append, errorPaths);
        this.setParams({});
        return;
      }
      this._error(append, errorPaths);
    }
    _error(append, errorPaths) {
      (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
    }
    $dataError() {
      (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0)
        throw new Error('add "trackErrors" to keyword definition');
      (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(cond) {
      if (!this.allErrors)
        this.gen.if(cond);
    }
    setParams(obj, assign) {
      if (assign)
        Object.assign(this.params, obj);
      else
        this.params = obj;
    }
    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
      this.gen.block(() => {
        this.check$data(valid, $dataValid);
        codeBlock();
      });
    }
    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
      if (!this.$data)
        return;
      const { gen, schemaCode, schemaType, def } = this;
      gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
      if (valid !== codegen_1.nil)
        gen.assign(valid, true);
      if (schemaType.length || def.validateSchema) {
        gen.elseIf(this.invalid$data());
        this.$dataError();
        if (valid !== codegen_1.nil)
          gen.assign(valid, false);
      }
      gen.else();
    }
    invalid$data() {
      const { gen, schemaCode, schemaType, def, it } = this;
      return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
      function wrong$DataType() {
        if (schemaType.length) {
          if (!(schemaCode instanceof codegen_1.Name))
            throw new Error("ajv implementation error");
          const st = Array.isArray(schemaType) ? schemaType : [schemaType];
          return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
        }
        return codegen_1.nil;
      }
      function invalid$DataSchema() {
        if (def.validateSchema) {
          const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
          return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
        }
        return codegen_1.nil;
      }
    }
    subschema(appl, valid) {
      const subschema = (0, subschema_1.getSubschema)(this.it, appl);
      (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
      (0, subschema_1.extendSubschemaMode)(subschema, appl);
      const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
      subschemaCode(nextContext, valid);
      return nextContext;
    }
    mergeEvaluated(schemaCxt, toName) {
      const { it, gen } = this;
      if (!it.opts.unevaluated)
        return;
      if (it.props !== true && schemaCxt.props !== void 0) {
        it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
      }
      if (it.items !== true && schemaCxt.items !== void 0) {
        it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
      }
    }
    mergeValidEvaluated(schemaCxt, valid) {
      const { it, gen } = this;
      if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
        gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
        return true;
      }
    }
  }
  exports.KeywordCxt = KeywordCxt;
  function keywordCode(it, keyword, def, ruleType) {
    const cxt = new KeywordCxt(it, def, keyword);
    if ("code" in def) {
      def.code(cxt, ruleType);
    } else if (cxt.$data && def.validate) {
      (0, keyword_1.funcKeywordCode)(cxt, def);
    } else if ("macro" in def) {
      (0, keyword_1.macroKeywordCode)(cxt, def);
    } else if (def.compile || def.validate) {
      (0, keyword_1.funcKeywordCode)(cxt, def);
    }
  }
  var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
  var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function getData($data, { dataLevel, dataNames, dataPathArr }) {
    let jsonPointer;
    let data;
    if ($data === "")
      return names_1.default.rootData;
    if ($data[0] === "/") {
      if (!JSON_POINTER.test($data))
        throw new Error(`Invalid JSON-pointer: ${$data}`);
      jsonPointer = $data;
      data = names_1.default.rootData;
    } else {
      const matches = RELATIVE_JSON_POINTER.exec($data);
      if (!matches)
        throw new Error(`Invalid JSON-pointer: ${$data}`);
      const up = +matches[1];
      jsonPointer = matches[2];
      if (jsonPointer === "#") {
        if (up >= dataLevel)
          throw new Error(errorMsg("property/index", up));
        return dataPathArr[dataLevel - up];
      }
      if (up > dataLevel)
        throw new Error(errorMsg("data", up));
      data = dataNames[dataLevel - up];
      if (!jsonPointer)
        return data;
    }
    let expr = data;
    const segments = jsonPointer.split("/");
    for (const segment of segments) {
      if (segment) {
        data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
        expr = (0, codegen_1._)`${expr} && ${data}`;
      }
    }
    return expr;
    function errorMsg(pointerType, up) {
      return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
    }
  }
  exports.getData = getData;
});
var require_validation_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  class ValidationError extends Error {
    constructor(errors3) {
      super("validation failed");
      this.errors = errors3;
      this.ajv = this.validation = true;
    }
  }
  exports.default = ValidationError;
});
var require_ref_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var resolve_1 = require_resolve();
  class MissingRefError extends Error {
    constructor(resolver, baseId, ref, msg) {
      super(msg || `can't resolve reference ${ref} from id ${baseId}`);
      this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
      this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
    }
  }
  exports.default = MissingRefError;
});
var require_compile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
  var codegen_1 = require_codegen();
  var validation_error_1 = require_validation_error();
  var names_1 = require_names();
  var resolve_1 = require_resolve();
  var util_1 = require_util();
  var validate_1 = require_validate();
  class SchemaEnv {
    constructor(env) {
      var _a;
      this.refs = {};
      this.dynamicAnchors = {};
      let schema;
      if (typeof env.schema == "object")
        schema = env.schema;
      this.schema = env.schema;
      this.schemaId = env.schemaId;
      this.root = env.root || this;
      this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
      this.schemaPath = env.schemaPath;
      this.localRefs = env.localRefs;
      this.meta = env.meta;
      this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
      this.refs = {};
    }
  }
  exports.SchemaEnv = SchemaEnv;
  function compileSchema(sch) {
    const _sch = getCompilingSchema.call(this, sch);
    if (_sch)
      return _sch;
    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
    let _ValidationError;
    if (sch.$async) {
      _ValidationError = gen.scopeValue("Error", {
        ref: validation_error_1.default,
        code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
      });
    }
    const validateName = gen.scopeName("validate");
    sch.validateName = validateName;
    const schemaCxt = {
      gen,
      allErrors: this.opts.allErrors,
      data: names_1.default.data,
      parentData: names_1.default.parentData,
      parentDataProperty: names_1.default.parentDataProperty,
      dataNames: [names_1.default.data],
      dataPathArr: [codegen_1.nil],
      dataLevel: 0,
      dataTypes: [],
      definedProperties: /* @__PURE__ */ new Set(),
      topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
      validateName,
      ValidationError: _ValidationError,
      schema: sch.schema,
      schemaEnv: sch,
      rootId,
      baseId: sch.baseId || rootId,
      schemaPath: codegen_1.nil,
      errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, codegen_1._)`""`,
      opts: this.opts,
      self: this
    };
    let sourceCode;
    try {
      this._compilations.add(sch);
      (0, validate_1.validateFunctionCode)(schemaCxt);
      gen.optimize(this.opts.code.optimize);
      const validateCode = gen.toString();
      sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
      if (this.opts.code.process)
        sourceCode = this.opts.code.process(sourceCode, sch);
      const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
      const validate = makeValidate(this, this.scope.get());
      this.scope.value(validateName, { ref: validate });
      validate.errors = null;
      validate.schema = sch.schema;
      validate.schemaEnv = sch;
      if (sch.$async)
        validate.$async = true;
      if (this.opts.code.source === true) {
        validate.source = { validateName, validateCode, scopeValues: gen._values };
      }
      if (this.opts.unevaluated) {
        const { props, items } = schemaCxt;
        validate.evaluated = {
          props: props instanceof codegen_1.Name ? void 0 : props,
          items: items instanceof codegen_1.Name ? void 0 : items,
          dynamicProps: props instanceof codegen_1.Name,
          dynamicItems: items instanceof codegen_1.Name
        };
        if (validate.source)
          validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
      }
      sch.validate = validate;
      return sch;
    } catch (e) {
      delete sch.validate;
      delete sch.validateName;
      if (sourceCode)
        this.logger.error("Error compiling schema, function code:", sourceCode);
      throw e;
    } finally {
      this._compilations.delete(sch);
    }
  }
  exports.compileSchema = compileSchema;
  function resolveRef(root2, baseId, ref) {
    var _a;
    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
    const schOrFunc = root2.refs[ref];
    if (schOrFunc)
      return schOrFunc;
    let _sch = resolve3.call(this, root2, ref);
    if (_sch === void 0) {
      const schema = (_a = root2.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
      const { schemaId } = this.opts;
      if (schema)
        _sch = new SchemaEnv({ schema, schemaId, root: root2, baseId });
    }
    if (_sch === void 0)
      return;
    return root2.refs[ref] = inlineOrCompile.call(this, _sch);
  }
  exports.resolveRef = resolveRef;
  function inlineOrCompile(sch) {
    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
      return sch.schema;
    return sch.validate ? sch : compileSchema.call(this, sch);
  }
  function getCompilingSchema(schEnv) {
    for (const sch of this._compilations) {
      if (sameSchemaEnv(sch, schEnv))
        return sch;
    }
  }
  exports.getCompilingSchema = getCompilingSchema;
  function sameSchemaEnv(s1, s2) {
    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
  }
  function resolve3(root2, ref) {
    let sch;
    while (typeof (sch = this.refs[ref]) == "string")
      ref = sch;
    return sch || this.schemas[ref] || resolveSchema.call(this, root2, ref);
  }
  function resolveSchema(root2, ref) {
    const p = this.opts.uriResolver.parse(ref);
    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root2.baseId, void 0);
    if (Object.keys(root2.schema).length > 0 && refPath === baseId) {
      return getJsonPointer.call(this, p, root2);
    }
    const id = (0, resolve_1.normalizeId)(refPath);
    const schOrRef = this.refs[id] || this.schemas[id];
    if (typeof schOrRef == "string") {
      const sch = resolveSchema.call(this, root2, schOrRef);
      if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
        return;
      return getJsonPointer.call(this, p, sch);
    }
    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
      return;
    if (!schOrRef.validate)
      compileSchema.call(this, schOrRef);
    if (id === (0, resolve_1.normalizeId)(ref)) {
      const { schema } = schOrRef;
      const { schemaId } = this.opts;
      const schId = schema[schemaId];
      if (schId)
        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
      return new SchemaEnv({ schema, schemaId, root: root2, baseId });
    }
    return getJsonPointer.call(this, p, schOrRef);
  }
  exports.resolveSchema = resolveSchema;
  var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function getJsonPointer(parsedRef, { baseId, schema, root: root2 }) {
    var _a;
    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
      return;
    for (const part of parsedRef.fragment.slice(1).split("/")) {
      if (typeof schema === "boolean")
        return;
      const partSchema = schema[(0, util_1.unescapeFragment)(part)];
      if (partSchema === void 0)
        return;
      schema = partSchema;
      const schId = typeof schema === "object" && schema[this.opts.schemaId];
      if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
      }
    }
    let env;
    if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
      const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
      env = resolveSchema.call(this, root2, $ref);
    }
    const { schemaId } = this.opts;
    env = env || new SchemaEnv({ schema, schemaId, root: root2, baseId });
    if (env.schema !== env.root.schema)
      return env;
    return;
  }
});
var require_data = __commonJS((exports, module2) => {
  module2.exports = {
    $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
    description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
    type: "object",
    required: ["$data"],
    properties: {
      $data: {
        type: "string",
        anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
      }
    },
    additionalProperties: false
  };
});
var require_scopedChars = __commonJS((exports, module2) => {
  var HEX = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  module2.exports = {
    HEX
  };
});
var require_utils = __commonJS((exports, module2) => {
  var { HEX } = require_scopedChars();
  var IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
  function normalizeIPv4(host) {
    if (findToken(host, ".") < 3) {
      return { host, isIPV4: false };
    }
    const matches = host.match(IPV4_REG) || [];
    const [address] = matches;
    if (address) {
      return { host: stripLeadingZeros(address, "."), isIPV4: true };
    } else {
      return { host, isIPV4: false };
    }
  }
  function stringArrayToHexStripped(input, keepZero = false) {
    let acc = "";
    let strip = true;
    for (const c of input) {
      if (HEX[c] === void 0)
        return;
      if (c !== "0" && strip === true)
        strip = false;
      if (!strip)
        acc += c;
    }
    if (keepZero && acc.length === 0)
      acc = "0";
    return acc;
  }
  function getIPV6(input) {
    let tokenCount = 0;
    const output = { error: false, address: "", zone: "" };
    const address = [];
    const buffer = [];
    let isZone = false;
    let endipv6Encountered = false;
    let endIpv6 = false;
    function consume() {
      if (buffer.length) {
        if (isZone === false) {
          const hex = stringArrayToHexStripped(buffer);
          if (hex !== void 0) {
            address.push(hex);
          } else {
            output.error = true;
            return false;
          }
        }
        buffer.length = 0;
      }
      return true;
    }
    for (let i = 0; i < input.length; i++) {
      const cursor = input[i];
      if (cursor === "[" || cursor === "]") {
        continue;
      }
      if (cursor === ":") {
        if (endipv6Encountered === true) {
          endIpv6 = true;
        }
        if (!consume()) {
          break;
        }
        tokenCount++;
        address.push(":");
        if (tokenCount > 7) {
          output.error = true;
          break;
        }
        if (i - 1 >= 0 && input[i - 1] === ":") {
          endipv6Encountered = true;
        }
        continue;
      } else if (cursor === "%") {
        if (!consume()) {
          break;
        }
        isZone = true;
      } else {
        buffer.push(cursor);
        continue;
      }
    }
    if (buffer.length) {
      if (isZone) {
        output.zone = buffer.join("");
      } else if (endIpv6) {
        address.push(buffer.join(""));
      } else {
        address.push(stringArrayToHexStripped(buffer));
      }
    }
    output.address = address.join("");
    return output;
  }
  function normalizeIPv6(host) {
    if (findToken(host, ":") < 2) {
      return { host, isIPV6: false };
    }
    const ipv62 = getIPV6(host);
    if (!ipv62.error) {
      let newHost = ipv62.address;
      let escapedHost = ipv62.address;
      if (ipv62.zone) {
        newHost += "%" + ipv62.zone;
        escapedHost += "%25" + ipv62.zone;
      }
      return { host: newHost, escapedHost, isIPV6: true };
    } else {
      return { host, isIPV6: false };
    }
  }
  function stripLeadingZeros(str, token) {
    let out = "";
    let skip = true;
    const l = str.length;
    for (let i = 0; i < l; i++) {
      const c = str[i];
      if (c === "0" && skip) {
        if (i + 1 <= l && str[i + 1] === token || i + 1 === l) {
          out += c;
          skip = false;
        }
      } else {
        if (c === token) {
          skip = true;
        } else {
          skip = false;
        }
        out += c;
      }
    }
    return out;
  }
  function findToken(str, token) {
    let ind = 0;
    for (let i = 0; i < str.length; i++) {
      if (str[i] === token)
        ind++;
    }
    return ind;
  }
  var RDS1 = /^\.\.?\//u;
  var RDS2 = /^\/\.(?:\/|$)/u;
  var RDS3 = /^\/\.\.(?:\/|$)/u;
  var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
  function removeDotSegments(input) {
    const output = [];
    while (input.length) {
      if (input.match(RDS1)) {
        input = input.replace(RDS1, "");
      } else if (input.match(RDS2)) {
        input = input.replace(RDS2, "/");
      } else if (input.match(RDS3)) {
        input = input.replace(RDS3, "/");
        output.pop();
      } else if (input === "." || input === "..") {
        input = "";
      } else {
        const im = input.match(RDS5);
        if (im) {
          const s = im[0];
          input = input.slice(s.length);
          output.push(s);
        } else {
          throw new Error("Unexpected dot segment condition");
        }
      }
    }
    return output.join("");
  }
  function normalizeComponentEncoding(components, esc2) {
    const func = esc2 !== true ? escape : unescape;
    if (components.scheme !== void 0) {
      components.scheme = func(components.scheme);
    }
    if (components.userinfo !== void 0) {
      components.userinfo = func(components.userinfo);
    }
    if (components.host !== void 0) {
      components.host = func(components.host);
    }
    if (components.path !== void 0) {
      components.path = func(components.path);
    }
    if (components.query !== void 0) {
      components.query = func(components.query);
    }
    if (components.fragment !== void 0) {
      components.fragment = func(components.fragment);
    }
    return components;
  }
  function recomposeAuthority(components) {
    const uriTokens = [];
    if (components.userinfo !== void 0) {
      uriTokens.push(components.userinfo);
      uriTokens.push("@");
    }
    if (components.host !== void 0) {
      let host = unescape(components.host);
      const ipV4res = normalizeIPv4(host);
      if (ipV4res.isIPV4) {
        host = ipV4res.host;
      } else {
        const ipV6res = normalizeIPv6(ipV4res.host);
        if (ipV6res.isIPV6 === true) {
          host = `[${ipV6res.escapedHost}]`;
        } else {
          host = components.host;
        }
      }
      uriTokens.push(host);
    }
    if (typeof components.port === "number" || typeof components.port === "string") {
      uriTokens.push(":");
      uriTokens.push(String(components.port));
    }
    return uriTokens.length ? uriTokens.join("") : void 0;
  }
  module2.exports = {
    recomposeAuthority,
    normalizeComponentEncoding,
    removeDotSegments,
    normalizeIPv4,
    normalizeIPv6,
    stringArrayToHexStripped
  };
});
var require_schemes = __commonJS((exports, module2) => {
  var UUID_REG = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu;
  var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
  function isSecure(wsComponents) {
    return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
  }
  function httpParse(components) {
    if (!components.host) {
      components.error = components.error || "HTTP URIs must have a host.";
    }
    return components;
  }
  function httpSerialize(components) {
    const secure = String(components.scheme).toLowerCase() === "https";
    if (components.port === (secure ? 443 : 80) || components.port === "") {
      components.port = void 0;
    }
    if (!components.path) {
      components.path = "/";
    }
    return components;
  }
  function wsParse(wsComponents) {
    wsComponents.secure = isSecure(wsComponents);
    wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
    wsComponents.path = void 0;
    wsComponents.query = void 0;
    return wsComponents;
  }
  function wsSerialize(wsComponents) {
    if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
      wsComponents.port = void 0;
    }
    if (typeof wsComponents.secure === "boolean") {
      wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
      wsComponents.secure = void 0;
    }
    if (wsComponents.resourceName) {
      const [path9, query2] = wsComponents.resourceName.split("?");
      wsComponents.path = path9 && path9 !== "/" ? path9 : void 0;
      wsComponents.query = query2;
      wsComponents.resourceName = void 0;
    }
    wsComponents.fragment = void 0;
    return wsComponents;
  }
  function urnParse(urnComponents, options) {
    if (!urnComponents.path) {
      urnComponents.error = "URN can not be parsed";
      return urnComponents;
    }
    const matches = urnComponents.path.match(URN_REG);
    if (matches) {
      const scheme = options.scheme || urnComponents.scheme || "urn";
      urnComponents.nid = matches[1].toLowerCase();
      urnComponents.nss = matches[2];
      const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
      const schemeHandler = SCHEMES[urnScheme];
      urnComponents.path = void 0;
      if (schemeHandler) {
        urnComponents = schemeHandler.parse(urnComponents, options);
      }
    } else {
      urnComponents.error = urnComponents.error || "URN can not be parsed.";
    }
    return urnComponents;
  }
  function urnSerialize(urnComponents, options) {
    const scheme = options.scheme || urnComponents.scheme || "urn";
    const nid = urnComponents.nid.toLowerCase();
    const urnScheme = `${scheme}:${options.nid || nid}`;
    const schemeHandler = SCHEMES[urnScheme];
    if (schemeHandler) {
      urnComponents = schemeHandler.serialize(urnComponents, options);
    }
    const uriComponents = urnComponents;
    const nss = urnComponents.nss;
    uriComponents.path = `${nid || options.nid}:${nss}`;
    options.skipEscape = true;
    return uriComponents;
  }
  function urnuuidParse(urnComponents, options) {
    const uuidComponents = urnComponents;
    uuidComponents.uuid = uuidComponents.nss;
    uuidComponents.nss = void 0;
    if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
      uuidComponents.error = uuidComponents.error || "UUID is not valid.";
    }
    return uuidComponents;
  }
  function urnuuidSerialize(uuidComponents) {
    const urnComponents = uuidComponents;
    urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
    return urnComponents;
  }
  var http2 = {
    scheme: "http",
    domainHost: true,
    parse: httpParse,
    serialize: httpSerialize
  };
  var https2 = {
    scheme: "https",
    domainHost: http2.domainHost,
    parse: httpParse,
    serialize: httpSerialize
  };
  var ws = {
    scheme: "ws",
    domainHost: true,
    parse: wsParse,
    serialize: wsSerialize
  };
  var wss = {
    scheme: "wss",
    domainHost: ws.domainHost,
    parse: ws.parse,
    serialize: ws.serialize
  };
  var urn = {
    scheme: "urn",
    parse: urnParse,
    serialize: urnSerialize,
    skipNormalize: true
  };
  var urnuuid = {
    scheme: "urn:uuid",
    parse: urnuuidParse,
    serialize: urnuuidSerialize,
    skipNormalize: true
  };
  var SCHEMES = {
    http: http2,
    https: https2,
    ws,
    wss,
    urn,
    "urn:uuid": urnuuid
  };
  module2.exports = SCHEMES;
});
var require_fast_uri = __commonJS((exports, module2) => {
  var { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require_utils();
  var SCHEMES = require_schemes();
  function normalize2(uri, options) {
    if (typeof uri === "string") {
      uri = serialize(parse6(uri, options), options);
    } else if (typeof uri === "object") {
      uri = parse6(serialize(uri, options), options);
    }
    return uri;
  }
  function resolve3(baseURI, relativeURI, options) {
    const schemelessOptions = Object.assign({ scheme: "null" }, options);
    const resolved = resolveComponents(parse6(baseURI, schemelessOptions), parse6(relativeURI, schemelessOptions), schemelessOptions, true);
    return serialize(resolved, { ...schemelessOptions, skipEscape: true });
  }
  function resolveComponents(base, relative4, options, skipNormalization) {
    const target = {};
    if (!skipNormalization) {
      base = parse6(serialize(base, options), options);
      relative4 = parse6(serialize(relative4, options), options);
    }
    options = options || {};
    if (!options.tolerant && relative4.scheme) {
      target.scheme = relative4.scheme;
      target.userinfo = relative4.userinfo;
      target.host = relative4.host;
      target.port = relative4.port;
      target.path = removeDotSegments(relative4.path || "");
      target.query = relative4.query;
    } else {
      if (relative4.userinfo !== void 0 || relative4.host !== void 0 || relative4.port !== void 0) {
        target.userinfo = relative4.userinfo;
        target.host = relative4.host;
        target.port = relative4.port;
        target.path = removeDotSegments(relative4.path || "");
        target.query = relative4.query;
      } else {
        if (!relative4.path) {
          target.path = base.path;
          if (relative4.query !== void 0) {
            target.query = relative4.query;
          } else {
            target.query = base.query;
          }
        } else {
          if (relative4.path.charAt(0) === "/") {
            target.path = removeDotSegments(relative4.path);
          } else {
            if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
              target.path = "/" + relative4.path;
            } else if (!base.path) {
              target.path = relative4.path;
            } else {
              target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative4.path;
            }
            target.path = removeDotSegments(target.path);
          }
          target.query = relative4.query;
        }
        target.userinfo = base.userinfo;
        target.host = base.host;
        target.port = base.port;
      }
      target.scheme = base.scheme;
    }
    target.fragment = relative4.fragment;
    return target;
  }
  function equal(uriA, uriB, options) {
    if (typeof uriA === "string") {
      uriA = unescape(uriA);
      uriA = serialize(normalizeComponentEncoding(parse6(uriA, options), true), { ...options, skipEscape: true });
    } else if (typeof uriA === "object") {
      uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
    }
    if (typeof uriB === "string") {
      uriB = unescape(uriB);
      uriB = serialize(normalizeComponentEncoding(parse6(uriB, options), true), { ...options, skipEscape: true });
    } else if (typeof uriB === "object") {
      uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
    }
    return uriA.toLowerCase() === uriB.toLowerCase();
  }
  function serialize(cmpts, opts) {
    const components = {
      host: cmpts.host,
      scheme: cmpts.scheme,
      userinfo: cmpts.userinfo,
      port: cmpts.port,
      path: cmpts.path,
      query: cmpts.query,
      nid: cmpts.nid,
      nss: cmpts.nss,
      uuid: cmpts.uuid,
      fragment: cmpts.fragment,
      reference: cmpts.reference,
      resourceName: cmpts.resourceName,
      secure: cmpts.secure,
      error: ""
    };
    const options = Object.assign({}, opts);
    const uriTokens = [];
    const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
    if (schemeHandler && schemeHandler.serialize)
      schemeHandler.serialize(components, options);
    if (components.path !== void 0) {
      if (!options.skipEscape) {
        components.path = escape(components.path);
        if (components.scheme !== void 0) {
          components.path = components.path.split("%3A").join(":");
        }
      } else {
        components.path = unescape(components.path);
      }
    }
    if (options.reference !== "suffix" && components.scheme) {
      uriTokens.push(components.scheme, ":");
    }
    const authority = recomposeAuthority(components);
    if (authority !== void 0) {
      if (options.reference !== "suffix") {
        uriTokens.push("//");
      }
      uriTokens.push(authority);
      if (components.path && components.path.charAt(0) !== "/") {
        uriTokens.push("/");
      }
    }
    if (components.path !== void 0) {
      let s = components.path;
      if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
        s = removeDotSegments(s);
      }
      if (authority === void 0) {
        s = s.replace(/^\/\//u, "/%2F");
      }
      uriTokens.push(s);
    }
    if (components.query !== void 0) {
      uriTokens.push("?", components.query);
    }
    if (components.fragment !== void 0) {
      uriTokens.push("#", components.fragment);
    }
    return uriTokens.join("");
  }
  var hexLookUp = Array.from({ length: 127 }, (_v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));
  function nonSimpleDomain(value) {
    let code = 0;
    for (let i = 0, len = value.length; i < len; ++i) {
      code = value.charCodeAt(i);
      if (code > 126 || hexLookUp[code]) {
        return true;
      }
    }
    return false;
  }
  var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function parse6(uri, opts) {
    const options = Object.assign({}, opts);
    const parsed = {
      scheme: void 0,
      userinfo: void 0,
      host: "",
      port: void 0,
      path: "",
      query: void 0,
      fragment: void 0
    };
    const gotEncoding = uri.indexOf("%") !== -1;
    let isIP = false;
    if (options.reference === "suffix")
      uri = (options.scheme ? options.scheme + ":" : "") + "//" + uri;
    const matches = uri.match(URI_PARSE);
    if (matches) {
      parsed.scheme = matches[1];
      parsed.userinfo = matches[3];
      parsed.host = matches[4];
      parsed.port = parseInt(matches[5], 10);
      parsed.path = matches[6] || "";
      parsed.query = matches[7];
      parsed.fragment = matches[8];
      if (isNaN(parsed.port)) {
        parsed.port = matches[5];
      }
      if (parsed.host) {
        const ipv4result = normalizeIPv4(parsed.host);
        if (ipv4result.isIPV4 === false) {
          const ipv6result = normalizeIPv6(ipv4result.host);
          parsed.host = ipv6result.host.toLowerCase();
          isIP = ipv6result.isIPV6;
        } else {
          parsed.host = ipv4result.host;
          isIP = true;
        }
      }
      if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
        parsed.reference = "same-document";
      } else if (parsed.scheme === void 0) {
        parsed.reference = "relative";
      } else if (parsed.fragment === void 0) {
        parsed.reference = "absolute";
      } else {
        parsed.reference = "uri";
      }
      if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
        parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
      }
      const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
      if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
        if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
          try {
            parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
          } catch (e) {
            parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
          }
        }
      }
      if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
        if (gotEncoding && parsed.scheme !== void 0) {
          parsed.scheme = unescape(parsed.scheme);
        }
        if (gotEncoding && parsed.host !== void 0) {
          parsed.host = unescape(parsed.host);
        }
        if (parsed.path) {
          parsed.path = escape(unescape(parsed.path));
        }
        if (parsed.fragment) {
          parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
        }
      }
      if (schemeHandler && schemeHandler.parse) {
        schemeHandler.parse(parsed, options);
      }
    } else {
      parsed.error = parsed.error || "URI can not be parsed.";
    }
    return parsed;
  }
  var fastUri = {
    SCHEMES,
    normalize: normalize2,
    resolve: resolve3,
    resolveComponents,
    equal,
    serialize,
    parse: parse6
  };
  module2.exports = fastUri;
  module2.exports.default = fastUri;
  module2.exports.fastUri = fastUri;
});
var require_uri = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var uri = require_fast_uri();
  uri.code = 'require("ajv/dist/runtime/uri").default';
  exports.default = uri;
});
var require_core = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
  var validate_1 = require_validate();
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_1.KeywordCxt;
  } });
  var codegen_1 = require_codegen();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_1._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_1.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_1.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_1.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_1.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_1.CodeGen;
  } });
  var validation_error_1 = require_validation_error();
  var ref_error_1 = require_ref_error();
  var rules_1 = require_rules();
  var compile_1 = require_compile();
  var codegen_2 = require_codegen();
  var resolve_1 = require_resolve();
  var dataType_1 = require_dataType();
  var util_1 = require_util();
  var $dataRefSchema = require_data();
  var uri_1 = require_uri();
  var defaultRegExp = (str, flags) => new RegExp(str, flags);
  defaultRegExp.code = "new RegExp";
  var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  var removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  var deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  var MAX_EXPRESSION = 200;
  function requiredOptions(o) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
    const s = o.strict;
    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
    const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
    return {
      strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
      strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
      strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
      strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
      strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
      code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
      loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
      loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
      meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
      messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
      inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
      schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
      addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
      validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
      validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
      unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
      int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
      uriResolver
    };
  }
  class Ajv {
    constructor(opts = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = /* @__PURE__ */ new Set();
      this._loading = {};
      this._cache = /* @__PURE__ */ new Map();
      opts = this.opts = { ...opts, ...requiredOptions(opts) };
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger(opts.logger);
      const formatOpt = opts.validateFormats;
      opts.validateFormats = false;
      this.RULES = (0, rules_1.getRules)();
      checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts.keywords)
        addInitialKeywords.call(this, opts.keywords);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      addInitialSchemas.call(this);
      opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = { ...$dataRefSchema };
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
    }
    validate(schemaKeyRef, data) {
      let v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v = this.compile(schemaKeyRef);
      }
      const valid = v(data);
      if (!("$async" in v))
        this.errors = v.errors;
      return valid;
    }
    compile(schema, _meta) {
      const sch = this._addSchema(schema, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema, meta) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema, meta);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e) {
          if (!(e instanceof ref_error_1.default))
            throw e;
          checkLoaded.call(this, e);
          await loadMissingSchema.call(this, e.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref, missingRef }) {
        if (this.refs[ref]) {
          throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref) {
        const _schema = await _loadSchema.call(this, ref);
        if (!this.refs[ref])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref])
          this.addSchema(_schema, ref, meta);
      }
      async function _loadSchema(ref) {
        const p = this._loading[ref];
        if (p)
          return p;
        try {
          return await (this._loading[ref] = loadSchema(ref));
        } finally {
          delete this._loading[ref];
        }
      }
    }
    addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema)) {
        for (const sch of schema)
          this.addSchema(sch, void 0, _meta, _validateSchema);
        return this;
      }
      let id;
      if (typeof schema === "object") {
        const { schemaId } = this.opts;
        id = schema[schemaId];
        if (id !== void 0 && typeof id != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key = (0, resolve_1.normalizeId)(key || id);
      this._checkUnique(key);
      this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
      return this;
    }
    addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema, key, true, _validateSchema);
      return this;
    }
    validateSchema(schema, throwOrLogError) {
      if (typeof schema == "boolean")
        return true;
      let $schema;
      $schema = schema.$schema;
      if ($schema !== void 0 && typeof $schema != "string") {
        throw new Error("$schema must be a string");
      }
      $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid = this.validate($schema, schema);
      if (!valid && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid;
    }
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === void 0) {
        const { schemaId } = this.opts;
        const root2 = new compile_1.SchemaEnv({ schema: {}, schemaId });
        sch = compile_1.resolveSchema.call(this, root2, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey = schemaKeyRef;
          this._cache.delete(cacheKey);
          let id = schemaKeyRef[this.opts.schemaId];
          if (id) {
            id = (0, resolve_1.normalizeId)(id);
            delete this.schemas[id];
            delete this.refs[id];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    addVocabulary(definitions) {
      for (const def of definitions)
        this.addKeyword(def);
      return this;
    }
    addKeyword(kwdOrDef, def) {
      let keyword;
      if (typeof kwdOrDef == "string") {
        keyword = kwdOrDef;
        if (typeof def == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def.keyword = keyword;
        }
      } else if (typeof kwdOrDef == "object" && def === void 0) {
        def = kwdOrDef;
        keyword = def.keyword;
        if (Array.isArray(keyword) && !keyword.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword, def);
      if (!def) {
        (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def);
      const definition = {
        ...def,
        type: (0, dataType_1.getJSONTypes)(def.type),
        schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
      };
      (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t2) => addRule.call(this, k, definition, t2)));
      return this;
    }
    getKeyword(keyword) {
      const rule = this.RULES.all[keyword];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    removeKeyword(keyword) {
      const { RULES } = this;
      delete RULES.keywords[keyword];
      delete RULES.all[keyword];
      for (const group of RULES.rules) {
        const i = group.rules.findIndex((rule) => rule.keyword === keyword);
        if (i >= 0)
          group.rules.splice(i, 1);
      }
      return this;
    }
    addFormat(name, format) {
      if (typeof format == "string")
        format = new RegExp(format);
      this.formats[name] = format;
      return this;
    }
    errorsText(errors3 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors3 || errors3.length === 0)
        return "No errors";
      return errors3.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      const rules = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key in rules) {
          const rule = rules[key];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema = keywords[key];
          if ($data && schema)
            keywords[key] = schemaOrData(schema);
        }
      }
      return metaSchema;
    }
    _removeAllSchemas(schemas4, regex) {
      for (const keyRef in schemas4) {
        const sch = schemas4[keyRef];
        if (!regex || regex.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas4[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas4[keyRef];
          }
        }
      }
    }
    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id;
      const { schemaId } = this.opts;
      if (typeof schema == "object") {
        id = schema[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema);
      if (sch !== void 0)
        return sch;
      baseId = (0, resolve_1.normalizeId)(id || baseId);
      const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
      sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema, true);
      return sch;
    }
    _checkUnique(id) {
      if (this.schemas[id] || this.refs[id]) {
        throw new Error(`schema with key or id "${id}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_1.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_1.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  Ajv.ValidationError = validation_error_1.default;
  Ajv.MissingRefError = ref_error_1.default;
  exports.default = Ajv;
  function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
      const opt = key;
      if (opt in options)
        this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
  }
  function getSchEnv(keyRef) {
    keyRef = (0, resolve_1.normalizeId)(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  }
  function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key in optsSchemas)
        this.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats() {
    for (const name in this.opts.formats) {
      const format = this.opts.formats[name];
      if (format)
        this.addFormat(name, format);
    }
  }
  function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword in defs) {
      const def = defs[keyword];
      if (!def.keyword)
        def.keyword = keyword;
      this.addKeyword(def);
    }
  }
  function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  }
  var noLogs = { log() {
  }, warn() {
  }, error() {
  } };
  function getLogger(logger) {
    if (logger === false)
      return noLogs;
    if (logger === void 0)
      return console;
    if (logger.log && logger.warn && logger.error)
      return logger;
    throw new Error("logger must implement log, warn and error methods");
  }
  var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  function checkKeyword(keyword, def) {
    const { RULES } = this;
    (0, util_1.eachItem)(keyword, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def)
      return;
    if (def.$data && !("code" in def || "validate" in def)) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  }
  function addRule(keyword, definition, dataType) {
    var _a;
    const post = definition === null || definition === void 0 ? void 0 : definition.post;
    if (dataType && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType);
    if (!ruleGroup) {
      ruleGroup = { type: dataType, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword] = true;
    if (!definition)
      return;
    const rule = {
      keyword,
      definition: {
        ...definition,
        type: (0, dataType_1.getJSONTypes)(definition.type),
        schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
      }
    };
    if (definition.before)
      addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword] = rule;
    (_a = definition.implements) === null || _a === void 0 || _a.forEach((kwd) => this.addKeyword(kwd));
  }
  function addBeforeRule(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i >= 0) {
      ruleGroup.rules.splice(i, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  }
  function keywordMetaschema(def) {
    let { metaSchema } = def;
    if (metaSchema === void 0)
      return;
    if (def.$data && this.opts.$data)
      metaSchema = schemaOrData(metaSchema);
    def.validateSchema = this.compile(metaSchema, true);
  }
  var $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function schemaOrData(schema) {
    return { anyOf: [schema, $dataRef] };
  }
});
var require_id = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var def = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  exports.default = def;
});
var require_ref = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.callRef = exports.getValidate = void 0;
  var ref_error_1 = require_ref_error();
  var code_1 = require_code2();
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var compile_1 = require_compile();
  var util_1 = require_util();
  var def = {
    keyword: "$ref",
    schemaType: "string",
    code(cxt) {
      const { gen, schema: $ref, it } = cxt;
      const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
      const { root: root2 } = env;
      if (($ref === "#" || $ref === "#/") && baseId === root2.baseId)
        return callRootRef();
      const schOrEnv = compile_1.resolveRef.call(self2, root2, baseId, $ref);
      if (schOrEnv === void 0)
        throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
      if (schOrEnv instanceof compile_1.SchemaEnv)
        return callValidate(schOrEnv);
      return inlineRefSchema(schOrEnv);
      function callRootRef() {
        if (env === root2)
          return callRef(cxt, validateName, env, env.$async);
        const rootName = gen.scopeValue("root", { ref: root2 });
        return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root2, root2.$async);
      }
      function callValidate(sch) {
        const v = getValidate(cxt, sch);
        callRef(cxt, v, sch, sch.$async);
      }
      function inlineRefSchema(sch) {
        const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
        const valid = gen.name("valid");
        const schCxt = cxt.subschema({
          schema: sch,
          dataTypes: [],
          schemaPath: codegen_1.nil,
          topSchemaRef: schName,
          errSchemaPath: $ref
        }, valid);
        cxt.mergeEvaluated(schCxt);
        cxt.ok(valid);
      }
    }
  };
  function getValidate(cxt, sch) {
    const { gen } = cxt;
    return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
  }
  exports.getValidate = getValidate;
  function callRef(cxt, v, sch, $async) {
    const { gen, it } = cxt;
    const { allErrors, schemaEnv: env, opts } = it;
    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
    if ($async)
      callAsyncRef();
    else
      callSyncRef();
    function callAsyncRef() {
      if (!env.$async)
        throw new Error("async schema referenced by sync schema");
      const valid = gen.let("valid");
      gen.try(() => {
        gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
        addEvaluatedFrom(v);
        if (!allErrors)
          gen.assign(valid, true);
      }, (e) => {
        gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
        addErrorsFrom(e);
        if (!allErrors)
          gen.assign(valid, false);
      });
      cxt.ok(valid);
    }
    function callSyncRef() {
      cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
    }
    function addErrorsFrom(source) {
      const errs = (0, codegen_1._)`${source}.errors`;
      gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
      gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
    }
    function addEvaluatedFrom(source) {
      var _a;
      if (!it.opts.unevaluated)
        return;
      const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
      if (it.props !== true) {
        if (schEvaluated && !schEvaluated.dynamicProps) {
          if (schEvaluated.props !== void 0) {
            it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
          }
        } else {
          const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
          it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
        }
      }
      if (it.items !== true) {
        if (schEvaluated && !schEvaluated.dynamicItems) {
          if (schEvaluated.items !== void 0) {
            it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
          }
        } else {
          const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
          it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
        }
      }
    }
  }
  exports.callRef = callRef;
  exports.default = def;
});
var require_core2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var id_1 = require_id();
  var ref_1 = require_ref();
  var core2 = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    id_1.default,
    ref_1.default
  ];
  exports.default = core2;
});
var require_limitNumber = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var ops = codegen_1.operators;
  var KWDs = {
    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
  };
  var error2 = {
    message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
  };
  var def = {
    keyword: Object.keys(KWDs),
    type: "number",
    schemaType: "number",
    $data: true,
    error: error2,
    code(cxt) {
      const { keyword, data, schemaCode } = cxt;
      cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
    }
  };
  exports.default = def;
});
var require_multipleOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var error2 = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
    params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
  };
  var def = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: true,
    error: error2,
    code(cxt) {
      const { gen, data, schemaCode, it } = cxt;
      const prec = it.opts.multipleOfPrecision;
      const res = gen.let("res");
      const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
      cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
    }
  };
  exports.default = def;
});
var require_ucs2length = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function ucs2length(str) {
    const len = str.length;
    let length = 0;
    let pos = 0;
    let value;
    while (pos < len) {
      length++;
      value = str.charCodeAt(pos++);
      if (value >= 55296 && value <= 56319 && pos < len) {
        value = str.charCodeAt(pos);
        if ((value & 64512) === 56320)
          pos++;
      }
    }
    return length;
  }
  exports.default = ucs2length;
  ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
});
var require_limitLength = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var ucs2length_1 = require_ucs2length();
  var error2 = {
    message({ keyword, schemaCode }) {
      const comp = keyword === "maxLength" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  var def = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: true,
    error: error2,
    code(cxt) {
      const { keyword, data, schemaCode, it } = cxt;
      const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
      const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
      cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
    }
  };
  exports.default = def;
});
var require_pattern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code2();
  var codegen_1 = require_codegen();
  var error2 = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
  };
  var def = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: true,
    error: error2,
    code(cxt) {
      const { data, $data, schema, schemaCode, it } = cxt;
      const u = it.opts.unicodeRegExp ? "u" : "";
      const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
      cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
    }
  };
  exports.default = def;
});
var require_limitProperties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var error2 = {
    message({ keyword, schemaCode }) {
      const comp = keyword === "maxProperties" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  var def = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: true,
    error: error2,
    code(cxt) {
      const { keyword, data, schemaCode } = cxt;
      const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
      cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
    }
  };
  exports.default = def;
});
var require_required = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code2();
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var error2 = {
    message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
    params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
  };
  var def = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: true,
    error: error2,
    code(cxt) {
      const { gen, schema, schemaCode, data, $data, it } = cxt;
      const { opts } = it;
      if (!$data && schema.length === 0)
        return;
      const useLoop = schema.length >= opts.loopRequired;
      if (it.allErrors)
        allErrorsMode();
      else
        exitOnErrorMode();
      if (opts.strictRequired) {
        const props = cxt.parentSchema.properties;
        const { definedProperties } = cxt.it;
        for (const requiredKey of schema) {
          if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
            const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
            const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
            (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
          }
        }
      }
      function allErrorsMode() {
        if (useLoop || $data) {
          cxt.block$data(codegen_1.nil, loopAllRequired);
        } else {
          for (const prop of schema) {
            (0, code_1.checkReportMissingProp)(cxt, prop);
          }
        }
      }
      function exitOnErrorMode() {
        const missing = gen.let("missing");
        if (useLoop || $data) {
          const valid = gen.let("valid", true);
          cxt.block$data(valid, () => loopUntilMissing(missing, valid));
          cxt.ok(valid);
        } else {
          gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
      function loopAllRequired() {
        gen.forOf("prop", schemaCode, (prop) => {
          cxt.setParams({ missingProperty: prop });
          gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
        });
      }
      function loopUntilMissing(missing, valid) {
        cxt.setParams({ missingProperty: missing });
        gen.forOf(missing, schemaCode, () => {
          gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error();
            gen.break();
          });
        }, codegen_1.nil);
      }
    }
  };
  exports.default = def;
});
var require_limitItems = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var error2 = {
    message({ keyword, schemaCode }) {
      const comp = keyword === "maxItems" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  var def = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: true,
    error: error2,
    code(cxt) {
      const { keyword, data, schemaCode } = cxt;
      const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
      cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
    }
  };
  exports.default = def;
});
var require_equal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var equal = require_fast_deep_equal();
  equal.code = 'require("ajv/dist/runtime/equal").default';
  exports.default = equal;
});
var require_uniqueItems = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var dataType_1 = require_dataType();
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var equal_1 = require_equal();
  var error2 = {
    message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
    params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
  };
  var def = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: true,
    error: error2,
    code(cxt) {
      const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
      if (!$data && !schema)
        return;
      const valid = gen.let("valid");
      const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
      cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
      cxt.ok(valid);
      function validateUniqueItems() {
        const i = gen.let("i", (0, codegen_1._)`${data}.length`);
        const j = gen.let("j");
        cxt.setParams({ i, j });
        gen.assign(valid, true);
        gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
      }
      function canOptimize() {
        return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
      }
      function loopN(i, j) {
        const item = gen.name("item");
        const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
        const indices = gen.const("indices", (0, codegen_1._)`{}`);
        gen.for((0, codegen_1._)`;${i}--;`, () => {
          gen.let(item, (0, codegen_1._)`${data}[${i}]`);
          gen.if(wrongType, (0, codegen_1._)`continue`);
          if (itemTypes.length > 1)
            gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
          gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
            gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
            cxt.error();
            gen.assign(valid, false).break();
          }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
        });
      }
      function loopN2(i, j) {
        const eql = (0, util_1.useFunc)(gen, equal_1.default);
        const outer = gen.name("outer");
        gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
          cxt.error();
          gen.assign(valid, false).break(outer);
        })));
      }
    }
  };
  exports.default = def;
});
var require_const = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var equal_1 = require_equal();
  var error2 = {
    message: "must be equal to constant",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
  };
  var def = {
    keyword: "const",
    $data: true,
    error: error2,
    code(cxt) {
      const { gen, data, $data, schemaCode, schema } = cxt;
      if ($data || schema && typeof schema == "object") {
        cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
      } else {
        cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
      }
    }
  };
  exports.default = def;
});
var require_enum = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var equal_1 = require_equal();
  var error2 = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
  };
  var def = {
    keyword: "enum",
    schemaType: "array",
    $data: true,
    error: error2,
    code(cxt) {
      const { gen, data, $data, schema, schemaCode, it } = cxt;
      if (!$data && schema.length === 0)
        throw new Error("enum must have non-empty array");
      const useLoop = schema.length >= it.opts.loopEnum;
      let eql;
      const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
      let valid;
      if (useLoop || $data) {
        valid = gen.let("valid");
        cxt.block$data(valid, loopEnum);
      } else {
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const vSchema = gen.const("vSchema", schemaCode);
        valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
      }
      cxt.pass(valid);
      function loopEnum() {
        gen.assign(valid, false);
        gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
      }
      function equalCode(vSchema, i) {
        const sch = schema[i];
        return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
      }
    }
  };
  exports.default = def;
});
var require_validation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var limitNumber_1 = require_limitNumber();
  var multipleOf_1 = require_multipleOf();
  var limitLength_1 = require_limitLength();
  var pattern_1 = require_pattern();
  var limitProperties_1 = require_limitProperties();
  var required_1 = require_required();
  var limitItems_1 = require_limitItems();
  var uniqueItems_1 = require_uniqueItems();
  var const_1 = require_const();
  var enum_1 = require_enum();
  var validation = [
    limitNumber_1.default,
    multipleOf_1.default,
    limitLength_1.default,
    pattern_1.default,
    limitProperties_1.default,
    required_1.default,
    limitItems_1.default,
    uniqueItems_1.default,
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    const_1.default,
    enum_1.default
  ];
  exports.default = validation;
});
var require_additionalItems = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateAdditionalItems = void 0;
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var error2 = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  var def = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: error2,
    code(cxt) {
      const { parentSchema, it } = cxt;
      const { items } = parentSchema;
      if (!Array.isArray(items)) {
        (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      validateAdditionalItems(cxt, items);
    }
  };
  function validateAdditionalItems(cxt, items) {
    const { gen, schema, data, keyword, it } = cxt;
    it.items = true;
    const len = gen.const("len", (0, codegen_1._)`${data}.length`);
    if (schema === false) {
      cxt.setParams({ len: items.length });
      cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
    } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
      const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
      gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
      cxt.ok(valid);
    }
    function validateItems(valid) {
      gen.forRange("i", items.length, len, (i) => {
        cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
        if (!it.allErrors)
          gen.if((0, codegen_1.not)(valid), () => gen.break());
      });
    }
  }
  exports.validateAdditionalItems = validateAdditionalItems;
  exports.default = def;
});
var require_items = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateTuple = void 0;
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var code_1 = require_code2();
  var def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(cxt) {
      const { schema, it } = cxt;
      if (Array.isArray(schema))
        return validateTuple(cxt, "additionalItems", schema);
      it.items = true;
      if ((0, util_1.alwaysValidSchema)(it, schema))
        return;
      cxt.ok((0, code_1.validateArray)(cxt));
    }
  };
  function validateTuple(cxt, extraItems, schArr = cxt.schema) {
    const { gen, parentSchema, data, keyword, it } = cxt;
    checkStrictTuple(parentSchema);
    if (it.opts.unevaluated && schArr.length && it.items !== true) {
      it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
    }
    const valid = gen.name("valid");
    const len = gen.const("len", (0, codegen_1._)`${data}.length`);
    schArr.forEach((sch, i) => {
      if ((0, util_1.alwaysValidSchema)(it, sch))
        return;
      gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
        keyword,
        schemaProp: i,
        dataProp: i
      }, valid));
      cxt.ok(valid);
    });
    function checkStrictTuple(sch) {
      const { opts, errSchemaPath } = it;
      const l = schArr.length;
      const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
      if (opts.strictTuples && !fullTuple) {
        const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
        (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
      }
    }
  }
  exports.validateTuple = validateTuple;
  exports.default = def;
});
var require_prefixItems = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var items_1 = require_items();
  var def = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
  };
  exports.default = def;
});
var require_items2020 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var code_1 = require_code2();
  var additionalItems_1 = require_additionalItems();
  var error2 = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  var def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: error2,
    code(cxt) {
      const { schema, parentSchema, it } = cxt;
      const { prefixItems } = parentSchema;
      it.items = true;
      if ((0, util_1.alwaysValidSchema)(it, schema))
        return;
      if (prefixItems)
        (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
      else
        cxt.ok((0, code_1.validateArray)(cxt));
    }
  };
  exports.default = def;
});
var require_contains = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var error2 = {
    message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
    params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
  };
  var def = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: true,
    error: error2,
    code(cxt) {
      const { gen, schema, parentSchema, data, it } = cxt;
      let min;
      let max;
      const { minContains, maxContains } = parentSchema;
      if (it.opts.next) {
        min = minContains === void 0 ? 1 : minContains;
        max = maxContains;
      } else {
        min = 1;
      }
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      cxt.setParams({ min, max });
      if (max === void 0 && min === 0) {
        (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
        return;
      }
      if (max !== void 0 && min > max) {
        (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
        cxt.fail();
        return;
      }
      if ((0, util_1.alwaysValidSchema)(it, schema)) {
        let cond = (0, codegen_1._)`${len} >= ${min}`;
        if (max !== void 0)
          cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
        cxt.pass(cond);
        return;
      }
      it.items = true;
      const valid = gen.name("valid");
      if (max === void 0 && min === 1) {
        validateItems(valid, () => gen.if(valid, () => gen.break()));
      } else if (min === 0) {
        gen.let(valid, true);
        if (max !== void 0)
          gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
      } else {
        gen.let(valid, false);
        validateItemsWithCount();
      }
      cxt.result(valid, () => cxt.reset());
      function validateItemsWithCount() {
        const schValid = gen.name("_valid");
        const count = gen.let("count", 0);
        validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
      }
      function validateItems(_valid, block) {
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword: "contains",
            dataProp: i,
            dataPropType: util_1.Type.Num,
            compositeRule: true
          }, _valid);
          block();
        });
      }
      function checkLimits(count) {
        gen.code((0, codegen_1._)`${count}++`);
        if (max === void 0) {
          gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
        } else {
          gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
          if (min === 1)
            gen.assign(valid, true);
          else
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
        }
      }
    }
  };
  exports.default = def;
});
var require_dependencies = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var code_1 = require_code2();
  exports.error = {
    message: ({ params: { property, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
  };
  var def = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  function splitDependencies({ schema }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema) {
      if (key === "__proto__")
        continue;
      const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
      deps[key] = schema[key];
    }
    return [propertyDeps, schemaDeps];
  }
  function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it.allErrors) {
        gen.if(hasProperty, () => {
          for (const depProp of deps) {
            (0, code_1.checkReportMissingProp)(cxt, depProp);
          }
        });
      } else {
        gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
        (0, code_1.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
  }
  exports.validatePropertyDeps = validatePropertyDeps;
  function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword, it } = cxt;
    const valid = gen.name("valid");
    for (const prop in schemaDeps) {
      if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
        continue;
      gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
        const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
        cxt.mergeValidEvaluated(schCxt, valid);
      }, () => gen.var(valid, true));
      cxt.ok(valid);
    }
  }
  exports.validateSchemaDeps = validateSchemaDeps;
  exports.default = def;
});
var require_propertyNames = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var error2 = {
    message: "property name must be valid",
    params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
  };
  var def = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: error2,
    code(cxt) {
      const { gen, schema, data, it } = cxt;
      if ((0, util_1.alwaysValidSchema)(it, schema))
        return;
      const valid = gen.name("valid");
      gen.forIn("key", data, (key) => {
        cxt.setParams({ propertyName: key });
        cxt.subschema({
          keyword: "propertyNames",
          data: key,
          dataTypes: ["string"],
          propertyName: key,
          compositeRule: true
        }, valid);
        gen.if((0, codegen_1.not)(valid), () => {
          cxt.error(true);
          if (!it.allErrors)
            gen.break();
        });
      });
      cxt.ok(valid);
    }
  };
  exports.default = def;
});
var require_additionalProperties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code2();
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var util_1 = require_util();
  var error2 = {
    message: "must NOT have additional properties",
    params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
  };
  var def = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: true,
    trackErrors: true,
    error: error2,
    code(cxt) {
      const { gen, schema, parentSchema, data, errsCount, it } = cxt;
      if (!errsCount)
        throw new Error("ajv implementation error");
      const { allErrors, opts } = it;
      it.props = true;
      if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
        return;
      const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
      const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
      checkAdditionalProperties();
      cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
      function checkAdditionalProperties() {
        gen.forIn("key", data, (key) => {
          if (!props.length && !patProps.length)
            additionalPropertyCode(key);
          else
            gen.if(isAdditional(key), () => additionalPropertyCode(key));
        });
      }
      function isAdditional(key) {
        let definedProp;
        if (props.length > 8) {
          const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
          definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
        } else if (props.length) {
          definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
        } else {
          definedProp = codegen_1.nil;
        }
        if (patProps.length) {
          definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
        }
        return (0, codegen_1.not)(definedProp);
      }
      function deleteAdditional(key) {
        gen.code((0, codegen_1._)`delete ${data}[${key}]`);
      }
      function additionalPropertyCode(key) {
        if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
          deleteAdditional(key);
          return;
        }
        if (schema === false) {
          cxt.setParams({ additionalProperty: key });
          cxt.error();
          if (!allErrors)
            gen.break();
          return;
        }
        if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
          const valid = gen.name("valid");
          if (opts.removeAdditional === "failing") {
            applyAdditionalSchema(key, valid, false);
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.reset();
              deleteAdditional(key);
            });
          } else {
            applyAdditionalSchema(key, valid);
            if (!allErrors)
              gen.if((0, codegen_1.not)(valid), () => gen.break());
          }
        }
      }
      function applyAdditionalSchema(key, valid, errors3) {
        const subschema = {
          keyword: "additionalProperties",
          dataProp: key,
          dataPropType: util_1.Type.Str
        };
        if (errors3 === false) {
          Object.assign(subschema, {
            compositeRule: true,
            createErrors: false,
            allErrors: false
          });
        }
        cxt.subschema(subschema, valid);
      }
    }
  };
  exports.default = def;
});
var require_properties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var validate_1 = require_validate();
  var code_1 = require_code2();
  var util_1 = require_util();
  var additionalProperties_1 = require_additionalProperties();
  var def = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen, schema, parentSchema, data, it } = cxt;
      if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
        additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
      }
      const allProps = (0, code_1.allSchemaProperties)(schema);
      for (const prop of allProps) {
        it.definedProperties.add(prop);
      }
      if (it.opts.unevaluated && allProps.length && it.props !== true) {
        it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
      }
      const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
      if (properties.length === 0)
        return;
      const valid = gen.name("valid");
      for (const prop of properties) {
        if (hasDefault(prop)) {
          applyPropertySchema(prop);
        } else {
          gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
          applyPropertySchema(prop);
          if (!it.allErrors)
            gen.else().var(valid, true);
          gen.endIf();
        }
        cxt.it.definedProperties.add(prop);
        cxt.ok(valid);
      }
      function hasDefault(prop) {
        return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
      }
      function applyPropertySchema(prop) {
        cxt.subschema({
          keyword: "properties",
          schemaProp: prop,
          dataProp: prop
        }, valid);
      }
    }
  };
  exports.default = def;
});
var require_patternProperties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code2();
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var util_2 = require_util();
  var def = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen, schema, data, parentSchema, it } = cxt;
      const { opts } = it;
      const patterns = (0, code_1.allSchemaProperties)(schema);
      const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
      if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
        return;
      }
      const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
      const valid = gen.name("valid");
      if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
        it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
      }
      const { props } = it;
      validatePatternProperties();
      function validatePatternProperties() {
        for (const pat of patterns) {
          if (checkProperties)
            checkMatchingProperties(pat);
          if (it.allErrors) {
            validateProperties(pat);
          } else {
            gen.var(valid, true);
            validateProperties(pat);
            gen.if(valid);
          }
        }
      }
      function checkMatchingProperties(pat) {
        for (const prop in checkProperties) {
          if (new RegExp(pat).test(prop)) {
            (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
          }
        }
      }
      function validateProperties(pat) {
        gen.forIn("key", data, (key) => {
          gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
            const alwaysValid = alwaysValidPatterns.includes(pat);
            if (!alwaysValid) {
              cxt.subschema({
                keyword: "patternProperties",
                schemaProp: pat,
                dataProp: key,
                dataPropType: util_2.Type.Str
              }, valid);
            }
            if (it.opts.unevaluated && props !== true) {
              gen.assign((0, codegen_1._)`${props}[${key}]`, true);
            } else if (!alwaysValid && !it.allErrors) {
              gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          });
        });
      }
    }
  };
  exports.default = def;
});
var require_not = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util();
  var def = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    code(cxt) {
      const { gen, schema, it } = cxt;
      if ((0, util_1.alwaysValidSchema)(it, schema)) {
        cxt.fail();
        return;
      }
      const valid = gen.name("valid");
      cxt.subschema({
        keyword: "not",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, valid);
      cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
    },
    error: { message: "must NOT be valid" }
  };
  exports.default = def;
});
var require_anyOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code2();
  var def = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: true,
    code: code_1.validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  exports.default = def;
});
var require_oneOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var error2 = {
    message: "must match exactly one schema in oneOf",
    params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
  };
  var def = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: true,
    error: error2,
    code(cxt) {
      const { gen, schema, parentSchema, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      if (it.opts.discriminator && parentSchema.discriminator)
        return;
      const schArr = schema;
      const valid = gen.let("valid", false);
      const passing = gen.let("passing", null);
      const schValid = gen.name("_valid");
      cxt.setParams({ passing });
      gen.block(validateOneOf);
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
      function validateOneOf() {
        schArr.forEach((sch, i) => {
          let schCxt;
          if ((0, util_1.alwaysValidSchema)(it, sch)) {
            gen.var(schValid, true);
          } else {
            schCxt = cxt.subschema({
              keyword: "oneOf",
              schemaProp: i,
              compositeRule: true
            }, schValid);
          }
          if (i > 0) {
            gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
          }
          gen.if(schValid, () => {
            gen.assign(valid, true);
            gen.assign(passing, i);
            if (schCxt)
              cxt.mergeEvaluated(schCxt, codegen_1.Name);
          });
        });
      }
    }
  };
  exports.default = def;
});
var require_allOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util();
  var def = {
    keyword: "allOf",
    schemaType: "array",
    code(cxt) {
      const { gen, schema, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const valid = gen.name("valid");
      schema.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
        cxt.ok(valid);
        cxt.mergeEvaluated(schCxt);
      });
    }
  };
  exports.default = def;
});
var require_if = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var error2 = {
    message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
    params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
  };
  var def = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    error: error2,
    code(cxt) {
      const { gen, parentSchema, it } = cxt;
      if (parentSchema.then === void 0 && parentSchema.else === void 0) {
        (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
      }
      const hasThen = hasSchema(it, "then");
      const hasElse = hasSchema(it, "else");
      if (!hasThen && !hasElse)
        return;
      const valid = gen.let("valid", true);
      const schValid = gen.name("_valid");
      validateIf();
      cxt.reset();
      if (hasThen && hasElse) {
        const ifClause = gen.let("ifClause");
        cxt.setParams({ ifClause });
        gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
      } else if (hasThen) {
        gen.if(schValid, validateClause("then"));
      } else {
        gen.if((0, codegen_1.not)(schValid), validateClause("else"));
      }
      cxt.pass(valid, () => cxt.error(true));
      function validateIf() {
        const schCxt = cxt.subschema({
          keyword: "if",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, schValid);
        cxt.mergeEvaluated(schCxt);
      }
      function validateClause(keyword, ifClause) {
        return () => {
          const schCxt = cxt.subschema({ keyword }, schValid);
          gen.assign(valid, schValid);
          cxt.mergeValidEvaluated(schCxt, valid);
          if (ifClause)
            gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
          else
            cxt.setParams({ ifClause: keyword });
        };
      }
    }
  };
  function hasSchema(it, keyword) {
    const schema = it.schema[keyword];
    return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
  }
  exports.default = def;
});
var require_thenElse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util();
  var def = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword, parentSchema, it }) {
      if (parentSchema.if === void 0)
        (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
    }
  };
  exports.default = def;
});
var require_applicator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var additionalItems_1 = require_additionalItems();
  var prefixItems_1 = require_prefixItems();
  var items_1 = require_items();
  var items2020_1 = require_items2020();
  var contains_1 = require_contains();
  var dependencies_1 = require_dependencies();
  var propertyNames_1 = require_propertyNames();
  var additionalProperties_1 = require_additionalProperties();
  var properties_1 = require_properties();
  var patternProperties_1 = require_patternProperties();
  var not_1 = require_not();
  var anyOf_1 = require_anyOf();
  var oneOf_1 = require_oneOf();
  var allOf_1 = require_allOf();
  var if_1 = require_if();
  var thenElse_1 = require_thenElse();
  function getApplicator(draft2020 = false) {
    const applicator = [
      not_1.default,
      anyOf_1.default,
      oneOf_1.default,
      allOf_1.default,
      if_1.default,
      thenElse_1.default,
      propertyNames_1.default,
      additionalProperties_1.default,
      dependencies_1.default,
      properties_1.default,
      patternProperties_1.default
    ];
    if (draft2020)
      applicator.push(prefixItems_1.default, items2020_1.default);
    else
      applicator.push(additionalItems_1.default, items_1.default);
    applicator.push(contains_1.default);
    return applicator;
  }
  exports.default = getApplicator;
});
var require_format = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var error2 = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
  };
  var def = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: true,
    error: error2,
    code(cxt, ruleType) {
      const { gen, data, $data, schema, schemaCode, it } = cxt;
      const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
      if (!opts.validateFormats)
        return;
      if ($data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts.code.formats
        });
        const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
        const fType = gen.let("fType");
        const format = gen.let("format");
        gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
        cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
        function unknownFmt() {
          if (opts.strictSchema === false)
            return codegen_1.nil;
          return (0, codegen_1._)`${schemaCode} && !${format}`;
        }
        function invalidFmt() {
          const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
          const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
          return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
        }
      }
      function validateFormat() {
        const formatDef = self2.formats[schema];
        if (!formatDef) {
          unknownFormat();
          return;
        }
        if (formatDef === true)
          return;
        const [fmtType, format, fmtRef] = getFormat(formatDef);
        if (fmtType === ruleType)
          cxt.pass(validCondition());
        function unknownFormat() {
          if (opts.strictSchema === false) {
            self2.logger.warn(unknownMsg());
            return;
          }
          throw new Error(unknownMsg());
          function unknownMsg() {
            return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
          }
        }
        function getFormat(fmtDef) {
          const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
          const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
          if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
            return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
          }
          return ["string", fmtDef, fmt];
        }
        function validCondition() {
          if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
            if (!schemaEnv.$async)
              throw new Error("async format in sync schema");
            return (0, codegen_1._)`await ${fmtRef}(${data})`;
          }
          return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
        }
      }
    }
  };
  exports.default = def;
});
var require_format2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var format_1 = require_format();
  var format = [format_1.default];
  exports.default = format;
});
var require_metadata = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.contentVocabulary = exports.metadataVocabulary = void 0;
  exports.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ];
  exports.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ];
});
var require_draft7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var core_1 = require_core2();
  var validation_1 = require_validation();
  var applicator_1 = require_applicator();
  var format_1 = require_format2();
  var metadata_1 = require_metadata();
  var draft7Vocabularies = [
    core_1.default,
    validation_1.default,
    (0, applicator_1.default)(),
    format_1.default,
    metadata_1.metadataVocabulary,
    metadata_1.contentVocabulary
  ];
  exports.default = draft7Vocabularies;
});
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiscrError = void 0;
  var DiscrError;
  (function(DiscrError2) {
    DiscrError2["Tag"] = "tag";
    DiscrError2["Mapping"] = "mapping";
  })(DiscrError || (exports.DiscrError = DiscrError = {}));
});
var require_discriminator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var types_1 = require_types();
  var compile_1 = require_compile();
  var ref_error_1 = require_ref_error();
  var util_1 = require_util();
  var error2 = {
    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
  };
  var def = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: error2,
    code(cxt) {
      const { gen, data, schema, parentSchema, it } = cxt;
      const { oneOf } = parentSchema;
      if (!it.opts.discriminator) {
        throw new Error("discriminator: requires discriminator option");
      }
      const tagName = schema.propertyName;
      if (typeof tagName != "string")
        throw new Error("discriminator: requires propertyName");
      if (schema.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!oneOf)
        throw new Error("discriminator: requires oneOf keyword");
      const valid = gen.let("valid", false);
      const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
      gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
      cxt.ok(valid);
      function validateMapping() {
        const mapping = getMapping();
        gen.if(false);
        for (const tagValue in mapping) {
          gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
          gen.assign(valid, applyTagSchema(mapping[tagValue]));
        }
        gen.else();
        cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
        gen.endIf();
      }
      function applyTagSchema(schemaProp) {
        const _valid = gen.name("valid");
        const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
        cxt.mergeEvaluated(schCxt, codegen_1.Name);
        return _valid;
      }
      function getMapping() {
        var _a;
        const oneOfMapping = {};
        const topRequired = hasRequired(parentSchema);
        let tagRequired = true;
        for (let i = 0; i < oneOf.length; i++) {
          let sch = oneOf[i];
          if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
            const ref = sch.$ref;
            sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
            if (sch instanceof compile_1.SchemaEnv)
              sch = sch.schema;
            if (sch === void 0)
              throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
          }
          const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
          if (typeof propSch != "object") {
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
          }
          tagRequired = tagRequired && (topRequired || hasRequired(sch));
          addMappings(propSch, i);
        }
        if (!tagRequired)
          throw new Error(`discriminator: "${tagName}" must be required`);
        return oneOfMapping;
        function hasRequired({ required: required2 }) {
          return Array.isArray(required2) && required2.includes(tagName);
        }
        function addMappings(sch, i) {
          if (sch.const) {
            addMapping(sch.const, i);
          } else if (sch.enum) {
            for (const tagValue of sch.enum) {
              addMapping(tagValue, i);
            }
          } else {
            throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
          }
        }
        function addMapping(tagValue, i) {
          if (typeof tagValue != "string" || tagValue in oneOfMapping) {
            throw new Error(`discriminator: "${tagName}" values must be unique strings`);
          }
          oneOfMapping[tagValue] = i;
        }
      }
    }
  };
  exports.default = def;
});
var require_json_schema_draft_07 = __commonJS((exports, module2) => {
  module2.exports = {
    $schema: "http://json-schema.org/draft-07/schema#",
    $id: "http://json-schema.org/draft-07/schema#",
    title: "Core schema meta-schema",
    definitions: {
      schemaArray: {
        type: "array",
        minItems: 1,
        items: { $ref: "#" }
      },
      nonNegativeInteger: {
        type: "integer",
        minimum: 0
      },
      nonNegativeIntegerDefault0: {
        allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
      },
      simpleTypes: {
        enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
      },
      stringArray: {
        type: "array",
        items: { type: "string" },
        uniqueItems: true,
        default: []
      }
    },
    type: ["object", "boolean"],
    properties: {
      $id: {
        type: "string",
        format: "uri-reference"
      },
      $schema: {
        type: "string",
        format: "uri"
      },
      $ref: {
        type: "string",
        format: "uri-reference"
      },
      $comment: {
        type: "string"
      },
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      default: true,
      readOnly: {
        type: "boolean",
        default: false
      },
      examples: {
        type: "array",
        items: true
      },
      multipleOf: {
        type: "number",
        exclusiveMinimum: 0
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "number"
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "number"
      },
      maxLength: { $ref: "#/definitions/nonNegativeInteger" },
      minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      pattern: {
        type: "string",
        format: "regex"
      },
      additionalItems: { $ref: "#" },
      items: {
        anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
        default: true
      },
      maxItems: { $ref: "#/definitions/nonNegativeInteger" },
      minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      uniqueItems: {
        type: "boolean",
        default: false
      },
      contains: { $ref: "#" },
      maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
      minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      required: { $ref: "#/definitions/stringArray" },
      additionalProperties: { $ref: "#" },
      definitions: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      properties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      patternProperties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        propertyNames: { format: "regex" },
        default: {}
      },
      dependencies: {
        type: "object",
        additionalProperties: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
        }
      },
      propertyNames: { $ref: "#" },
      const: true,
      enum: {
        type: "array",
        items: true,
        minItems: 1,
        uniqueItems: true
      },
      type: {
        anyOf: [
          { $ref: "#/definitions/simpleTypes" },
          {
            type: "array",
            items: { $ref: "#/definitions/simpleTypes" },
            minItems: 1,
            uniqueItems: true
          }
        ]
      },
      format: { type: "string" },
      contentMediaType: { type: "string" },
      contentEncoding: { type: "string" },
      if: { $ref: "#" },
      then: { $ref: "#" },
      else: { $ref: "#" },
      allOf: { $ref: "#/definitions/schemaArray" },
      anyOf: { $ref: "#/definitions/schemaArray" },
      oneOf: { $ref: "#/definitions/schemaArray" },
      not: { $ref: "#" }
    },
    default: true
  };
});
var require_ajv = __commonJS((exports, module2) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
  var core_1 = require_core();
  var draft7_1 = require_draft7();
  var discriminator_1 = require_discriminator();
  var draft7MetaSchema = require_json_schema_draft_07();
  var META_SUPPORT_DATA = ["/properties"];
  var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
  class Ajv extends core_1.default {
    _addVocabularies() {
      super._addVocabularies();
      draft7_1.default.forEach((v) => this.addVocabulary(v));
      if (this.opts.discriminator)
        this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
      this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
    }
  }
  exports.Ajv = Ajv;
  module2.exports = exports = Ajv;
  module2.exports.Ajv = Ajv;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = Ajv;
  var validate_1 = require_validate();
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_1.KeywordCxt;
  } });
  var codegen_1 = require_codegen();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_1._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_1.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_1.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_1.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_1.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_1.CodeGen;
  } });
  var validation_error_1 = require_validation_error();
  Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
    return validation_error_1.default;
  } });
  var ref_error_1 = require_ref_error();
  Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
    return ref_error_1.default;
  } });
});
var require_formats = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
  function fmtDef(validate, compare) {
    return { validate, compare };
  }
  exports.fullFormats = {
    date: fmtDef(date4, compareDate),
    time: fmtDef(getTime(true), compareTime),
    "date-time": fmtDef(getDateTime(true), compareDateTime),
    "iso-time": fmtDef(getTime(), compareIsoTime),
    "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex,
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    byte,
    int32: { type: "number", validate: validateInt32 },
    int64: { type: "number", validate: validateInt64 },
    float: { type: "number", validate: validateNumber },
    double: { type: "number", validate: validateNumber },
    password: true,
    binary: true
  };
  exports.fastFormats = {
    ...exports.fullFormats,
    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
    "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
    "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  };
  exports.formatNames = Object.keys(exports.fullFormats);
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function date4(str) {
    const matches = DATE.exec(str);
    if (!matches)
      return false;
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
  }
  function compareDate(d1, d2) {
    if (!(d1 && d2))
      return;
    if (d1 > d2)
      return 1;
    if (d1 < d2)
      return -1;
    return 0;
  }
  var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
  function getTime(strictTimeZone) {
    return function time3(str) {
      const matches = TIME.exec(str);
      if (!matches)
        return false;
      const hr = +matches[1];
      const min = +matches[2];
      const sec = +matches[3];
      const tz = matches[4];
      const tzSign = matches[5] === "-" ? -1 : 1;
      const tzH = +(matches[6] || 0);
      const tzM = +(matches[7] || 0);
      if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
        return false;
      if (hr <= 23 && min <= 59 && sec < 60)
        return true;
      const utcMin = min - tzM * tzSign;
      const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
      return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
    };
  }
  function compareTime(s1, s2) {
    if (!(s1 && s2))
      return;
    const t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf();
    const t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
    if (!(t1 && t2))
      return;
    return t1 - t2;
  }
  function compareIsoTime(t1, t2) {
    if (!(t1 && t2))
      return;
    const a1 = TIME.exec(t1);
    const a2 = TIME.exec(t2);
    if (!(a1 && a2))
      return;
    t1 = a1[1] + a1[2] + a1[3];
    t2 = a2[1] + a2[2] + a2[3];
    if (t1 > t2)
      return 1;
    if (t1 < t2)
      return -1;
    return 0;
  }
  var DATE_TIME_SEPARATOR = /t|\s/i;
  function getDateTime(strictTimeZone) {
    const time3 = getTime(strictTimeZone);
    return function date_time(str) {
      const dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length === 2 && date4(dateTime[0]) && time3(dateTime[1]);
    };
  }
  function compareDateTime(dt1, dt2) {
    if (!(dt1 && dt2))
      return;
    const d1 = new Date(dt1).valueOf();
    const d2 = new Date(dt2).valueOf();
    if (!(d1 && d2))
      return;
    return d1 - d2;
  }
  function compareIsoDateTime(dt1, dt2) {
    if (!(dt1 && dt2))
      return;
    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
    const res = compareDate(d1, d2);
    if (res === void 0)
      return;
    return res || compareTime(t1, t2);
  }
  var NOT_URI_FRAGMENT = /\/|:/;
  var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function uri(str) {
    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
  }
  var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function byte(str) {
    BYTE.lastIndex = 0;
    return BYTE.test(str);
  }
  var MIN_INT32 = -(2 ** 31);
  var MAX_INT32 = 2 ** 31 - 1;
  function validateInt32(value) {
    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
  }
  function validateInt64(value) {
    return Number.isInteger(value);
  }
  function validateNumber() {
    return true;
  }
  var Z_ANCHOR = /[^\\]\\Z/;
  function regex(str) {
    if (Z_ANCHOR.test(str))
      return false;
    try {
      new RegExp(str);
      return true;
    } catch (e) {
      return false;
    }
  }
});
var require_limit = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatLimitDefinition = void 0;
  var ajv_1 = require_ajv();
  var codegen_1 = require_codegen();
  var ops = codegen_1.operators;
  var KWDs = {
    formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
  };
  var error2 = {
    message: ({ keyword, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
  };
  exports.formatLimitDefinition = {
    keyword: Object.keys(KWDs),
    type: "string",
    schemaType: "string",
    $data: true,
    error: error2,
    code(cxt) {
      const { gen, data, schemaCode, keyword, it } = cxt;
      const { opts, self: self2 } = it;
      if (!opts.validateFormats)
        return;
      const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
      if (fCxt.$data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts.code.formats
        });
        const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
        cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
      }
      function validateFormat() {
        const format = fCxt.schema;
        const fmtDef = self2.formats[format];
        if (!fmtDef || fmtDef === true)
          return;
        if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
          throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
        }
        const fmt = gen.scopeValue("formats", {
          key: format,
          ref: fmtDef,
          code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : void 0
        });
        cxt.fail$data(compareCode(fmt));
      }
      function compareCode(fmt) {
        return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
      }
    },
    dependencies: ["format"]
  };
  var formatLimitPlugin = (ajv) => {
    ajv.addKeyword(exports.formatLimitDefinition);
    return ajv;
  };
  exports.default = formatLimitPlugin;
});
var require_dist = __commonJS((exports, module2) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var formats_1 = require_formats();
  var limit_1 = require_limit();
  var codegen_1 = require_codegen();
  var fullName = new codegen_1.Name("fullFormats");
  var fastName = new codegen_1.Name("fastFormats");
  var formatsPlugin = (ajv, opts = { keywords: true }) => {
    if (Array.isArray(opts)) {
      addFormats(ajv, opts, formats_1.fullFormats, fullName);
      return ajv;
    }
    const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
    const list = opts.formats || formats_1.formatNames;
    addFormats(ajv, list, formats, exportName);
    if (opts.keywords)
      (0, limit_1.default)(ajv);
    return ajv;
  };
  formatsPlugin.get = (name, mode = "full") => {
    const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
    const f = formats[name];
    if (!f)
      throw new Error(`Unknown format "${name}"`);
    return f;
  };
  function addFormats(ajv, list, fs22, exportName) {
    var _a;
    var _b;
    (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 || (_b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`);
    for (const f of list)
      ajv.addFormat(f, fs22[f]);
  }
  module2.exports = exports = formatsPlugin;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = formatsPlugin;
});
var DEFAULT_MAX_LISTENERS = 50;
function createAbortController(maxListeners = DEFAULT_MAX_LISTENERS) {
  const controller = new AbortController();
  (0, import_events.setMaxListeners)(maxListeners, controller.signal);
  return controller;
}
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var _freeGlobal_default = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = _freeGlobal_default || freeSelf || Function("return this")();
var _root_default = root;
var Symbol2 = _root_default.Symbol;
var _Symbol_default = Symbol2;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = _Symbol_default ? _Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var _getRawTag_default = getRawTag;
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var _objectToString_default = objectToString;
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = _Symbol_default ? _Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? _getRawTag_default(value) : _objectToString_default(value);
}
var _baseGetTag_default = baseGetTag;
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject;
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = _baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;
var coreJsData = _root_default["__core-js_shared__"];
var _coreJsData_default = coreJsData;
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(_coreJsData_default && _coreJsData_default.keys && _coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
})();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked_default = isMasked;
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var _toSource_default = toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
  if (!isObject_default(value) || _isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(_toSource_default(value));
}
var _baseIsNative_default = baseIsNative;
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue_default = getValue;
function getNative(object, key) {
  var value = _getValue_default(object, key);
  return _baseIsNative_default(value) ? value : void 0;
}
var _getNative_default = getNative;
var nativeCreate = _getNative_default(Object, "create");
var _nativeCreate_default = nativeCreate;
function hashClear() {
  this.__data__ = _nativeCreate_default ? _nativeCreate_default(null) : {};
  this.size = 0;
}
var _hashClear_default = hashClear;
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete_default = hashDelete;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (_nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty3.call(data, key) ? data[key] : void 0;
}
var _hashGet_default = hashGet;
var objectProto5 = Object.prototype;
var hasOwnProperty4 = objectProto5.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return _nativeCreate_default ? data[key] !== void 0 : hasOwnProperty4.call(data, key);
}
var _hashHas_default = hashHas;
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = _nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var _hashSet_default = hashSet;
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = _hashClear_default;
Hash.prototype["delete"] = _hashDelete_default;
Hash.prototype.get = _hashGet_default;
Hash.prototype.has = _hashHas_default;
Hash.prototype.set = _hashSet_default;
var _Hash_default = Hash;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear_default = listCacheClear;
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;
function assocIndexOf(array2, key) {
  var length = array2.length;
  while (length--) {
    if (eq_default(array2[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf_default = assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = _assocIndexOf_default(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete_default = listCacheDelete;
function listCacheGet(key) {
  var data = this.__data__, index = _assocIndexOf_default(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var _listCacheGet_default = listCacheGet;
function listCacheHas(key) {
  return _assocIndexOf_default(this.__data__, key) > -1;
}
var _listCacheHas_default = listCacheHas;
function listCacheSet(key, value) {
  var data = this.__data__, index = _assocIndexOf_default(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var _listCacheSet_default = listCacheSet;
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = _listCacheClear_default;
ListCache.prototype["delete"] = _listCacheDelete_default;
ListCache.prototype.get = _listCacheGet_default;
ListCache.prototype.has = _listCacheHas_default;
ListCache.prototype.set = _listCacheSet_default;
var _ListCache_default = ListCache;
var Map2 = _getNative_default(_root_default, "Map");
var _Map_default = Map2;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    hash: new _Hash_default(),
    map: new (_Map_default || _ListCache_default)(),
    string: new _Hash_default()
  };
}
var _mapCacheClear_default = mapCacheClear;
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable_default = isKeyable;
function getMapData(map, key) {
  var data = map.__data__;
  return _isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData_default = getMapData;
function mapCacheDelete(key) {
  var result = _getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete_default = mapCacheDelete;
function mapCacheGet(key) {
  return _getMapData_default(this, key).get(key);
}
var _mapCacheGet_default = mapCacheGet;
function mapCacheHas(key) {
  return _getMapData_default(this, key).has(key);
}
var _mapCacheHas_default = mapCacheHas;
function mapCacheSet(key, value) {
  var data = _getMapData_default(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet_default = mapCacheSet;
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = _mapCacheClear_default;
MapCache.prototype["delete"] = _mapCacheDelete_default;
MapCache.prototype.get = _mapCacheGet_default;
MapCache.prototype.has = _mapCacheHas_default;
MapCache.prototype.set = _mapCacheSet_default;
var _MapCache_default = MapCache;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || _MapCache_default)();
  return memoized;
}
memoize.Cache = _MapCache_default;
var memoize_default = memoize;
var CHUNK_SIZE = 2e3;
function writeToStderr(data) {
  if (process.stderr.destroyed) {
    return;
  }
  for (let i = 0; i < data.length; i += CHUNK_SIZE) {
    process.stderr.write(data.substring(i, i + CHUNK_SIZE));
  }
}
var parseDebugFilter = memoize_default((filterString) => {
  if (!filterString || filterString.trim() === "") {
    return null;
  }
  const filters = filterString.split(",").map((f) => f.trim()).filter(Boolean);
  if (filters.length === 0) {
    return null;
  }
  const hasExclusive = filters.some((f) => f.startsWith("!"));
  const hasInclusive = filters.some((f) => !f.startsWith("!"));
  if (hasExclusive && hasInclusive) {
    return null;
  }
  const cleanFilters = filters.map((f) => f.replace(/^!/, "").toLowerCase());
  return {
    include: hasExclusive ? [] : cleanFilters,
    exclude: hasExclusive ? cleanFilters : [],
    isExclusive: hasExclusive
  };
});
function extractDebugCategories(message) {
  const categories = [];
  const mcpMatch = message.match(/^MCP server ["']([^"']+)["']/);
  if (mcpMatch && mcpMatch[1]) {
    categories.push("mcp");
    categories.push(mcpMatch[1].toLowerCase());
  } else {
    const prefixMatch = message.match(/^([^:[]+):/);
    if (prefixMatch && prefixMatch[1]) {
      categories.push(prefixMatch[1].trim().toLowerCase());
    }
  }
  const bracketMatch = message.match(/^\[([^\]]+)]/);
  if (bracketMatch && bracketMatch[1]) {
    categories.push(bracketMatch[1].trim().toLowerCase());
  }
  if (message.toLowerCase().includes("statsig event:")) {
    categories.push("statsig");
  }
  const secondaryMatch = message.match(/:\s*([^:]+?)(?:\s+(?:type|mode|status|event))?:/);
  if (secondaryMatch && secondaryMatch[1]) {
    const secondary = secondaryMatch[1].trim().toLowerCase();
    if (secondary.length < 30 && !secondary.includes(" ")) {
      categories.push(secondary);
    }
  }
  return Array.from(new Set(categories));
}
function shouldShowDebugCategories(categories, filter) {
  if (!filter) {
    return true;
  }
  if (categories.length === 0) {
    return false;
  }
  if (filter.isExclusive) {
    return !categories.some((cat) => filter.exclude.includes(cat));
  } else {
    return categories.some((cat) => filter.include.includes(cat));
  }
}
function shouldShowDebugMessage(message, filter) {
  if (!filter) {
    return true;
  }
  const categories = extractDebugCategories(message);
  return shouldShowDebugCategories(categories, filter);
}
function getClaudeConfigHomeDir() {
  var _a;
  return (_a = process.env.CLAUDE_CONFIG_DIR) != null ? _a : (0, import_path5.join)((0, import_os.homedir)(), ".claude");
}
function isEnvTruthy(envVar) {
  if (!envVar)
    return false;
  if (typeof envVar === "boolean")
    return envVar;
  const normalizedValue = envVar.toLowerCase().trim();
  return ["1", "true", "yes", "on"].includes(normalizedValue);
}
var MAX_OUTPUT_LENGTH = 15e4;
var DEFAULT_MAX_OUTPUT_LENGTH = 3e4;
function createMaxOutputLengthValidator(name) {
  return {
    name,
    default: DEFAULT_MAX_OUTPUT_LENGTH,
    validate: (value) => {
      if (!value) {
        return {
          effective: DEFAULT_MAX_OUTPUT_LENGTH,
          status: "valid"
        };
      }
      const parsed = parseInt(value, 10);
      if (isNaN(parsed) || parsed <= 0) {
        return {
          effective: DEFAULT_MAX_OUTPUT_LENGTH,
          status: "invalid",
          message: `Invalid value "${value}" (using default: ${DEFAULT_MAX_OUTPUT_LENGTH})`
        };
      }
      if (parsed > MAX_OUTPUT_LENGTH) {
        return {
          effective: MAX_OUTPUT_LENGTH,
          status: "capped",
          message: `Capped from ${parsed} to ${MAX_OUTPUT_LENGTH}`
        };
      }
      return { effective: parsed, status: "valid" };
    }
  };
}
var bashMaxOutputLengthValidator = createMaxOutputLengthValidator("BASH_MAX_OUTPUT_LENGTH");
var taskMaxOutputLengthValidator = createMaxOutputLengthValidator("TASK_MAX_OUTPUT_LENGTH");
var maxOutputTokensValidator = {
  name: "CLAUDE_CODE_MAX_OUTPUT_TOKENS",
  default: 32e3,
  validate: (value) => {
    const MAX_OUTPUT_TOKENS = 64e3;
    const DEFAULT_MAX_OUTPUT_TOKENS = 32e3;
    if (!value) {
      return { effective: DEFAULT_MAX_OUTPUT_TOKENS, status: "valid" };
    }
    const parsed = parseInt(value, 10);
    if (isNaN(parsed) || parsed <= 0) {
      return {
        effective: DEFAULT_MAX_OUTPUT_TOKENS,
        status: "invalid",
        message: `Invalid value "${value}" (using default: ${DEFAULT_MAX_OUTPUT_TOKENS})`
      };
    }
    if (parsed > MAX_OUTPUT_TOKENS) {
      return {
        effective: MAX_OUTPUT_TOKENS,
        status: "capped",
        message: `Capped from ${parsed} to ${MAX_OUTPUT_TOKENS}`
      };
    }
    return { effective: parsed, status: "valid" };
  }
};
function getInitialState() {
  let resolvedCwd = "";
  if (typeof process !== "undefined" && typeof process.cwd === "function") {
    resolvedCwd = (0, import_fs.realpathSync)((0, import_process.cwd)());
  }
  return {
    originalCwd: resolvedCwd,
    projectRoot: resolvedCwd,
    totalCostUSD: 0,
    totalAPIDuration: 0,
    totalAPIDurationWithoutRetries: 0,
    totalToolDuration: 0,
    startTime: Date.now(),
    lastInteractionTime: Date.now(),
    totalLinesAdded: 0,
    totalLinesRemoved: 0,
    hasUnknownModelCost: false,
    cwd: resolvedCwd,
    modelUsage: {},
    mainLoopModelOverride: void 0,
    initialMainLoopModel: null,
    modelStrings: null,
    isInteractive: false,
    clientType: "cli",
    sessionIngressToken: void 0,
    oauthTokenFromFd: void 0,
    apiKeyFromFd: void 0,
    flagSettingsPath: void 0,
    allowedSettingSources: [
      "userSettings",
      "projectSettings",
      "localSettings",
      "flagSettings",
      "policySettings"
    ],
    meter: null,
    sessionCounter: null,
    locCounter: null,
    prCounter: null,
    commitCounter: null,
    costCounter: null,
    tokenCounter: null,
    codeEditToolDecisionCounter: null,
    activeTimeCounter: null,
    sessionId: (0, import_crypto.randomUUID)(),
    loggerProvider: null,
    eventLogger: null,
    meterProvider: null,
    tracerProvider: null,
    agentColorMap: /* @__PURE__ */ new Map(),
    agentColorIndex: 0,
    envVarValidators: [bashMaxOutputLengthValidator, maxOutputTokensValidator],
    lastAPIRequest: null,
    inMemoryErrorLog: [],
    inlinePlugins: [],
    sessionBypassPermissionsMode: false,
    sessionTrustAccepted: false,
    sessionPersistenceDisabled: false,
    hasExitedPlanMode: false,
    needsPlanModeExitAttachment: false,
    hasExitedDelegateMode: false,
    needsDelegateModeExitAttachment: false,
    lspRecommendationShownThisSession: false,
    initJsonSchema: null,
    registeredHooks: null,
    planSlugCache: /* @__PURE__ */ new Map(),
    teleportedSessionInfo: null,
    invokedSkills: /* @__PURE__ */ new Map(),
    slowOperations: [],
    sdkBetas: void 0,
    mainThreadAgentType: void 0
  };
}
var STATE = getInitialState();
function getSessionId() {
  return STATE.sessionId;
}
function createBufferedWriter({
  writeFn,
  flushIntervalMs = 1e3,
  maxBufferSize = 100,
  immediateMode = false
}) {
  let buffer = [];
  let flushTimer = null;
  function clearTimer() {
    if (flushTimer) {
      clearTimeout(flushTimer);
      flushTimer = null;
    }
  }
  function flush() {
    if (buffer.length === 0)
      return;
    writeFn(buffer.join(""));
    buffer = [];
    clearTimer();
  }
  function scheduleFlush() {
    if (!flushTimer) {
      flushTimer = setTimeout(flush, flushIntervalMs);
    }
  }
  return {
    write(content) {
      if (immediateMode) {
        writeFn(content);
        return;
      }
      buffer.push(content);
      scheduleFlush();
      if (buffer.length >= maxBufferSize) {
        flush();
      }
    },
    flush,
    dispose() {
      flush();
    }
  };
}
var cleanupFunctions = /* @__PURE__ */ new Set();
function registerCleanup(cleanupFn) {
  cleanupFunctions.add(cleanupFn);
  return () => cleanupFunctions.delete(cleanupFn);
}
var SLOW_OPERATION_THRESHOLD_MS = Infinity;
function describeValue(value) {
  if (value === null)
    return "null";
  if (value === void 0)
    return "undefined";
  if (Array.isArray(value))
    return `Array[${value.length}]`;
  if (typeof value === "object") {
    const keys = Object.keys(value);
    return `Object{${keys.length} keys}`;
  }
  if (typeof value === "string")
    return `string(${value.length} chars)`;
  return typeof value;
}
function withSlowLogging(operation, fn) {
  const startTime = performance.now();
  try {
    return fn();
  } finally {
    const duration3 = performance.now() - startTime;
    if (duration3 > SLOW_OPERATION_THRESHOLD_MS && false) {
    }
  }
}
function jsonStringify(value, replacer, space) {
  const description = describeValue(value);
  return withSlowLogging(`JSON.stringify(${description})`, () => JSON.stringify(value, replacer, space));
}
var jsonParse = (text, reviver) => {
  const length = typeof text === "string" ? text.length : 0;
  return withSlowLogging(`JSON.parse(${length} chars)`, () => JSON.parse(text, reviver));
};
var isDebugMode = memoize_default(() => {
  return isEnvTruthy(process.env.DEBUG) || isEnvTruthy(process.env.DEBUG_SDK) || process.argv.includes("--debug") || process.argv.includes("-d") || isDebugToStdErr() || process.argv.some((arg) => arg.startsWith("--debug="));
});
var getDebugFilter = memoize_default(() => {
  const debugArg = process.argv.find((arg) => arg.startsWith("--debug="));
  if (!debugArg) {
    return null;
  }
  const filterPattern = debugArg.substring("--debug=".length);
  return parseDebugFilter(filterPattern);
});
var isDebugToStdErr = memoize_default(() => {
  return process.argv.includes("--debug-to-stderr") || process.argv.includes("-d2e");
});
function shouldLogDebugMessage(message) {
  if (false) {
  }
  if (typeof process === "undefined" || typeof process.versions === "undefined" || typeof process.versions.node === "undefined") {
    return false;
  }
  const filter = getDebugFilter();
  return shouldShowDebugMessage(message, filter);
}
var hasFormattedOutput = false;
var debugWriter = null;
function getDebugWriter() {
  if (!debugWriter) {
    debugWriter = createBufferedWriter({
      writeFn: (content) => {
        const path9 = getDebugLogPath();
        if (!getFsImplementation().existsSync((0, import_path6.dirname)(path9))) {
          getFsImplementation().mkdirSync((0, import_path6.dirname)(path9));
        }
        getFsImplementation().appendFileSync(path9, content);
        updateLatestDebugLogSymlink();
      },
      flushIntervalMs: 1e3,
      maxBufferSize: 100,
      immediateMode: isDebugMode()
    });
    registerCleanup(async () => debugWriter == null ? void 0 : debugWriter.dispose());
  }
  return debugWriter;
}
function logForDebugging2(message, { level } = {
  level: "debug"
}) {
  if (!shouldLogDebugMessage(message)) {
    return;
  }
  if (hasFormattedOutput && message.includes(`
`)) {
    message = jsonStringify(message);
  }
  const timestamp = (/* @__PURE__ */ new Date()).toISOString();
  const output = `${timestamp} [${level.toUpperCase()}] ${message.trim()}
`;
  if (isDebugToStdErr()) {
    writeToStderr(output);
    return;
  }
  getDebugWriter().write(output);
}
function getDebugLogPath() {
  var _a;
  return (_a = process.env.CLAUDE_CODE_DEBUG_LOGS_DIR) != null ? _a : (0, import_path6.join)(getClaudeConfigHomeDir(), "debug", `${getSessionId()}.txt`);
}
var updateLatestDebugLogSymlink = memoize_default(() => {
  if (process.argv[2] === "--ripgrep") {
    return;
  }
  try {
    const debugLogPath = getDebugLogPath();
    const debugLogsDir = (0, import_path6.dirname)(debugLogPath);
    const latestSymlinkPath = (0, import_path6.join)(debugLogsDir, "latest");
    if (!getFsImplementation().existsSync(debugLogsDir)) {
      getFsImplementation().mkdirSync(debugLogsDir);
    }
    if (getFsImplementation().existsSync(latestSymlinkPath)) {
      try {
        getFsImplementation().unlinkSync(latestSymlinkPath);
      } catch (e) {
      }
    }
    getFsImplementation().symlinkSync(debugLogPath, latestSymlinkPath);
  } catch (e) {
  }
});
var isLoggingSlowOperation = false;
function withSlowLogging2(operation, fn) {
  const startTime = performance.now();
  try {
    return fn();
  } finally {
    const duration3 = performance.now() - startTime;
    if (duration3 > SLOW_OPERATION_THRESHOLD_MS && !isLoggingSlowOperation && false) {
    }
  }
}
var NodeFsOperations = {
  cwd() {
    return process.cwd();
  },
  existsSync(fsPath) {
    return withSlowLogging2(`existsSync(${fsPath})`, () => fs5.existsSync(fsPath));
  },
  async stat(fsPath) {
    return (0, import_promises.stat)(fsPath);
  },
  statSync(fsPath) {
    return withSlowLogging2(`statSync(${fsPath})`, () => fs5.statSync(fsPath));
  },
  lstatSync(fsPath) {
    return withSlowLogging2(`lstatSync(${fsPath})`, () => fs5.lstatSync(fsPath));
  },
  readFileSync(fsPath, options) {
    return withSlowLogging2(`readFileSync(${fsPath})`, () => fs5.readFileSync(fsPath, { encoding: options.encoding }));
  },
  readFileBytesSync(fsPath) {
    return withSlowLogging2(`readFileBytesSync(${fsPath})`, () => fs5.readFileSync(fsPath));
  },
  readSync(fsPath, options) {
    return withSlowLogging2(`readSync(${fsPath}, ${options.length} bytes)`, () => {
      let fd = void 0;
      try {
        fd = fs5.openSync(fsPath, "r");
        const buffer = Buffer.alloc(options.length);
        const bytesRead = fs5.readSync(fd, buffer, 0, options.length, 0);
        return { buffer, bytesRead };
      } finally {
        if (fd)
          fs5.closeSync(fd);
      }
    });
  },
  appendFileSync(path9, data, options) {
    return withSlowLogging2(`appendFileSync(${path9}, ${data.length} chars)`, () => {
      if (!fs5.existsSync(path9) && (options == null ? void 0 : options.mode) !== void 0) {
        const fd = fs5.openSync(path9, "a", options.mode);
        try {
          fs5.appendFileSync(fd, data);
        } finally {
          fs5.closeSync(fd);
        }
      } else {
        fs5.appendFileSync(path9, data);
      }
    });
  },
  copyFileSync(src, dest) {
    return withSlowLogging2(`copyFileSync(${src} \u2192 ${dest})`, () => fs5.copyFileSync(src, dest));
  },
  unlinkSync(path9) {
    return withSlowLogging2(`unlinkSync(${path9})`, () => fs5.unlinkSync(path9));
  },
  renameSync(oldPath, newPath) {
    return withSlowLogging2(`renameSync(${oldPath} \u2192 ${newPath})`, () => fs5.renameSync(oldPath, newPath));
  },
  linkSync(target, path9) {
    return withSlowLogging2(`linkSync(${target} \u2192 ${path9})`, () => fs5.linkSync(target, path9));
  },
  symlinkSync(target, path9) {
    return withSlowLogging2(`symlinkSync(${target} \u2192 ${path9})`, () => fs5.symlinkSync(target, path9));
  },
  readlinkSync(path9) {
    return withSlowLogging2(`readlinkSync(${path9})`, () => fs5.readlinkSync(path9));
  },
  realpathSync(path9) {
    return withSlowLogging2(`realpathSync(${path9})`, () => fs5.realpathSync(path9));
  },
  mkdirSync(dirPath, options) {
    return withSlowLogging2(`mkdirSync(${dirPath})`, () => {
      if (!fs5.existsSync(dirPath)) {
        const mkdirOptions = {
          recursive: true
        };
        if ((options == null ? void 0 : options.mode) !== void 0) {
          mkdirOptions.mode = options.mode;
        }
        fs5.mkdirSync(dirPath, mkdirOptions);
      }
    });
  },
  readdirSync(dirPath) {
    return withSlowLogging2(`readdirSync(${dirPath})`, () => fs5.readdirSync(dirPath, { withFileTypes: true }));
  },
  readdirStringSync(dirPath) {
    return withSlowLogging2(`readdirStringSync(${dirPath})`, () => fs5.readdirSync(dirPath));
  },
  isDirEmptySync(dirPath) {
    return withSlowLogging2(`isDirEmptySync(${dirPath})`, () => {
      const files = this.readdirSync(dirPath);
      return files.length === 0;
    });
  },
  rmdirSync(dirPath) {
    return withSlowLogging2(`rmdirSync(${dirPath})`, () => fs5.rmdirSync(dirPath));
  },
  rmSync(path9, options) {
    return withSlowLogging2(`rmSync(${path9})`, () => fs5.rmSync(path9, options));
  },
  createWriteStream(path9) {
    return fs5.createWriteStream(path9);
  }
};
var activeFs = NodeFsOperations;
function getFsImplementation() {
  return activeFs;
}
var AbortError = class extends Error {
};
function isRunningWithBun() {
  return process.versions.bun !== void 0;
}
var debugFilePath = null;
var initialized = false;
function getOrCreateDebugFile() {
  if (initialized) {
    return debugFilePath;
  }
  initialized = true;
  if (!process.env.DEBUG_CLAUDE_AGENT_SDK) {
    return null;
  }
  const debugDir = (0, import_path7.join)(getClaudeConfigHomeDir(), "debug");
  debugFilePath = (0, import_path7.join)(debugDir, `sdk-${(0, import_crypto2.randomUUID)()}.txt`);
  if (!(0, import_fs2.existsSync)(debugDir)) {
    (0, import_fs2.mkdirSync)(debugDir, { recursive: true });
  }
  process.stderr.write(`SDK debug logs: ${debugFilePath}
`);
  return debugFilePath;
}
function logForSdkDebugging(message) {
  const path9 = getOrCreateDebugFile();
  if (!path9) {
    return;
  }
  const timestamp = (/* @__PURE__ */ new Date()).toISOString();
  const output = `${timestamp} ${message}
`;
  (0, import_fs2.appendFileSync)(path9, output);
}
function mergeSandboxIntoExtraArgs(extraArgs, sandbox) {
  const effectiveExtraArgs = { ...extraArgs };
  if (sandbox) {
    let settingsObj = { sandbox };
    if (effectiveExtraArgs.settings) {
      try {
        const existingSettings = jsonParse(effectiveExtraArgs.settings);
        settingsObj = { ...existingSettings, sandbox };
      } catch (e) {
      }
    }
    effectiveExtraArgs.settings = jsonStringify(settingsObj);
  }
  return effectiveExtraArgs;
}
var ProcessTransport = class {
  constructor(options) {
    __publicField(this, "options");
    __publicField(this, "process");
    __publicField(this, "processStdin");
    __publicField(this, "processStdout");
    __publicField(this, "ready", false);
    __publicField(this, "abortController");
    __publicField(this, "exitError");
    __publicField(this, "exitListeners", []);
    __publicField(this, "processExitHandler");
    __publicField(this, "abortHandler");
    this.options = options;
    this.abortController = options.abortController || createAbortController();
    this.initialize();
  }
  getDefaultExecutable() {
    return isRunningWithBun() ? "bun" : "node";
  }
  spawnLocalProcess(spawnOptions) {
    const { command, args, cwd: cwd2, env, signal } = spawnOptions;
    const stderrMode = env.DEBUG_CLAUDE_AGENT_SDK || this.options.stderr ? "pipe" : "ignore";
    const childProcess = (0, import_child_process2.spawn)(command, args, {
      cwd: cwd2,
      stdio: ["pipe", "pipe", stderrMode],
      signal,
      env,
      windowsHide: true
    });
    if (env.DEBUG_CLAUDE_AGENT_SDK || this.options.stderr) {
      childProcess.stderr.on("data", (data) => {
        const message = data.toString();
        logForSdkDebugging(message);
        if (this.options.stderr) {
          this.options.stderr(message);
        }
      });
    }
    const mappedProcess = {
      stdin: childProcess.stdin,
      stdout: childProcess.stdout,
      get killed() {
        return childProcess.killed;
      },
      get exitCode() {
        return childProcess.exitCode;
      },
      kill: childProcess.kill.bind(childProcess),
      on: childProcess.on.bind(childProcess),
      once: childProcess.once.bind(childProcess),
      off: childProcess.off.bind(childProcess)
    };
    return mappedProcess;
  }
  initialize() {
    try {
      const {
        additionalDirectories = [],
        betas,
        cwd: cwd2,
        executable = this.getDefaultExecutable(),
        executableArgs = [],
        extraArgs = {},
        pathToClaudeCodeExecutable,
        env = { ...process.env },
        maxThinkingTokens,
        maxTurns,
        maxBudgetUsd,
        model,
        fallbackModel,
        jsonSchema,
        permissionMode,
        allowDangerouslySkipPermissions,
        permissionPromptToolName,
        continueConversation,
        resume,
        settingSources,
        allowedTools = [],
        disallowedTools = [],
        tools,
        mcpServers,
        strictMcpConfig,
        canUseTool,
        includePartialMessages,
        plugins,
        sandbox
      } = this.options;
      const args = [
        "--output-format",
        "stream-json",
        "--verbose",
        "--input-format",
        "stream-json"
      ];
      if (maxThinkingTokens !== void 0) {
        args.push("--max-thinking-tokens", maxThinkingTokens.toString());
      }
      if (maxTurns)
        args.push("--max-turns", maxTurns.toString());
      if (maxBudgetUsd !== void 0) {
        args.push("--max-budget-usd", maxBudgetUsd.toString());
      }
      if (model)
        args.push("--model", model);
      if (betas && betas.length > 0) {
        args.push("--betas", betas.join(","));
      }
      if (jsonSchema) {
        args.push("--json-schema", jsonStringify(jsonSchema));
      }
      if (env.DEBUG_CLAUDE_AGENT_SDK) {
        args.push("--debug-to-stderr");
      }
      if (canUseTool) {
        if (permissionPromptToolName) {
          throw new Error("canUseTool callback cannot be used with permissionPromptToolName. Please use one or the other.");
        }
        args.push("--permission-prompt-tool", "stdio");
      } else if (permissionPromptToolName) {
        args.push("--permission-prompt-tool", permissionPromptToolName);
      }
      if (continueConversation)
        args.push("--continue");
      if (resume)
        args.push("--resume", resume);
      if (allowedTools.length > 0) {
        args.push("--allowedTools", allowedTools.join(","));
      }
      if (disallowedTools.length > 0) {
        args.push("--disallowedTools", disallowedTools.join(","));
      }
      if (tools !== void 0) {
        if (Array.isArray(tools)) {
          if (tools.length === 0) {
            args.push("--tools", "");
          } else {
            args.push("--tools", tools.join(","));
          }
        } else {
          args.push("--tools", "default");
        }
      }
      if (mcpServers && Object.keys(mcpServers).length > 0) {
        args.push("--mcp-config", jsonStringify({ mcpServers }));
      }
      if (settingSources) {
        args.push("--setting-sources", settingSources.join(","));
      }
      if (strictMcpConfig) {
        args.push("--strict-mcp-config");
      }
      if (permissionMode) {
        args.push("--permission-mode", permissionMode);
      }
      if (allowDangerouslySkipPermissions) {
        args.push("--allow-dangerously-skip-permissions");
      }
      if (fallbackModel) {
        if (model && fallbackModel === model) {
          throw new Error("Fallback model cannot be the same as the main model. Please specify a different model for fallbackModel option.");
        }
        args.push("--fallback-model", fallbackModel);
      }
      if (includePartialMessages) {
        args.push("--include-partial-messages");
      }
      for (const dir of additionalDirectories) {
        args.push("--add-dir", dir);
      }
      if (plugins && plugins.length > 0) {
        for (const plugin of plugins) {
          if (plugin.type === "local") {
            args.push("--plugin-dir", plugin.path);
          } else {
            throw new Error(`Unsupported plugin type: ${plugin.type}`);
          }
        }
      }
      if (this.options.forkSession) {
        args.push("--fork-session");
      }
      if (this.options.resumeSessionAt) {
        args.push("--resume-session-at", this.options.resumeSessionAt);
      }
      if (this.options.persistSession === false) {
        args.push("--no-session-persistence");
      }
      const effectiveExtraArgs = mergeSandboxIntoExtraArgs(extraArgs != null ? extraArgs : {}, sandbox);
      for (const [flag, value] of Object.entries(effectiveExtraArgs)) {
        if (value === null) {
          args.push(`--${flag}`);
        } else {
          args.push(`--${flag}`, value);
        }
      }
      if (!env.CLAUDE_CODE_ENTRYPOINT) {
        env.CLAUDE_CODE_ENTRYPOINT = "sdk-ts";
      }
      delete env.NODE_OPTIONS;
      if (env.DEBUG_CLAUDE_AGENT_SDK) {
        env.DEBUG = "1";
      } else {
        delete env.DEBUG;
      }
      const isNative = isNativeBinary(pathToClaudeCodeExecutable);
      const spawnCommand = isNative ? pathToClaudeCodeExecutable : executable;
      const spawnArgs = isNative ? [...executableArgs, ...args] : [...executableArgs, pathToClaudeCodeExecutable, ...args];
      const spawnOptions = {
        command: spawnCommand,
        args: spawnArgs,
        cwd: cwd2,
        env,
        signal: this.abortController.signal
      };
      if (this.options.spawnClaudeCodeProcess) {
        logForSdkDebugging(`Spawning Claude Code (custom): ${spawnCommand} ${spawnArgs.join(" ")}`);
        this.process = this.options.spawnClaudeCodeProcess(spawnOptions);
      } else {
        const fs22 = getFsImplementation();
        if (!fs22.existsSync(pathToClaudeCodeExecutable)) {
          const errorMessage = isNative ? `Claude Code native binary not found at ${pathToClaudeCodeExecutable}. Please ensure Claude Code is installed via native installer or specify a valid path with options.pathToClaudeCodeExecutable.` : `Claude Code executable not found at ${pathToClaudeCodeExecutable}. Is options.pathToClaudeCodeExecutable set?`;
          throw new ReferenceError(errorMessage);
        }
        logForSdkDebugging(`Spawning Claude Code: ${spawnCommand} ${spawnArgs.join(" ")}`);
        this.process = this.spawnLocalProcess(spawnOptions);
      }
      this.processStdin = this.process.stdin;
      this.processStdout = this.process.stdout;
      const cleanup = () => {
        if (this.process && !this.process.killed) {
          this.process.kill("SIGTERM");
        }
      };
      this.processExitHandler = cleanup;
      this.abortHandler = cleanup;
      process.on("exit", this.processExitHandler);
      this.abortController.signal.addEventListener("abort", this.abortHandler);
      this.process.on("error", (error2) => {
        this.ready = false;
        if (this.abortController.signal.aborted) {
          this.exitError = new AbortError("Claude Code process aborted by user");
        } else {
          this.exitError = new Error(`Failed to spawn Claude Code process: ${error2.message}`);
          logForSdkDebugging(this.exitError.message);
        }
      });
      this.process.on("exit", (code, signal) => {
        this.ready = false;
        if (this.abortController.signal.aborted) {
          this.exitError = new AbortError("Claude Code process aborted by user");
        } else {
          const error2 = this.getProcessExitError(code, signal);
          if (error2) {
            this.exitError = error2;
            logForSdkDebugging(error2.message);
          }
        }
      });
      this.ready = true;
    } catch (error2) {
      this.ready = false;
      throw error2;
    }
  }
  getProcessExitError(code, signal) {
    if (code !== 0 && code !== null) {
      return new Error(`Claude Code process exited with code ${code}`);
    } else if (signal) {
      return new Error(`Claude Code process terminated by signal ${signal}`);
    }
    return;
  }
  write(data) {
    var _a, _b;
    if (this.abortController.signal.aborted) {
      throw new AbortError("Operation aborted");
    }
    if (!this.ready || !this.processStdin) {
      throw new Error("ProcessTransport is not ready for writing");
    }
    if (((_a = this.process) == null ? void 0 : _a.killed) || ((_b = this.process) == null ? void 0 : _b.exitCode) !== null) {
      throw new Error("Cannot write to terminated process");
    }
    if (this.exitError) {
      throw new Error(`Cannot write to process that exited with error: ${this.exitError.message}`);
    }
    logForSdkDebugging(`[ProcessTransport] Writing to stdin: ${data.substring(0, 100)}`);
    try {
      const written = this.processStdin.write(data);
      if (!written) {
        logForSdkDebugging("[ProcessTransport] Write buffer full, data queued");
      }
    } catch (error2) {
      this.ready = false;
      throw new Error(`Failed to write to process stdin: ${error2.message}`);
    }
  }
  close() {
    var _a;
    if (this.processStdin) {
      this.processStdin.end();
      this.processStdin = void 0;
    }
    if (this.abortHandler) {
      this.abortController.signal.removeEventListener("abort", this.abortHandler);
      this.abortHandler = void 0;
    }
    for (const { handler } of this.exitListeners) {
      (_a = this.process) == null ? void 0 : _a.off("exit", handler);
    }
    this.exitListeners = [];
    if (this.process && !this.process.killed) {
      this.process.kill("SIGTERM");
      setTimeout(() => {
        if (this.process && !this.process.killed) {
          this.process.kill("SIGKILL");
        }
      }, 5e3);
    }
    this.ready = false;
    if (this.processExitHandler) {
      process.off("exit", this.processExitHandler);
      this.processExitHandler = void 0;
    }
  }
  isReady() {
    return this.ready;
  }
  async *readMessages() {
    if (!this.processStdout) {
      throw new Error("ProcessTransport output stream not available");
    }
    const rl = (0, import_readline.createInterface)({ input: this.processStdout });
    try {
      for await (const line of rl) {
        if (line.trim()) {
          const message = jsonParse(line);
          yield message;
        }
      }
      await this.waitForExit();
    } catch (error2) {
      throw error2;
    } finally {
      rl.close();
    }
  }
  endInput() {
    if (this.processStdin) {
      this.processStdin.end();
    }
  }
  getInputStream() {
    return this.processStdin;
  }
  onExit(callback) {
    if (!this.process)
      return () => {
      };
    const handler = (code, signal) => {
      const error2 = this.getProcessExitError(code, signal);
      callback(error2);
    };
    this.process.on("exit", handler);
    this.exitListeners.push({ callback, handler });
    return () => {
      if (this.process) {
        this.process.off("exit", handler);
      }
      const index = this.exitListeners.findIndex((l) => l.handler === handler);
      if (index !== -1) {
        this.exitListeners.splice(index, 1);
      }
    };
  }
  async waitForExit() {
    if (!this.process) {
      if (this.exitError) {
        throw this.exitError;
      }
      return;
    }
    if (this.process.exitCode !== null || this.process.killed) {
      if (this.exitError) {
        throw this.exitError;
      }
      return;
    }
    return new Promise((resolve3, reject) => {
      const exitHandler = (code, signal) => {
        if (this.abortController.signal.aborted) {
          reject(new AbortError("Operation aborted"));
          return;
        }
        const error2 = this.getProcessExitError(code, signal);
        if (error2) {
          reject(error2);
        } else {
          resolve3();
        }
      };
      this.process.once("exit", exitHandler);
      const errorHandler = (error2) => {
        this.process.off("exit", exitHandler);
        reject(error2);
      };
      this.process.once("error", errorHandler);
      this.process.once("exit", () => {
        this.process.off("error", errorHandler);
      });
    });
  }
};
function isNativeBinary(executablePath) {
  const jsExtensions = [".js", ".mjs", ".tsx", ".ts", ".jsx"];
  return !jsExtensions.some((ext) => executablePath.endsWith(ext));
}
var Stream = class {
  constructor(returned) {
    __publicField(this, "returned");
    __publicField(this, "queue", []);
    __publicField(this, "readResolve");
    __publicField(this, "readReject");
    __publicField(this, "isDone", false);
    __publicField(this, "hasError");
    __publicField(this, "started", false);
    this.returned = returned;
  }
  [Symbol.asyncIterator]() {
    if (this.started) {
      throw new Error("Stream can only be iterated once");
    }
    this.started = true;
    return this;
  }
  next() {
    if (this.queue.length > 0) {
      return Promise.resolve({
        done: false,
        value: this.queue.shift()
      });
    }
    if (this.isDone) {
      return Promise.resolve({ done: true, value: void 0 });
    }
    if (this.hasError) {
      return Promise.reject(this.hasError);
    }
    return new Promise((resolve3, reject) => {
      this.readResolve = resolve3;
      this.readReject = reject;
    });
  }
  enqueue(value) {
    if (this.readResolve) {
      const resolve3 = this.readResolve;
      this.readResolve = void 0;
      this.readReject = void 0;
      resolve3({ done: false, value });
    } else {
      this.queue.push(value);
    }
  }
  done() {
    this.isDone = true;
    if (this.readResolve) {
      const resolve3 = this.readResolve;
      this.readResolve = void 0;
      this.readReject = void 0;
      resolve3({ done: true, value: void 0 });
    }
  }
  error(error2) {
    this.hasError = error2;
    if (this.readReject) {
      const reject = this.readReject;
      this.readResolve = void 0;
      this.readReject = void 0;
      reject(error2);
    }
  }
  return() {
    this.isDone = true;
    if (this.returned) {
      this.returned();
    }
    return Promise.resolve({ done: true, value: void 0 });
  }
};
var SdkControlServerTransport = class {
  constructor(sendMcpMessage) {
    __publicField(this, "sendMcpMessage");
    __publicField(this, "isClosed", false);
    __publicField(this, "onclose");
    __publicField(this, "onerror");
    __publicField(this, "onmessage");
    this.sendMcpMessage = sendMcpMessage;
  }
  async start() {
  }
  async send(message) {
    if (this.isClosed) {
      throw new Error("Transport is closed");
    }
    this.sendMcpMessage(message);
  }
  async close() {
    var _a;
    if (this.isClosed) {
      return;
    }
    this.isClosed = true;
    (_a = this.onclose) == null ? void 0 : _a.call(this);
  }
};
var Query = class {
  constructor(transport, isSingleUserTurn, canUseTool, hooks, abortController, sdkMcpServers = /* @__PURE__ */ new Map(), jsonSchema, initConfig) {
    __publicField(this, "transport");
    __publicField(this, "isSingleUserTurn");
    __publicField(this, "canUseTool");
    __publicField(this, "hooks");
    __publicField(this, "abortController");
    __publicField(this, "jsonSchema");
    __publicField(this, "initConfig");
    __publicField(this, "pendingControlResponses", /* @__PURE__ */ new Map());
    __publicField(this, "cleanupPerformed", false);
    __publicField(this, "sdkMessages");
    __publicField(this, "inputStream", new Stream());
    __publicField(this, "initialization");
    __publicField(this, "cancelControllers", /* @__PURE__ */ new Map());
    __publicField(this, "hookCallbacks", /* @__PURE__ */ new Map());
    __publicField(this, "nextCallbackId", 0);
    __publicField(this, "sdkMcpTransports", /* @__PURE__ */ new Map());
    __publicField(this, "sdkMcpServerInstances", /* @__PURE__ */ new Map());
    __publicField(this, "pendingMcpResponses", /* @__PURE__ */ new Map());
    __publicField(this, "firstResultReceivedResolve");
    __publicField(this, "firstResultReceived", false);
    this.transport = transport;
    this.isSingleUserTurn = isSingleUserTurn;
    this.canUseTool = canUseTool;
    this.hooks = hooks;
    this.abortController = abortController;
    this.jsonSchema = jsonSchema;
    this.initConfig = initConfig;
    for (const [name, server] of sdkMcpServers) {
      this.connectSdkMcpServer(name, server);
    }
    this.sdkMessages = this.readSdkMessages();
    this.readMessages();
    this.initialization = this.initialize();
    this.initialization.catch(() => {
    });
  }
  hasBidirectionalNeeds() {
    return this.sdkMcpTransports.size > 0 || this.hooks !== void 0 && Object.keys(this.hooks).length > 0 || this.canUseTool !== void 0;
  }
  setError(error2) {
    this.inputStream.error(error2);
  }
  cleanup(error2) {
    if (this.cleanupPerformed)
      return;
    this.cleanupPerformed = true;
    try {
      this.transport.close();
      this.pendingControlResponses.clear();
      this.pendingMcpResponses.clear();
      this.cancelControllers.clear();
      this.hookCallbacks.clear();
      for (const transport of this.sdkMcpTransports.values()) {
        try {
          transport.close();
        } catch (e) {
        }
      }
      this.sdkMcpTransports.clear();
      if (error2) {
        this.inputStream.error(error2);
      } else {
        this.inputStream.done();
      }
    } catch (_error) {
    }
  }
  next(...[value]) {
    return this.sdkMessages.next(...[value]);
  }
  return(value) {
    return this.sdkMessages.return(value);
  }
  throw(e) {
    return this.sdkMessages.throw(e);
  }
  [Symbol.asyncIterator]() {
    return this.sdkMessages;
  }
  [Symbol.asyncDispose]() {
    return this.sdkMessages[Symbol.asyncDispose]();
  }
  async readMessages() {
    try {
      for await (const message of this.transport.readMessages()) {
        if (message.type === "control_response") {
          const handler = this.pendingControlResponses.get(message.response.request_id);
          if (handler) {
            handler(message.response);
          }
          continue;
        } else if (message.type === "control_request") {
          this.handleControlRequest(message);
          continue;
        } else if (message.type === "control_cancel_request") {
          this.handleControlCancelRequest(message);
          continue;
        } else if (message.type === "keep_alive") {
          continue;
        }
        if (message.type === "result") {
          this.firstResultReceived = true;
          if (this.firstResultReceivedResolve) {
            this.firstResultReceivedResolve();
          }
          if (this.isSingleUserTurn) {
            logForDebugging2(`[Query.readMessages] First result received for single-turn query, closing stdin`);
            this.transport.endInput();
          }
        }
        this.inputStream.enqueue(message);
      }
      if (this.firstResultReceivedResolve) {
        this.firstResultReceivedResolve();
      }
      this.inputStream.done();
      this.cleanup();
    } catch (error2) {
      if (this.firstResultReceivedResolve) {
        this.firstResultReceivedResolve();
      }
      this.inputStream.error(error2);
      this.cleanup(error2);
    }
  }
  async handleControlRequest(request) {
    const controller = new AbortController();
    this.cancelControllers.set(request.request_id, controller);
    try {
      const response = await this.processControlRequest(request, controller.signal);
      const controlResponse = {
        type: "control_response",
        response: {
          subtype: "success",
          request_id: request.request_id,
          response
        }
      };
      await Promise.resolve(this.transport.write(jsonStringify(controlResponse) + `
`));
    } catch (error2) {
      const controlErrorResponse = {
        type: "control_response",
        response: {
          subtype: "error",
          request_id: request.request_id,
          error: error2.message || String(error2)
        }
      };
      await Promise.resolve(this.transport.write(jsonStringify(controlErrorResponse) + `
`));
    } finally {
      this.cancelControllers.delete(request.request_id);
    }
  }
  handleControlCancelRequest(request) {
    const controller = this.cancelControllers.get(request.request_id);
    if (controller) {
      controller.abort();
      this.cancelControllers.delete(request.request_id);
    }
  }
  async processControlRequest(request, signal) {
    if (request.request.subtype === "can_use_tool") {
      if (!this.canUseTool) {
        throw new Error("canUseTool callback is not provided.");
      }
      const result = await this.canUseTool(request.request.tool_name, request.request.input, {
        signal,
        suggestions: request.request.permission_suggestions,
        blockedPath: request.request.blocked_path,
        decisionReason: request.request.decision_reason,
        toolUseID: request.request.tool_use_id,
        agentID: request.request.agent_id
      });
      return {
        ...result,
        toolUseID: request.request.tool_use_id
      };
    } else if (request.request.subtype === "hook_callback") {
      const result = await this.handleHookCallbacks(request.request.callback_id, request.request.input, request.request.tool_use_id, signal);
      return result;
    } else if (request.request.subtype === "mcp_message") {
      const mcpRequest = request.request;
      const transport = this.sdkMcpTransports.get(mcpRequest.server_name);
      if (!transport) {
        throw new Error(`SDK MCP server not found: ${mcpRequest.server_name}`);
      }
      if ("method" in mcpRequest.message && "id" in mcpRequest.message && mcpRequest.message.id !== null) {
        const response = await this.handleMcpControlRequest(mcpRequest.server_name, mcpRequest, transport);
        return { mcp_response: response };
      } else {
        if (transport.onmessage) {
          transport.onmessage(mcpRequest.message);
        }
        return { mcp_response: { jsonrpc: "2.0", result: {}, id: 0 } };
      }
    }
    throw new Error("Unsupported control request subtype: " + request.request.subtype);
  }
  async *readSdkMessages() {
    for await (const message of this.inputStream) {
      yield message;
    }
  }
  async initialize() {
    var _a, _b, _c;
    let hooks;
    if (this.hooks) {
      hooks = {};
      for (const [event, matchers] of Object.entries(this.hooks)) {
        if (matchers.length > 0) {
          hooks[event] = matchers.map((matcher) => {
            const callbackIds = [];
            for (const callback of matcher.hooks) {
              const callbackId = `hook_${this.nextCallbackId++}`;
              this.hookCallbacks.set(callbackId, callback);
              callbackIds.push(callbackId);
            }
            return {
              matcher: matcher.matcher,
              hookCallbackIds: callbackIds,
              timeout: matcher.timeout
            };
          });
        }
      }
    }
    const sdkMcpServers = this.sdkMcpTransports.size > 0 ? Array.from(this.sdkMcpTransports.keys()) : void 0;
    const initRequest = {
      subtype: "initialize",
      hooks,
      sdkMcpServers,
      jsonSchema: this.jsonSchema,
      systemPrompt: (_a = this.initConfig) == null ? void 0 : _a.systemPrompt,
      appendSystemPrompt: (_b = this.initConfig) == null ? void 0 : _b.appendSystemPrompt,
      agents: (_c = this.initConfig) == null ? void 0 : _c.agents
    };
    const response = await this.request(initRequest);
    return response.response;
  }
  async interrupt() {
    await this.request({
      subtype: "interrupt"
    });
  }
  async setPermissionMode(mode) {
    await this.request({
      subtype: "set_permission_mode",
      mode
    });
  }
  async setModel(model) {
    await this.request({
      subtype: "set_model",
      model
    });
  }
  async setMaxThinkingTokens(maxThinkingTokens) {
    await this.request({
      subtype: "set_max_thinking_tokens",
      max_thinking_tokens: maxThinkingTokens
    });
  }
  async rewindFiles(userMessageId, options) {
    const response = await this.request({
      subtype: "rewind_files",
      user_message_id: userMessageId,
      dry_run: options == null ? void 0 : options.dryRun
    });
    return response.response;
  }
  async processPendingPermissionRequests(pendingPermissionRequests) {
    for (const request of pendingPermissionRequests) {
      if (request.request.subtype === "can_use_tool") {
        this.handleControlRequest(request).catch(() => {
        });
      }
    }
  }
  request(request) {
    const requestId = Math.random().toString(36).substring(2, 15);
    const sdkRequest = {
      request_id: requestId,
      type: "control_request",
      request
    };
    return new Promise((resolve3, reject) => {
      this.pendingControlResponses.set(requestId, (response) => {
        if (response.subtype === "success") {
          resolve3(response);
        } else {
          reject(new Error(response.error));
          if (response.pending_permission_requests) {
            this.processPendingPermissionRequests(response.pending_permission_requests);
          }
        }
      });
      Promise.resolve(this.transport.write(jsonStringify(sdkRequest) + `
`));
    });
  }
  async supportedCommands() {
    return (await this.initialization).commands;
  }
  async supportedModels() {
    return (await this.initialization).models;
  }
  async mcpServerStatus() {
    const response = await this.request({
      subtype: "mcp_status"
    });
    const mcpStatusResponse = response.response;
    return mcpStatusResponse.mcpServers;
  }
  async setMcpServers(servers) {
    const sdkServers = {};
    const processServers = {};
    for (const [name, config2] of Object.entries(servers)) {
      if (config2.type === "sdk" && "instance" in config2) {
        sdkServers[name] = config2.instance;
      } else {
        processServers[name] = config2;
      }
    }
    const currentSdkNames = new Set(this.sdkMcpServerInstances.keys());
    const newSdkNames = new Set(Object.keys(sdkServers));
    for (const name of currentSdkNames) {
      if (!newSdkNames.has(name)) {
        await this.disconnectSdkMcpServer(name);
      }
    }
    for (const [name, server] of Object.entries(sdkServers)) {
      if (!currentSdkNames.has(name)) {
        this.connectSdkMcpServer(name, server);
      }
    }
    const sdkServerConfigs = {};
    for (const name of Object.keys(sdkServers)) {
      sdkServerConfigs[name] = { type: "sdk", name };
    }
    const response = await this.request({
      subtype: "mcp_set_servers",
      servers: { ...processServers, ...sdkServerConfigs }
    });
    return response.response;
  }
  async accountInfo() {
    return (await this.initialization).account;
  }
  async streamInput(stream) {
    var _a;
    logForDebugging2(`[Query.streamInput] Starting to process input stream`);
    try {
      let messageCount = 0;
      for await (const message of stream) {
        messageCount++;
        logForDebugging2(`[Query.streamInput] Processing message ${messageCount}: ${message.type}`);
        if ((_a = this.abortController) == null ? void 0 : _a.signal.aborted)
          break;
        await Promise.resolve(this.transport.write(jsonStringify(message) + `
`));
      }
      logForDebugging2(`[Query.streamInput] Finished processing ${messageCount} messages from input stream`);
      if (messageCount > 0 && this.hasBidirectionalNeeds()) {
        logForDebugging2(`[Query.streamInput] Has bidirectional needs, waiting for first result`);
        await this.waitForFirstResult();
      }
      logForDebugging2(`[Query] Calling transport.endInput() to close stdin to CLI process`);
      this.transport.endInput();
    } catch (error2) {
      if (!(error2 instanceof AbortError)) {
        throw error2;
      }
    }
  }
  waitForFirstResult() {
    if (this.firstResultReceived) {
      logForDebugging2(`[Query.waitForFirstResult] Result already received, returning immediately`);
      return Promise.resolve();
    }
    return new Promise((resolve3) => {
      var _a, _b;
      if ((_a = this.abortController) == null ? void 0 : _a.signal.aborted) {
        resolve3();
        return;
      }
      (_b = this.abortController) == null ? void 0 : _b.signal.addEventListener("abort", () => resolve3(), {
        once: true
      });
      this.firstResultReceivedResolve = resolve3;
    });
  }
  handleHookCallbacks(callbackId, input, toolUseID, abortSignal) {
    const callback = this.hookCallbacks.get(callbackId);
    if (!callback) {
      throw new Error(`No hook callback found for ID: ${callbackId}`);
    }
    return callback(input, toolUseID, {
      signal: abortSignal
    });
  }
  connectSdkMcpServer(name, server) {
    const sdkTransport = new SdkControlServerTransport((message) => this.sendMcpServerMessageToCli(name, message));
    this.sdkMcpTransports.set(name, sdkTransport);
    this.sdkMcpServerInstances.set(name, server);
    server.connect(sdkTransport);
  }
  async disconnectSdkMcpServer(name) {
    const transport = this.sdkMcpTransports.get(name);
    if (transport) {
      await transport.close();
      this.sdkMcpTransports.delete(name);
    }
    this.sdkMcpServerInstances.delete(name);
  }
  sendMcpServerMessageToCli(serverName, message) {
    if ("id" in message && message.id !== null && message.id !== void 0) {
      const key = `${serverName}:${message.id}`;
      const pending = this.pendingMcpResponses.get(key);
      if (pending) {
        pending.resolve(message);
        this.pendingMcpResponses.delete(key);
        return;
      }
    }
    const controlRequest = {
      type: "control_request",
      request_id: (0, import_crypto3.randomUUID)(),
      request: {
        subtype: "mcp_message",
        server_name: serverName,
        message
      }
    };
    this.transport.write(jsonStringify(controlRequest) + `
`);
  }
  handleMcpControlRequest(serverName, mcpRequest, transport) {
    const messageId = "id" in mcpRequest.message ? mcpRequest.message.id : null;
    const key = `${serverName}:${messageId}`;
    return new Promise((resolve3, reject) => {
      const cleanup = () => {
        this.pendingMcpResponses.delete(key);
      };
      const resolveAndCleanup = (response) => {
        cleanup();
        resolve3(response);
      };
      const rejectAndCleanup = (error2) => {
        cleanup();
        reject(error2);
      };
      this.pendingMcpResponses.set(key, {
        resolve: resolveAndCleanup,
        reject: rejectAndCleanup
      });
      if (transport.onmessage) {
        transport.onmessage(mcpRequest.message);
      } else {
        cleanup();
        reject(new Error("No message handler registered"));
        return;
      }
    });
  }
};
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs2(_arg) {
  }
  util2.assertIs = assertIs2;
  function assertNever2(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever2;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues2(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues2;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var ZodError = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue2) {
      return issue2.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error2) => {
      for (const issue2 of error2.issues) {
        if (issue2.code === "invalid_union") {
          issue2.unionErrors.map(processError);
        } else if (issue2.code === "invalid_return_type") {
          processError(issue2.returnTypeError);
        } else if (issue2.code === "invalid_arguments") {
          processError(issue2.argumentsError);
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error2 = new ZodError(issues);
  return error2;
};
var errorMap = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode.invalid_type:
      if (issue2.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue2);
  }
  return { message };
};
var en_default = errorMap;
var overrideErrorMap = en_default;
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path: path9, errorMaps, issueData } = params;
  const fullPath = [...path9, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue2 = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === en_default ? void 0 : en_default
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue2);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message == null ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  constructor(parent, value, path9, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path9;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error2 = new ZodError(ctx.common.issues);
        this._error = error2;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message != null ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message != null ? message : required_error) != null ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message != null ? message : invalid_type_error) != null ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params == null ? void 0 : params.async) != null ? _a : false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err == null ? void 0 : err.message) == null ? void 0 : _a.toLowerCase()) == null ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check2, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check2(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check2, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check2(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base642));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && (decoded == null ? void 0 : decoded.typ) !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (e) {
    return false;
  }
}
function isValidCidr(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString2 extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType2 = this._getType(input);
    if (parsedType2 !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.length < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.length > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "length") {
        const tooBig = input.data.length > check2.value;
        const tooSmall = input.data.length < check2.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          }
          status.dirty();
        }
      } else if (check2.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "url") {
        try {
          new URL(input.data);
        } catch (e) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "regex") {
        check2.regex.lastIndex = 0;
        const testResult = check2.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "trim") {
        input.data = input.data.trim();
      } else if (check2.kind === "includes") {
        if (!input.data.includes(check2.value, check2.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check2.value, position: check2.position },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check2.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check2.kind === "startsWith") {
        if (!input.data.startsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "endsWith") {
        if (!input.data.endsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "datetime") {
        const regex = datetimeRegex(check2);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "time") {
        const regex = timeRegex(check2);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ip") {
        if (!isValidIP(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "jwt") {
        if (!isValidJWT(input.data, check2.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cidr") {
        if (!isValidCidr(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check2) {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (_a = options == null ? void 0 : options.offset) != null ? _a : false,
      local: (_b = options == null ? void 0 : options.local) != null ? _b : false,
      ...errorUtil.errToObj(options == null ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      ...errorUtil.errToObj(options == null ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position,
      ...errorUtil.errToObj(options == null ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params == null ? void 0 : params.coerce) != null ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType2 = this._getType(input);
    if (parsedType2 !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check2 of this._def.checks) {
      if (check2.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check2.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (e) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType2 = this._getType(input);
    if (parsedType2 !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (input.data % check2.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params == null ? void 0 : params.coerce) != null ? _a : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType2 = this._getType(input);
    if (parsedType2 !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType2 = this._getType(input);
    if (parsedType2 !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.getTime() < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check2.message,
            inclusive: true,
            exact: false,
            minimum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.getTime() > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check2.message,
            inclusive: true,
            exact: false,
            maximum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check2) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType2 = this._getType(input);
    if (parsedType2 !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType2 = this._getType(input);
    if (parsedType2 !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType2 = this._getType(input);
    if (parsedType2 !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType2 = this._getType(input);
    if (parsedType2 !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType2 = this._getType(input);
    if (parsedType2 !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue2, ctx).message) != null ? _c : ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) != null ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error2) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error2
        }
      });
    }
    function makeReturnsIssue(returns, error2) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error2
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error2 = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error2.addIssue(makeArgsIssue(args, e));
          throw error2;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error2.addIssue(makeReturnsIssue(result, e));
          throw error2;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess2, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess2 },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType2 = this._getType(input);
    if (parsedType2 === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType2 = this._getType(input);
    if (parsedType2 === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType2 = this._getType(input);
    if (parsedType2 !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var NEVER = Object.freeze({
  status: "aborted"
});
function $constructor(name, initializer3, params) {
  var _a;
  function init(inst, def) {
    var _a3, _b;
    var _a2;
    Object.defineProperty(inst, "_zod", {
      value: (_a3 = inst._zod) != null ? _a3 : {},
      enumerable: false
    });
    (_b = (_a2 = inst._zod).traits) != null ? _b : _a2.traits = /* @__PURE__ */ new Set();
    inst._zod.traits.add(name);
    initializer3(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  const Parent = (_a = params == null ? void 0 : params.Parent) != null ? _a : Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a3;
    var _a2;
    const inst = (params == null ? void 0 : params.Parent) ? new Definition() : this;
    init(inst, def);
    (_a3 = (_a2 = inst._zod).deferred) != null ? _a3 : _a2.deferred = [];
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      var _a2, _b;
      if ((params == null ? void 0 : params.Parent) && inst instanceof params.Parent)
        return true;
      return (_b = (_a2 = inst == null ? void 0 : inst._zod) == null ? void 0 : _a2.traits) == null ? void 0 : _b.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
var $ZodAsyncError = class extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
var exports_util = {};
__export2(exports_util, {
  unwrapMessage: () => unwrapMessage,
  stringifyPrimitive: () => stringifyPrimitive,
  required: () => required,
  randomString: () => randomString,
  propertyKeyTypes: () => propertyKeyTypes,
  promiseAllObject: () => promiseAllObject,
  primitiveTypes: () => primitiveTypes,
  prefixIssues: () => prefixIssues,
  pick: () => pick,
  partial: () => partial,
  optionalKeys: () => optionalKeys,
  omit: () => omit,
  numKeys: () => numKeys,
  nullish: () => nullish,
  normalizeParams: () => normalizeParams,
  merge: () => merge,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  joinValues: () => joinValues,
  issue: () => issue,
  isPlainObject: () => isPlainObject,
  isObject: () => isObject2,
  getSizableOrigin: () => getSizableOrigin,
  getParsedType: () => getParsedType2,
  getLengthableOrigin: () => getLengthableOrigin,
  getEnumValues: () => getEnumValues,
  getElementAtPath: () => getElementAtPath,
  floatSafeRemainder: () => floatSafeRemainder2,
  finalizeIssue: () => finalizeIssue,
  extend: () => extend,
  escapeRegex: () => escapeRegex,
  esc: () => esc,
  defineLazy: () => defineLazy,
  createTransparentProxy: () => createTransparentProxy,
  clone: () => clone,
  cleanRegex: () => cleanRegex,
  cleanEnum: () => cleanEnum,
  captureStackTrace: () => captureStackTrace,
  cached: () => cached,
  assignProp: () => assignProp,
  assertNotEqual: () => assertNotEqual,
  assertNever: () => assertNever,
  assertIs: () => assertIs,
  assertEqual: () => assertEqual,
  assert: () => assert,
  allowsEval: () => allowsEval,
  aborted: () => aborted,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  Class: () => Class,
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error();
}
function assert(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set = false;
  return {
    get value() {
      if (!set) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder2(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object, key, getter) {
  const set = false;
  Object.defineProperty(object, key, {
    get() {
      if (!set) {
        const value = getter();
        object[key] = value;
        return value;
      }
      throw new Error("cached value already set");
    },
    set(v) {
      Object.defineProperty(object, key, {
        value: v
      });
    },
    configurable: true
  });
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function getElementAtPath(obj, path9) {
  if (!path9)
    return obj;
  return path9.reduce((acc, key) => acc == null ? void 0 : acc[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
var captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {
};
function isObject2(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  var _a;
  if (typeof navigator !== "undefined" && ((_a = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : _a.includes("Cloudflare"))) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject2(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  const prot = ctor.prototype;
  if (isObject2(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType2 = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t2}`);
  }
};
var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def != null ? def : inst._zod.def);
  if (!def || (params == null ? void 0 : params.parent))
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if ((params == null ? void 0 : params.message) !== void 0) {
    if ((params == null ? void 0 : params.error) !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target != null ? target : target = getter();
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target != null ? target : target = getter();
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target != null ? target : target = getter();
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target != null ? target : target = getter();
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target != null ? target : target = getter();
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target != null ? target : target = getter();
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target != null ? target : target = getter();
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const newShape = {};
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    newShape[key] = currDef.shape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function omit(schema, mask) {
  const newShape = { ...schema._zod.def.shape };
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    delete newShape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
  };
  return clone(schema, def);
}
function merge(a, b) {
  return clone(a, {
    ...a._zod.def,
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    catchall: b._zod.def.catchall,
    checks: []
  });
}
function partial(Class2, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in oldShape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = Class2 ? new Class2({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  } else {
    for (const key in oldShape) {
      shape[key] = Class2 ? new Class2({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    checks: []
  });
}
function required(Class2, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in shape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = new Class2({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  } else {
    for (const key in oldShape) {
      shape[key] = new Class2({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    checks: []
  });
}
function aborted(x, startIndex = 0) {
  var _a;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (((_a = x.issues[i]) == null ? void 0 : _a.continue) !== true)
      return true;
  }
  return false;
}
function prefixIssues(path9, issues) {
  return issues.map((iss) => {
    var _a2;
    var _a;
    (_a2 = (_a = iss).path) != null ? _a2 : _a.path = [];
    iss.path.unshift(path9);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message == null ? void 0 : message.message;
}
function finalizeIssue(iss, ctx, config2) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  const full = { ...iss, path: (_a = iss.path) != null ? _a : [] };
  if (!iss.message) {
    const message = (_k = (_j = (_h = (_f = unwrapMessage((_d = (_c = (_b = iss.inst) == null ? void 0 : _b._zod.def) == null ? void 0 : _c.error) == null ? void 0 : _d.call(_c, iss))) != null ? _f : unwrapMessage((_e = ctx == null ? void 0 : ctx.error) == null ? void 0 : _e.call(ctx, iss))) != null ? _h : unwrapMessage((_g = config2.customError) == null ? void 0 : _g.call(config2, iss))) != null ? _j : unwrapMessage((_i = config2.localeError) == null ? void 0 : _i.call(config2, iss))) != null ? _k : "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!(ctx == null ? void 0 : ctx.reportInput)) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
var Class = class {
  constructor(..._args) {
  }
};
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  Object.defineProperty(inst, "message", {
    get() {
      return JSON.stringify(def, jsonStringifyReplacer, 2);
    },
    enumerable: true
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error2, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error2.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error2, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error22) => {
    for (const issue2 of error22.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error2);
  return fieldErrors;
}
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  var _a;
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new ((_a = _params == null ? void 0 : _params.Err) != null ? _a : _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params == null ? void 0 : _params.callee);
    throw e;
  }
  return result.value;
};
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  var _a;
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new ((_a = params == null ? void 0 : params.Err) != null ? _a : _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params == null ? void 0 : params.callee);
    throw e;
  }
  return result.value;
};
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err != null ? _Err : $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname2 = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time22 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-]\\d{2}:\\d{2})`);
  const timeRegex2 = `${time22}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex2})$`);
}
var string = (params) => {
  var _a, _b;
  const regex = params ? `[\\s\\S]{${(_a = params == null ? void 0 : params.minimum) != null ? _a : 0},${(_b = params == null ? void 0 : params.maximum) != null ? _b : ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var integer = /^\d+$/;
var number = /^-?\d+(?:\.\d+)?/i;
var boolean = /true|false/i;
var _null = /null/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a2, _b;
  var _a;
  (_a2 = inst._zod) != null ? _a2 : inst._zod = {};
  inst._zod.def = def;
  (_b = (_a = inst._zod).onattach) != null ? _b : _a.onattach = [];
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    var _a;
    const bag = inst2._zod.bag;
    const curr = (_a = def.inclusive ? bag.maximum : bag.exclusiveMaximum) != null ? _a : Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    var _a;
    const bag = inst2._zod.bag;
    const curr = (_a = def.inclusive ? bag.minimum : bag.exclusiveMinimum) != null ? _a : Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a2;
    var _a;
    (_a2 = (_a = inst2._zod.bag).multipleOf) != null ? _a2 : _a.multipleOf = def.value;
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder2(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = (_a = def.format) == null ? void 0 : _a.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  };
  inst._zod.onattach.push((inst2) => {
    var _a;
    const curr = (_a = inst2._zod.bag.maximum) != null ? _a : Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  };
  inst._zod.onattach.push((inst2) => {
    var _a;
    const curr = (_a = inst2._zod.bag.minimum) != null ? _a : Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  };
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b2;
  var _a, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a3;
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      (_a3 = bag.patterns) != null ? _a3 : bag.patterns = /* @__PURE__ */ new Set();
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a2 = (_a = inst._zod).check) != null ? _a2 : _a.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    };
  else
    (_b2 = (_b = inst._zod).check) != null ? _b2 : _b.check = () => {
    };
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  var _a;
  (_a = def.pattern) != null ? _a : def.pattern = lowercase;
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  var _a;
  (_a = def.pattern) != null ? _a : def.pattern = uppercase;
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    var _a;
    const bag = inst2._zod.bag;
    (_a = bag.patterns) != null ? _a : bag.patterns = /* @__PURE__ */ new Set();
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  (_a = def.pattern) != null ? _a : def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    var _a2;
    const bag = inst2._zod.bag;
    (_a2 = bag.patterns) != null ? _a2 : bag.patterns = /* @__PURE__ */ new Set();
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  (_a = def.pattern) != null ? _a : def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    var _a2;
    const bag = inst2._zod.bag;
    (_a2 = bag.patterns) != null ? _a2 : bag.patterns = /* @__PURE__ */ new Set();
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});
var Doc = class {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split(`
`).filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    var _a;
    const F = Function;
    const args = this == null ? void 0 : this.args;
    const content = (_a = this == null ? void 0 : this.content) != null ? _a : [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join(`
`));
  }
};
var version = {
  major: 4,
  minor: 0,
  patch: 0
};
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a2, _b, _c;
  var _a;
  inst != null ? inst : inst = {};
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...(_a2 = inst._zod.def.checks) != null ? _a2 : []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_b = (_a = inst._zod).deferred) != null ? _b : _a.deferred = [];
    (_c = inst._zod.deferred) == null ? void 0 : _c.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted2 = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.when) {
          const shouldRun = ch._zod.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted2) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && (ctx == null ? void 0 : ctx.async) === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult != null ? asyncResult : Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted2)
              isAborted2 = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted2)
            isAborted2 = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    inst._zod.run = (payload, ctx) => {
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      var _a3;
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: (_a3 = r.error) == null ? void 0 : _a3.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r) => {
          var _a4;
          return r.success ? { value: r.data } : { issues: (_a4 = r.error) == null ? void 0 : _a4.issues };
        });
      }
    },
    vendor: "zod",
    version: 1
  };
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  var _a, _b, _c;
  $ZodType.init(inst, def);
  inst._zod.pattern = (_c = [...(_b = (_a = inst == null ? void 0 : inst._zod.bag) == null ? void 0 : _a.patterns) != null ? _b : []].pop()) != null ? _c : string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  var _a;
  (_a = def.pattern) != null ? _a : def.pattern = guid;
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  var _a, _b;
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    (_a = def.pattern) != null ? _a : def.pattern = uuid(v);
  } else
    (_b = def.pattern) != null ? _b : def.pattern = uuid();
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  var _a;
  (_a = def.pattern) != null ? _a : def.pattern = email;
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const orig = payload.value;
      const url = new URL(orig);
      const href = url.href;
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname2.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (!orig.endsWith("/") && href.endsWith("/")) {
        payload.value = href.slice(0, -1);
      } else {
        payload.value = href;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  var _a;
  (_a = def.pattern) != null ? _a : def.pattern = emoji();
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  var _a;
  (_a = def.pattern) != null ? _a : def.pattern = nanoid;
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  var _a;
  (_a = def.pattern) != null ? _a : def.pattern = cuid;
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  var _a;
  (_a = def.pattern) != null ? _a : def.pattern = cuid2;
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  var _a;
  (_a = def.pattern) != null ? _a : def.pattern = ulid;
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  var _a;
  (_a = def.pattern) != null ? _a : def.pattern = xid;
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  var _a;
  (_a = def.pattern) != null ? _a : def.pattern = ksuid;
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  var _a;
  (_a = def.pattern) != null ? _a : def.pattern = datetime(def);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  var _a;
  (_a = def.pattern) != null ? _a : def.pattern = date;
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  var _a;
  (_a = def.pattern) != null ? _a : def.pattern = time(def);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  var _a;
  (_a = def.pattern) != null ? _a : def.pattern = duration;
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  var _a;
  (_a = def.pattern) != null ? _a : def.pattern = ipv4;
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  var _a;
  (_a = def.pattern) != null ? _a : def.pattern = ipv6;
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch (e) {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  var _a;
  (_a = def.pattern) != null ? _a : def.pattern = cidrv4;
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  var _a;
  (_a = def.pattern) != null ? _a : def.pattern = cidrv6;
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const [address, prefix] = payload.value.split("/");
    try {
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch (e) {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch (e) {
    return false;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  var _a;
  (_a = def.pattern) != null ? _a : def.pattern = base64;
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  var _a;
  (_a = def.pattern) != null ? _a : def.pattern = base64url;
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  var _a;
  (_a = def.pattern) != null ? _a : def.pattern = e164;
  $ZodStringFormat.init(inst, def);
});
function isValidJWT2(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && (parsedHeader == null ? void 0 : parsedHeader.typ) !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch (e) {
    return false;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT2(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  var _a;
  $ZodType.init(inst, def);
  inst._zod.pattern = (_a = inst._zod.bag.pattern) != null ? _a : number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handleObjectResult(result, final, key) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  final.value[key] = result.value;
}
function handleOptionalObjectResult(result, final, key, input) {
  if (result.issues.length) {
    if (input[key] === void 0) {
      if (key in input) {
        final.value[key] = void 0;
      } else {
        final.value[key] = result.value;
      }
    } else {
      final.issues.push(...prefixIssues(key, result.issues));
    }
  } else if (result.value === void 0) {
    if (key in input)
      final.value[key] = void 0;
  } else {
    final.value[key] = result.value;
  }
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const _normalized = cached(() => {
    const keys = Object.keys(def.shape);
    for (const k of keys) {
      if (!(def.shape[k] instanceof $ZodType)) {
        throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
      }
    }
    const okeys = optionalKeys(def.shape);
    return {
      shape: def.shape,
      keys,
      keySet: new Set(keys),
      numKeys: keys.length,
      optionalKeys: new Set(okeys)
    };
  });
  defineLazy(inst._zod, "propValues", () => {
    var _a;
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        (_a = propValues[key]) != null ? _a : propValues[key] = /* @__PURE__ */ new Set();
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {}`);
    for (const key of normalized.keys) {
      if (normalized.optionalKeys.has(key)) {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        const k = esc(key);
        doc.write(`
        if (${id}.issues.length) {
          if (input[${k}] === undefined) {
            if (${k} in input) {
              newResult[${k}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k}, ...iss.path] : [${k}],
              }))
            );
          }
        } else if (${id}.value === undefined) {
          if (${k} in input) newResult[${k}] = undefined;
        } else {
          newResult[${k}] = ${id}.value;
        }
        `);
      } else {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        doc.write(`
          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]
          })));`);
        doc.write(`newResult[${esc(key)}] = ${id}.value`);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject3 = isObject2;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value != null ? value : value = _normalized.value;
    const input = payload.value;
    if (!isObject3(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (jit && fastEnabled && (ctx == null ? void 0 : ctx.async) === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
    } else {
      payload.value = {};
      const shape = value.shape;
      for (const key of value.keys) {
        const el = shape[key];
        const r = el._zod.run({ value: input[key], issues: [] }, ctx);
        const isOptional = el._zod.optin === "optional" && el._zod.optout === "optional";
        if (r instanceof Promise) {
          proms.push(r.then((r2) => isOptional ? handleOptionalObjectResult(r2, payload, key, input) : handleObjectResult(r2, payload, key)));
        } else if (isOptional) {
          handleOptionalObjectResult(r, payload, key, input);
        } else {
          handleObjectResult(r, payload, key);
        }
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    const unrecognized = [];
    const keySet = value.keySet;
    const _catchall = catchall._zod;
    const t2 = _catchall.def.type;
    for (const key of Object.keys(input)) {
      if (keySet.has(key))
        continue;
      if (t2 === "never") {
        unrecognized.push(key);
        continue;
      }
      const r = _catchall.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handleObjectResult(r2, payload, key)));
      } else {
        handleObjectResult(r, payload, key);
      }
    }
    if (unrecognized.length) {
      payload.issues.push({
        code: "unrecognized_keys",
        keys: unrecognized,
        input,
        inst
      });
    }
    if (!proms.length)
      return payload;
    return Promise.all(proms).then(() => {
      return payload;
    });
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return;
  });
  inst._zod.parse = (payload, ctx) => {
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = /* @__PURE__ */ new Set();
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map = /* @__PURE__ */ new Map();
    for (const o of opts) {
      const values = o._zod.propValues[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map.set(v, o);
      }
    }
    return map;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input == null ? void 0 : input[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues2(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues2(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues2(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized != null ? unrecognized : [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            origin: "record",
            code: "invalid_key",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  inst._zod.values = new Set(values);
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? o.toString() : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const _out = def.transform(payload.value, payload);
    if (_ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def, ctx));
    }
    return handlePipeResult(left, def, ctx);
  };
});
function handlePipeResult(left, def, ctx) {
  if (aborted(left)) {
    return left;
  }
  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  var _a;
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      path: [...(_a = inst._zod.def.path) != null ? _a : []],
      continue: !inst._zod.def.abort
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
var parsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t2;
};
var error = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    var _a;
    return (_a = Sizable[origin]) != null ? _a : null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    var _a, _b, _c, _d;
    switch (issue2.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue2.expected}, received ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${(_a = issue2.origin) != null ? _a : "value"} to have ${adj}${issue2.maximum.toString()} ${(_b = sizing.unit) != null ? _b : "elements"}`;
        return `Too big: expected ${(_c = issue2.origin) != null ? _c : "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${(_d = Nouns[_issue.format]) != null ? _d : issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default2() {
  return {
    localeError: error()
  };
}
var $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  remove(schema) {
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    var _a;
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...(_a = this.get(p)) != null ? _a : {} };
      delete pm.id;
      return { ...pm, ...this._map.get(schema) };
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
var globalRegistry = /* @__PURE__ */ registry();
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    ...normalizeParams(params)
  });
}
function _custom(Class2, fn, _params) {
  var _a;
  const norm = normalizeParams(_params);
  (_a = norm.abort) != null ? _a : norm.abort = true;
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
var exports_iso2 = {};
__export2(exports_iso2, {
  time: () => time2,
  duration: () => duration2,
  datetime: () => datetime2,
  date: () => date2,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
    },
    addIssue: {
      value: (issue2) => inst.issues.push(issue2)
    },
    addIssues: {
      value: (issues2) => inst.issues.push(...issues2)
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
    }
  });
};
var ZodError2 = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});
var parse4 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse3 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync3 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
var ZodType2 = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks3) => {
    var _a;
    return inst.clone({
      ...def,
      checks: [
        ...(_a = def.checks) != null ? _a : [],
        ...checks3.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    });
  };
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
  inst.parse = (data, params) => parse4(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse3(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync3(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.refine = (check2, params) => inst.check(refine(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      var _a;
      return (_a = globalRegistry.get(inst)) == null ? void 0 : _a.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  var _a, _b, _c;
  $ZodString.init(inst, def);
  ZodType2.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = (_a = bag.format) != null ? _a : null;
  inst.minLength = (_b = bag.minimum) != null ? _b : null;
  inst.maxLength = (_c = bag.maximum) != null ? _c : null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
var ZodString2 = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString2, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodNumber2 = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  $ZodNumber.init(inst, def);
  ZodType2.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = (_c = Math.max((_a = bag.minimum) != null ? _a : Number.NEGATIVE_INFINITY, (_b = bag.exclusiveMinimum) != null ? _b : Number.NEGATIVE_INFINITY)) != null ? _c : null;
  inst.maxValue = (_f = Math.min((_d = bag.maximum) != null ? _d : Number.POSITIVE_INFINITY, (_e = bag.exclusiveMaximum) != null ? _e : Number.POSITIVE_INFINITY)) != null ? _f : null;
  inst.isInt = ((_g = bag.format) != null ? _g : "").includes("int") || Number.isSafeInteger((_h = bag.multipleOf) != null ? _h : 0.5);
  inst.isFinite = true;
  inst.format = (_i = bag.format) != null ? _i : null;
});
function number2(params) {
  return _number(ZodNumber2, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber2.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
var ZodBoolean2 = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType2.init(inst, def);
});
function boolean2(params) {
  return _boolean(ZodBoolean2, params);
}
var ZodNull2 = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType2.init(inst, def);
});
function _null3(params) {
  return _null2(ZodNull2, params);
}
var ZodUnknown2 = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType2.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown2);
}
var ZodNever2 = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType2.init(inst, def);
});
function never(params) {
  return _never(ZodNever2, params);
}
var ZodArray2 = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType2.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray2, element, params);
}
var ZodObject2 = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodType2.init(inst, def);
  exports_util.defineLazy(inst, "shape", () => def.shape);
  inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return exports_util.extend(inst, incoming);
  };
  inst.merge = (other) => exports_util.merge(inst, other);
  inst.pick = (mask) => exports_util.pick(inst, mask);
  inst.omit = (mask) => exports_util.omit(inst, mask);
  inst.partial = (...args) => exports_util.partial(ZodOptional2, inst, args[0]);
  inst.required = (...args) => exports_util.required(ZodNonOptional, inst, args[0]);
});
function object2(shape, params) {
  const def = {
    type: "object",
    get shape() {
      exports_util.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    ...exports_util.normalizeParams(params)
  };
  return new ZodObject2(def);
}
function looseObject(shape, params) {
  return new ZodObject2({
    type: "object",
    get shape() {
      exports_util.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    catchall: unknown(),
    ...exports_util.normalizeParams(params)
  });
}
var ZodUnion2 = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType2.init(inst, def);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion2({
    type: "union",
    options,
    ...exports_util.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion2.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion2({
    type: "union",
    options,
    discriminator,
    ...exports_util.normalizeParams(params)
  });
}
var ZodIntersection2 = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType2.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection2({
    type: "intersection",
    left,
    right
  });
}
var ZodRecord2 = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType2.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodEnum2 = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType2.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum2({
      ...def,
      checks: [],
      ...exports_util.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum2({
      ...def,
      checks: [],
      ...exports_util.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum2({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
var ZodLiteral2 = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType2.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...exports_util.normalizeParams(params)
  });
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.addIssue = (issue2) => {
      var _a, _b, _c, _d;
      if (typeof issue2 === "string") {
        payload.issues.push(exports_util.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        (_a = _issue.code) != null ? _a : _issue.code = "custom";
        (_b = _issue.input) != null ? _b : _issue.input = payload.value;
        (_c = _issue.inst) != null ? _c : _issue.inst = inst;
        (_d = _issue.continue) != null ? _d : _issue.continue = true;
        payload.issues.push(exports_util.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional2 = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional2({
    type: "optional",
    innerType
  });
}
var ZodNullable2 = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable2({
    type: "nullable",
    innerType
  });
}
var ZodDefault2 = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
  return new ZodDefault2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodCatch2 = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
  return new ZodCatch2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType2.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
  });
}
var ZodReadonly2 = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType2.init(inst, def);
});
function readonly(innerType) {
  return new ZodReadonly2({
    type: "readonly",
    innerType
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType2.init(inst, def);
});
function check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...exports_util.normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn != null ? fn : (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn, params) {
  const ch = check((payload) => {
    payload.addIssue = (issue2) => {
      var _a, _b, _c, _d;
      if (typeof issue2 === "string") {
        payload.issues.push(exports_util.issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        (_a = _issue.code) != null ? _a : _issue.code = "custom";
        (_b = _issue.input) != null ? _b : _issue.input = payload.value;
        (_c = _issue.inst) != null ? _c : _issue.inst = ch;
        (_d = _issue.continue) != null ? _d : _issue.continue = !ch._zod.def.abort;
        payload.issues.push(exports_util.issue(_issue));
      }
    };
    return fn(payload.value, payload);
  }, params);
  return ch;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}
config(en_default2());
var RELATED_TASK_META_KEY = "io.modelcontextprotocol/related-task";
var JSONRPC_VERSION = "2.0";
var AssertObjectSchema = custom((v) => v !== null && (typeof v === "object" || typeof v === "function"));
var ProgressTokenSchema = union([string2(), number2().int()]);
var CursorSchema = string2();
var TaskCreationParamsSchema = looseObject({
  ttl: union([number2(), _null3()]).optional(),
  pollInterval: number2().optional()
});
var RelatedTaskMetadataSchema = looseObject({
  taskId: string2()
});
var RequestMetaSchema = looseObject({
  progressToken: ProgressTokenSchema.optional(),
  [RELATED_TASK_META_KEY]: RelatedTaskMetadataSchema.optional()
});
var BaseRequestParamsSchema = looseObject({
  task: TaskCreationParamsSchema.optional(),
  _meta: RequestMetaSchema.optional()
});
var RequestSchema = object2({
  method: string2(),
  params: BaseRequestParamsSchema.optional()
});
var NotificationsParamsSchema = looseObject({
  _meta: object2({
    [RELATED_TASK_META_KEY]: optional(RelatedTaskMetadataSchema)
  }).passthrough().optional()
});
var NotificationSchema = object2({
  method: string2(),
  params: NotificationsParamsSchema.optional()
});
var ResultSchema = looseObject({
  _meta: looseObject({
    [RELATED_TASK_META_KEY]: RelatedTaskMetadataSchema.optional()
  }).optional()
});
var RequestIdSchema = union([string2(), number2().int()]);
var JSONRPCRequestSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  ...RequestSchema.shape
}).strict();
var JSONRPCNotificationSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  ...NotificationSchema.shape
}).strict();
var JSONRPCResponseSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  result: ResultSchema
}).strict();
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2["ConnectionClosed"] = -32e3] = "ConnectionClosed";
  ErrorCode2[ErrorCode2["RequestTimeout"] = -32001] = "RequestTimeout";
  ErrorCode2[ErrorCode2["ParseError"] = -32700] = "ParseError";
  ErrorCode2[ErrorCode2["InvalidRequest"] = -32600] = "InvalidRequest";
  ErrorCode2[ErrorCode2["MethodNotFound"] = -32601] = "MethodNotFound";
  ErrorCode2[ErrorCode2["InvalidParams"] = -32602] = "InvalidParams";
  ErrorCode2[ErrorCode2["InternalError"] = -32603] = "InternalError";
  ErrorCode2[ErrorCode2["UrlElicitationRequired"] = -32042] = "UrlElicitationRequired";
})(ErrorCode || (ErrorCode = {}));
var JSONRPCErrorSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  error: object2({
    code: number2().int(),
    message: string2(),
    data: optional(unknown())
  })
}).strict();
var JSONRPCMessageSchema = union([JSONRPCRequestSchema, JSONRPCNotificationSchema, JSONRPCResponseSchema, JSONRPCErrorSchema]);
var EmptyResultSchema = ResultSchema.strict();
var CancelledNotificationParamsSchema = NotificationsParamsSchema.extend({
  requestId: RequestIdSchema,
  reason: string2().optional()
});
var CancelledNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/cancelled"),
  params: CancelledNotificationParamsSchema
});
var IconSchema = object2({
  src: string2(),
  mimeType: string2().optional(),
  sizes: array(string2()).optional()
});
var IconsSchema = object2({
  icons: array(IconSchema).optional()
});
var BaseMetadataSchema = object2({
  name: string2(),
  title: string2().optional()
});
var ImplementationSchema = BaseMetadataSchema.extend({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  version: string2(),
  websiteUrl: string2().optional()
});
var FormElicitationCapabilitySchema = intersection(object2({
  applyDefaults: boolean2().optional()
}), record(string2(), unknown()));
var ElicitationCapabilitySchema = preprocess((value) => {
  if (value && typeof value === "object" && !Array.isArray(value)) {
    if (Object.keys(value).length === 0) {
      return { form: {} };
    }
  }
  return value;
}, intersection(object2({
  form: FormElicitationCapabilitySchema.optional(),
  url: AssertObjectSchema.optional()
}), record(string2(), unknown()).optional()));
var ClientTasksCapabilitySchema = object2({
  list: optional(object2({}).passthrough()),
  cancel: optional(object2({}).passthrough()),
  requests: optional(object2({
    sampling: optional(object2({
      createMessage: optional(object2({}).passthrough())
    }).passthrough()),
    elicitation: optional(object2({
      create: optional(object2({}).passthrough())
    }).passthrough())
  }).passthrough())
}).passthrough();
var ServerTasksCapabilitySchema = object2({
  list: optional(object2({}).passthrough()),
  cancel: optional(object2({}).passthrough()),
  requests: optional(object2({
    tools: optional(object2({
      call: optional(object2({}).passthrough())
    }).passthrough())
  }).passthrough())
}).passthrough();
var ClientCapabilitiesSchema = object2({
  experimental: record(string2(), AssertObjectSchema).optional(),
  sampling: object2({
    context: AssertObjectSchema.optional(),
    tools: AssertObjectSchema.optional()
  }).optional(),
  elicitation: ElicitationCapabilitySchema.optional(),
  roots: object2({
    listChanged: boolean2().optional()
  }).optional(),
  tasks: optional(ClientTasksCapabilitySchema)
});
var InitializeRequestParamsSchema = BaseRequestParamsSchema.extend({
  protocolVersion: string2(),
  capabilities: ClientCapabilitiesSchema,
  clientInfo: ImplementationSchema
});
var InitializeRequestSchema = RequestSchema.extend({
  method: literal("initialize"),
  params: InitializeRequestParamsSchema
});
var ServerCapabilitiesSchema = object2({
  experimental: record(string2(), AssertObjectSchema).optional(),
  logging: AssertObjectSchema.optional(),
  completions: AssertObjectSchema.optional(),
  prompts: optional(object2({
    listChanged: optional(boolean2())
  })),
  resources: object2({
    subscribe: boolean2().optional(),
    listChanged: boolean2().optional()
  }).optional(),
  tools: object2({
    listChanged: boolean2().optional()
  }).optional(),
  tasks: optional(ServerTasksCapabilitySchema)
}).passthrough();
var InitializeResultSchema = ResultSchema.extend({
  protocolVersion: string2(),
  capabilities: ServerCapabilitiesSchema,
  serverInfo: ImplementationSchema,
  instructions: string2().optional()
});
var InitializedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/initialized")
});
var PingRequestSchema = RequestSchema.extend({
  method: literal("ping")
});
var ProgressSchema = object2({
  progress: number2(),
  total: optional(number2()),
  message: optional(string2())
});
var ProgressNotificationParamsSchema = object2({
  ...NotificationsParamsSchema.shape,
  ...ProgressSchema.shape,
  progressToken: ProgressTokenSchema
});
var ProgressNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/progress"),
  params: ProgressNotificationParamsSchema
});
var PaginatedRequestParamsSchema = BaseRequestParamsSchema.extend({
  cursor: CursorSchema.optional()
});
var PaginatedRequestSchema = RequestSchema.extend({
  params: PaginatedRequestParamsSchema.optional()
});
var PaginatedResultSchema = ResultSchema.extend({
  nextCursor: optional(CursorSchema)
});
var TaskSchema = object2({
  taskId: string2(),
  status: _enum(["working", "input_required", "completed", "failed", "cancelled"]),
  ttl: union([number2(), _null3()]),
  createdAt: string2(),
  lastUpdatedAt: string2(),
  pollInterval: optional(number2()),
  statusMessage: optional(string2())
});
var CreateTaskResultSchema = ResultSchema.extend({
  task: TaskSchema
});
var TaskStatusNotificationParamsSchema = NotificationsParamsSchema.merge(TaskSchema);
var TaskStatusNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/tasks/status"),
  params: TaskStatusNotificationParamsSchema
});
var GetTaskRequestSchema = RequestSchema.extend({
  method: literal("tasks/get"),
  params: BaseRequestParamsSchema.extend({
    taskId: string2()
  })
});
var GetTaskResultSchema = ResultSchema.merge(TaskSchema);
var GetTaskPayloadRequestSchema = RequestSchema.extend({
  method: literal("tasks/result"),
  params: BaseRequestParamsSchema.extend({
    taskId: string2()
  })
});
var ListTasksRequestSchema = PaginatedRequestSchema.extend({
  method: literal("tasks/list")
});
var ListTasksResultSchema = PaginatedResultSchema.extend({
  tasks: array(TaskSchema)
});
var CancelTaskRequestSchema = RequestSchema.extend({
  method: literal("tasks/cancel"),
  params: BaseRequestParamsSchema.extend({
    taskId: string2()
  })
});
var CancelTaskResultSchema = ResultSchema.merge(TaskSchema);
var ResourceContentsSchema = object2({
  uri: string2(),
  mimeType: optional(string2()),
  _meta: record(string2(), unknown()).optional()
});
var TextResourceContentsSchema = ResourceContentsSchema.extend({
  text: string2()
});
var Base64Schema = string2().refine((val) => {
  try {
    atob(val);
    return true;
  } catch (_a) {
    return false;
  }
}, { message: "Invalid Base64 string" });
var BlobResourceContentsSchema = ResourceContentsSchema.extend({
  blob: Base64Schema
});
var AnnotationsSchema = object2({
  audience: array(_enum(["user", "assistant"])).optional(),
  priority: number2().min(0).max(1).optional(),
  lastModified: exports_iso2.datetime({ offset: true }).optional()
});
var ResourceSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  uri: string2(),
  description: optional(string2()),
  mimeType: optional(string2()),
  annotations: AnnotationsSchema.optional(),
  _meta: optional(looseObject({}))
});
var ResourceTemplateSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  uriTemplate: string2(),
  description: optional(string2()),
  mimeType: optional(string2()),
  annotations: AnnotationsSchema.optional(),
  _meta: optional(looseObject({}))
});
var ListResourcesRequestSchema = PaginatedRequestSchema.extend({
  method: literal("resources/list")
});
var ListResourcesResultSchema = PaginatedResultSchema.extend({
  resources: array(ResourceSchema)
});
var ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({
  method: literal("resources/templates/list")
});
var ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({
  resourceTemplates: array(ResourceTemplateSchema)
});
var ResourceRequestParamsSchema = BaseRequestParamsSchema.extend({
  uri: string2()
});
var ReadResourceRequestParamsSchema = ResourceRequestParamsSchema;
var ReadResourceRequestSchema = RequestSchema.extend({
  method: literal("resources/read"),
  params: ReadResourceRequestParamsSchema
});
var ReadResourceResultSchema = ResultSchema.extend({
  contents: array(union([TextResourceContentsSchema, BlobResourceContentsSchema]))
});
var ResourceListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/resources/list_changed")
});
var SubscribeRequestParamsSchema = ResourceRequestParamsSchema;
var SubscribeRequestSchema = RequestSchema.extend({
  method: literal("resources/subscribe"),
  params: SubscribeRequestParamsSchema
});
var UnsubscribeRequestParamsSchema = ResourceRequestParamsSchema;
var UnsubscribeRequestSchema = RequestSchema.extend({
  method: literal("resources/unsubscribe"),
  params: UnsubscribeRequestParamsSchema
});
var ResourceUpdatedNotificationParamsSchema = NotificationsParamsSchema.extend({
  uri: string2()
});
var ResourceUpdatedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/resources/updated"),
  params: ResourceUpdatedNotificationParamsSchema
});
var PromptArgumentSchema = object2({
  name: string2(),
  description: optional(string2()),
  required: optional(boolean2())
});
var PromptSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  description: optional(string2()),
  arguments: optional(array(PromptArgumentSchema)),
  _meta: optional(looseObject({}))
});
var ListPromptsRequestSchema = PaginatedRequestSchema.extend({
  method: literal("prompts/list")
});
var ListPromptsResultSchema = PaginatedResultSchema.extend({
  prompts: array(PromptSchema)
});
var GetPromptRequestParamsSchema = BaseRequestParamsSchema.extend({
  name: string2(),
  arguments: record(string2(), string2()).optional()
});
var GetPromptRequestSchema = RequestSchema.extend({
  method: literal("prompts/get"),
  params: GetPromptRequestParamsSchema
});
var TextContentSchema = object2({
  type: literal("text"),
  text: string2(),
  annotations: AnnotationsSchema.optional(),
  _meta: record(string2(), unknown()).optional()
});
var ImageContentSchema = object2({
  type: literal("image"),
  data: Base64Schema,
  mimeType: string2(),
  annotations: AnnotationsSchema.optional(),
  _meta: record(string2(), unknown()).optional()
});
var AudioContentSchema = object2({
  type: literal("audio"),
  data: Base64Schema,
  mimeType: string2(),
  annotations: AnnotationsSchema.optional(),
  _meta: record(string2(), unknown()).optional()
});
var ToolUseContentSchema = object2({
  type: literal("tool_use"),
  name: string2(),
  id: string2(),
  input: object2({}).passthrough(),
  _meta: optional(object2({}).passthrough())
}).passthrough();
var EmbeddedResourceSchema = object2({
  type: literal("resource"),
  resource: union([TextResourceContentsSchema, BlobResourceContentsSchema]),
  annotations: AnnotationsSchema.optional(),
  _meta: record(string2(), unknown()).optional()
});
var ResourceLinkSchema = ResourceSchema.extend({
  type: literal("resource_link")
});
var ContentBlockSchema = union([
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ResourceLinkSchema,
  EmbeddedResourceSchema
]);
var PromptMessageSchema = object2({
  role: _enum(["user", "assistant"]),
  content: ContentBlockSchema
});
var GetPromptResultSchema = ResultSchema.extend({
  description: optional(string2()),
  messages: array(PromptMessageSchema)
});
var PromptListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/prompts/list_changed")
});
var ToolAnnotationsSchema = object2({
  title: string2().optional(),
  readOnlyHint: boolean2().optional(),
  destructiveHint: boolean2().optional(),
  idempotentHint: boolean2().optional(),
  openWorldHint: boolean2().optional()
});
var ToolExecutionSchema = object2({
  taskSupport: _enum(["required", "optional", "forbidden"]).optional()
});
var ToolSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  description: string2().optional(),
  inputSchema: object2({
    type: literal("object"),
    properties: record(string2(), AssertObjectSchema).optional(),
    required: array(string2()).optional()
  }).catchall(unknown()),
  outputSchema: object2({
    type: literal("object"),
    properties: record(string2(), AssertObjectSchema).optional(),
    required: array(string2()).optional()
  }).catchall(unknown()).optional(),
  annotations: optional(ToolAnnotationsSchema),
  execution: optional(ToolExecutionSchema),
  _meta: record(string2(), unknown()).optional()
});
var ListToolsRequestSchema = PaginatedRequestSchema.extend({
  method: literal("tools/list")
});
var ListToolsResultSchema = PaginatedResultSchema.extend({
  tools: array(ToolSchema)
});
var CallToolResultSchema = ResultSchema.extend({
  content: array(ContentBlockSchema).default([]),
  structuredContent: record(string2(), unknown()).optional(),
  isError: optional(boolean2())
});
var CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({
  toolResult: unknown()
}));
var CallToolRequestParamsSchema = BaseRequestParamsSchema.extend({
  name: string2(),
  arguments: optional(record(string2(), unknown()))
});
var CallToolRequestSchema = RequestSchema.extend({
  method: literal("tools/call"),
  params: CallToolRequestParamsSchema
});
var ToolListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/tools/list_changed")
});
var LoggingLevelSchema = _enum(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]);
var SetLevelRequestParamsSchema = BaseRequestParamsSchema.extend({
  level: LoggingLevelSchema
});
var SetLevelRequestSchema = RequestSchema.extend({
  method: literal("logging/setLevel"),
  params: SetLevelRequestParamsSchema
});
var LoggingMessageNotificationParamsSchema = NotificationsParamsSchema.extend({
  level: LoggingLevelSchema,
  logger: string2().optional(),
  data: unknown()
});
var LoggingMessageNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/message"),
  params: LoggingMessageNotificationParamsSchema
});
var ModelHintSchema = object2({
  name: string2().optional()
});
var ModelPreferencesSchema = object2({
  hints: optional(array(ModelHintSchema)),
  costPriority: optional(number2().min(0).max(1)),
  speedPriority: optional(number2().min(0).max(1)),
  intelligencePriority: optional(number2().min(0).max(1))
});
var ToolChoiceSchema = object2({
  mode: optional(_enum(["auto", "required", "none"]))
});
var ToolResultContentSchema = object2({
  type: literal("tool_result"),
  toolUseId: string2().describe("The unique identifier for the corresponding tool call."),
  content: array(ContentBlockSchema).default([]),
  structuredContent: object2({}).passthrough().optional(),
  isError: optional(boolean2()),
  _meta: optional(object2({}).passthrough())
}).passthrough();
var SamplingContentSchema = discriminatedUnion("type", [TextContentSchema, ImageContentSchema, AudioContentSchema]);
var SamplingMessageContentBlockSchema = discriminatedUnion("type", [
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ToolUseContentSchema,
  ToolResultContentSchema
]);
var SamplingMessageSchema = object2({
  role: _enum(["user", "assistant"]),
  content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)]),
  _meta: optional(object2({}).passthrough())
}).passthrough();
var CreateMessageRequestParamsSchema = BaseRequestParamsSchema.extend({
  messages: array(SamplingMessageSchema),
  modelPreferences: ModelPreferencesSchema.optional(),
  systemPrompt: string2().optional(),
  includeContext: _enum(["none", "thisServer", "allServers"]).optional(),
  temperature: number2().optional(),
  maxTokens: number2().int(),
  stopSequences: array(string2()).optional(),
  metadata: AssertObjectSchema.optional(),
  tools: optional(array(ToolSchema)),
  toolChoice: optional(ToolChoiceSchema)
});
var CreateMessageRequestSchema = RequestSchema.extend({
  method: literal("sampling/createMessage"),
  params: CreateMessageRequestParamsSchema
});
var CreateMessageResultSchema = ResultSchema.extend({
  model: string2(),
  stopReason: optional(_enum(["endTurn", "stopSequence", "maxTokens"]).or(string2())),
  role: _enum(["user", "assistant"]),
  content: SamplingContentSchema
});
var CreateMessageResultWithToolsSchema = ResultSchema.extend({
  model: string2(),
  stopReason: optional(_enum(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(string2())),
  role: _enum(["user", "assistant"]),
  content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)])
});
var BooleanSchemaSchema = object2({
  type: literal("boolean"),
  title: string2().optional(),
  description: string2().optional(),
  default: boolean2().optional()
});
var StringSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  minLength: number2().optional(),
  maxLength: number2().optional(),
  format: _enum(["email", "uri", "date", "date-time"]).optional(),
  default: string2().optional()
});
var NumberSchemaSchema = object2({
  type: _enum(["number", "integer"]),
  title: string2().optional(),
  description: string2().optional(),
  minimum: number2().optional(),
  maximum: number2().optional(),
  default: number2().optional()
});
var UntitledSingleSelectEnumSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  enum: array(string2()),
  default: string2().optional()
});
var TitledSingleSelectEnumSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  oneOf: array(object2({
    const: string2(),
    title: string2()
  })),
  default: string2().optional()
});
var LegacyTitledEnumSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  enum: array(string2()),
  enumNames: array(string2()).optional(),
  default: string2().optional()
});
var SingleSelectEnumSchemaSchema = union([UntitledSingleSelectEnumSchemaSchema, TitledSingleSelectEnumSchemaSchema]);
var UntitledMultiSelectEnumSchemaSchema = object2({
  type: literal("array"),
  title: string2().optional(),
  description: string2().optional(),
  minItems: number2().optional(),
  maxItems: number2().optional(),
  items: object2({
    type: literal("string"),
    enum: array(string2())
  }),
  default: array(string2()).optional()
});
var TitledMultiSelectEnumSchemaSchema = object2({
  type: literal("array"),
  title: string2().optional(),
  description: string2().optional(),
  minItems: number2().optional(),
  maxItems: number2().optional(),
  items: object2({
    anyOf: array(object2({
      const: string2(),
      title: string2()
    }))
  }),
  default: array(string2()).optional()
});
var MultiSelectEnumSchemaSchema = union([UntitledMultiSelectEnumSchemaSchema, TitledMultiSelectEnumSchemaSchema]);
var EnumSchemaSchema = union([LegacyTitledEnumSchemaSchema, SingleSelectEnumSchemaSchema, MultiSelectEnumSchemaSchema]);
var PrimitiveSchemaDefinitionSchema = union([EnumSchemaSchema, BooleanSchemaSchema, StringSchemaSchema, NumberSchemaSchema]);
var ElicitRequestFormParamsSchema = BaseRequestParamsSchema.extend({
  mode: literal("form").optional(),
  message: string2(),
  requestedSchema: object2({
    type: literal("object"),
    properties: record(string2(), PrimitiveSchemaDefinitionSchema),
    required: array(string2()).optional()
  })
});
var ElicitRequestURLParamsSchema = BaseRequestParamsSchema.extend({
  mode: literal("url"),
  message: string2(),
  elicitationId: string2(),
  url: string2().url()
});
var ElicitRequestParamsSchema = union([ElicitRequestFormParamsSchema, ElicitRequestURLParamsSchema]);
var ElicitRequestSchema = RequestSchema.extend({
  method: literal("elicitation/create"),
  params: ElicitRequestParamsSchema
});
var ElicitationCompleteNotificationParamsSchema = NotificationsParamsSchema.extend({
  elicitationId: string2()
});
var ElicitationCompleteNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/elicitation/complete"),
  params: ElicitationCompleteNotificationParamsSchema
});
var ElicitResultSchema = ResultSchema.extend({
  action: _enum(["accept", "decline", "cancel"]),
  content: preprocess((val) => val === null ? void 0 : val, record(string2(), union([string2(), number2(), boolean2(), array(string2())])).optional())
});
var ResourceTemplateReferenceSchema = object2({
  type: literal("ref/resource"),
  uri: string2()
});
var PromptReferenceSchema = object2({
  type: literal("ref/prompt"),
  name: string2()
});
var CompleteRequestParamsSchema = BaseRequestParamsSchema.extend({
  ref: union([PromptReferenceSchema, ResourceTemplateReferenceSchema]),
  argument: object2({
    name: string2(),
    value: string2()
  }),
  context: object2({
    arguments: record(string2(), string2()).optional()
  }).optional()
});
var CompleteRequestSchema = RequestSchema.extend({
  method: literal("completion/complete"),
  params: CompleteRequestParamsSchema
});
var CompleteResultSchema = ResultSchema.extend({
  completion: looseObject({
    values: array(string2()).max(100),
    total: optional(number2().int()),
    hasMore: optional(boolean2())
  })
});
var RootSchema = object2({
  uri: string2().startsWith("file://"),
  name: string2().optional(),
  _meta: record(string2(), unknown()).optional()
});
var ListRootsRequestSchema = RequestSchema.extend({
  method: literal("roots/list")
});
var ListRootsResultSchema = ResultSchema.extend({
  roots: array(RootSchema)
});
var RootsListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/roots/list_changed")
});
var ClientRequestSchema = union([
  PingRequestSchema,
  InitializeRequestSchema,
  CompleteRequestSchema,
  SetLevelRequestSchema,
  GetPromptRequestSchema,
  ListPromptsRequestSchema,
  ListResourcesRequestSchema,
  ListResourceTemplatesRequestSchema,
  ReadResourceRequestSchema,
  SubscribeRequestSchema,
  UnsubscribeRequestSchema,
  CallToolRequestSchema,
  ListToolsRequestSchema,
  GetTaskRequestSchema,
  GetTaskPayloadRequestSchema,
  ListTasksRequestSchema
]);
var ClientNotificationSchema = union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  InitializedNotificationSchema,
  RootsListChangedNotificationSchema,
  TaskStatusNotificationSchema
]);
var ClientResultSchema = union([
  EmptyResultSchema,
  CreateMessageResultSchema,
  CreateMessageResultWithToolsSchema,
  ElicitResultSchema,
  ListRootsResultSchema,
  GetTaskResultSchema,
  ListTasksResultSchema,
  CreateTaskResultSchema
]);
var ServerRequestSchema = union([
  PingRequestSchema,
  CreateMessageRequestSchema,
  ElicitRequestSchema,
  ListRootsRequestSchema,
  GetTaskRequestSchema,
  GetTaskPayloadRequestSchema,
  ListTasksRequestSchema
]);
var ServerNotificationSchema = union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  LoggingMessageNotificationSchema,
  ResourceUpdatedNotificationSchema,
  ResourceListChangedNotificationSchema,
  ToolListChangedNotificationSchema,
  PromptListChangedNotificationSchema,
  TaskStatusNotificationSchema,
  ElicitationCompleteNotificationSchema
]);
var ServerResultSchema = union([
  EmptyResultSchema,
  InitializeResultSchema,
  CompleteResultSchema,
  GetPromptResultSchema,
  ListPromptsResultSchema,
  ListResourcesResultSchema,
  ListResourceTemplatesResultSchema,
  ReadResourceResultSchema,
  CallToolResultSchema,
  ListToolsResultSchema,
  GetTaskResultSchema,
  ListTasksResultSchema,
  CreateTaskResultSchema
]);
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
var import_ajv = __toESM2(require_ajv(), 1);
var import_ajv_formats = __toESM2(require_dist(), 1);
var McpZodTypeKind;
(function(McpZodTypeKind2) {
  McpZodTypeKind2["Completable"] = "McpCompletable";
})(McpZodTypeKind || (McpZodTypeKind = {}));
function query({
  prompt,
  options
}) {
  const { systemPrompt, settingSources, sandbox, ...rest } = options != null ? options : {};
  let customSystemPrompt;
  let appendSystemPrompt;
  if (systemPrompt === void 0) {
    customSystemPrompt = "";
  } else if (typeof systemPrompt === "string") {
    customSystemPrompt = systemPrompt;
  } else if (systemPrompt.type === "preset") {
    appendSystemPrompt = systemPrompt.append;
  }
  let pathToClaudeCodeExecutable = rest.pathToClaudeCodeExecutable;
  if (!pathToClaudeCodeExecutable) {
    const filename = (0, import_url.fileURLToPath)(import_meta.url);
    const dirname22 = (0, import_path4.join)(filename, "..");
    pathToClaudeCodeExecutable = (0, import_path4.join)(dirname22, "cli.js");
  }
  process.env.CLAUDE_AGENT_SDK_VERSION = "0.2.7";
  const {
    abortController = createAbortController(),
    additionalDirectories = [],
    agents,
    allowedTools = [],
    betas,
    canUseTool,
    continue: continueConversation,
    cwd: cwd2,
    disallowedTools = [],
    tools,
    env,
    executable = isRunningWithBun() ? "bun" : "node",
    executableArgs = [],
    extraArgs = {},
    fallbackModel,
    enableFileCheckpointing,
    forkSession,
    hooks,
    includePartialMessages,
    persistSession,
    maxThinkingTokens,
    maxTurns,
    maxBudgetUsd,
    mcpServers,
    model,
    outputFormat,
    permissionMode = "default",
    allowDangerouslySkipPermissions = false,
    permissionPromptToolName,
    plugins,
    resume,
    resumeSessionAt,
    stderr,
    strictMcpConfig
  } = rest;
  const jsonSchema = (outputFormat == null ? void 0 : outputFormat.type) === "json_schema" ? outputFormat.schema : void 0;
  let processEnv = env;
  if (!processEnv) {
    processEnv = { ...process.env };
  }
  if (!processEnv.CLAUDE_CODE_ENTRYPOINT) {
    processEnv.CLAUDE_CODE_ENTRYPOINT = "sdk-ts";
  }
  if (enableFileCheckpointing) {
    processEnv.CLAUDE_CODE_ENABLE_SDK_FILE_CHECKPOINTING = "true";
  }
  if (!pathToClaudeCodeExecutable) {
    throw new Error("pathToClaudeCodeExecutable is required");
  }
  const allMcpServers = {};
  const sdkMcpServers = /* @__PURE__ */ new Map();
  if (mcpServers) {
    for (const [name, config2] of Object.entries(mcpServers)) {
      if (config2.type === "sdk" && "instance" in config2) {
        sdkMcpServers.set(name, config2.instance);
        allMcpServers[name] = {
          type: "sdk",
          name
        };
      } else {
        allMcpServers[name] = config2;
      }
    }
  }
  const isSingleUserTurn = typeof prompt === "string";
  const transport = new ProcessTransport({
    abortController,
    additionalDirectories,
    betas,
    cwd: cwd2,
    executable,
    executableArgs,
    extraArgs,
    pathToClaudeCodeExecutable,
    env: processEnv,
    forkSession,
    stderr,
    maxThinkingTokens,
    maxTurns,
    maxBudgetUsd,
    model,
    fallbackModel,
    jsonSchema,
    permissionMode,
    allowDangerouslySkipPermissions,
    permissionPromptToolName,
    continueConversation,
    resume,
    resumeSessionAt,
    settingSources: settingSources != null ? settingSources : [],
    allowedTools,
    disallowedTools,
    tools,
    mcpServers: allMcpServers,
    strictMcpConfig,
    canUseTool: !!canUseTool,
    hooks: !!hooks,
    includePartialMessages,
    persistSession,
    plugins,
    sandbox,
    spawnClaudeCodeProcess: rest.spawnClaudeCodeProcess
  });
  const initConfig = {
    systemPrompt: customSystemPrompt,
    appendSystemPrompt,
    agents
  };
  const queryInstance = new Query(transport, isSingleUserTurn, canUseTool, hooks, abortController, sdkMcpServers, jsonSchema, initConfig);
  if (typeof prompt === "string") {
    transport.write(jsonStringify({
      type: "user",
      session_id: "",
      message: {
        role: "user",
        content: [{ type: "text", text: prompt }]
      },
      parent_tool_use_id: null
    }) + `
`);
  } else {
    queryInstance.streamInput(prompt);
  }
  return queryInstance;
}

// src/core/agent/ClaudianService.ts
var import_obsidian2 = require("obsidian");

// src/utils/context.ts
var CURRENT_NOTE_PREFIX_REGEX = /^<current_note>\n[\s\S]*?<\/current_note>\n\n/;
function formatCurrentNote(notePath) {
  return `<current_note>
${notePath}
</current_note>`;
}
function prependCurrentNote(prompt, notePath) {
  return `${formatCurrentNote(notePath)}

${prompt}`;
}
function stripCurrentNotePrefix(prompt) {
  return prompt.replace(CURRENT_NOTE_PREFIX_REGEX, "");
}
function extractUserQuery(prompt) {
  if (!prompt) return "";
  const queryMatch = prompt.match(/<query>\n?([\s\S]*?)\n?<\/query>/);
  if (queryMatch) {
    return queryMatch[1].trim();
  }
  return prompt.replace(/<current_note>[\s\S]*?<\/current_note>\s*/g, "").replace(/<editor_selection>[\s\S]*?<\/editor_selection>\s*/g, "").replace(/<context_files>[\s\S]*?<\/context_files>\s*/g, "").trim();
}
function formatContextFilesLine(files) {
  return `<context_files>
${files.join(", ")}
</context_files>`;
}
function prependContextFiles(prompt, files) {
  return `${formatContextFilesLine(files)}

${prompt}`;
}

// src/utils/session.ts
var SESSION_ERROR_PATTERNS = [
  "session expired",
  "session not found",
  "invalid session",
  "session invalid",
  "process exited with code"
];
var SESSION_ERROR_COMPOUND_PATTERNS = [
  { includes: ["session", "expired"] },
  { includes: ["resume", "failed"] },
  { includes: ["resume", "error"] }
];
function isSessionExpiredError(error2) {
  const msg = error2 instanceof Error ? error2.message.toLowerCase() : "";
  for (const pattern of SESSION_ERROR_PATTERNS) {
    if (msg.includes(pattern)) {
      return true;
    }
  }
  for (const { includes } of SESSION_ERROR_COMPOUND_PATTERNS) {
    if (includes.every((part) => msg.includes(part))) {
      return true;
    }
  }
  return false;
}
function formatToolInput(input, maxLength = 200) {
  if (!input || Object.keys(input).length === 0) return "";
  try {
    const parts = [];
    for (const [key, value] of Object.entries(input)) {
      if (value === void 0 || value === null) continue;
      let valueStr;
      if (typeof value === "string") {
        valueStr = value.length > 100 ? `${value.slice(0, 100)}...` : value;
      } else if (typeof value === "object") {
        valueStr = "[object]";
      } else {
        valueStr = String(value);
      }
      parts.push(`${key}=${valueStr}`);
    }
    const result = parts.join(", ");
    return result.length > maxLength ? `${result.slice(0, maxLength)}...` : result;
  } catch (e) {
    return "[input formatting error]";
  }
}
function formatToolCallForContext(toolCall, maxErrorLength = 500) {
  var _a;
  const status = (_a = toolCall.status) != null ? _a : "completed";
  const isFailed = status === "error" || status === "blocked";
  const inputStr = formatToolInput(toolCall.input);
  const inputPart = inputStr ? ` input: ${inputStr}` : "";
  if (!isFailed) {
    return `[Tool ${toolCall.name}${inputPart} status=${status}]`;
  }
  const hasResult = typeof toolCall.result === "string" && toolCall.result.trim().length > 0;
  if (!hasResult) {
    return `[Tool ${toolCall.name}${inputPart} status=${status}]`;
  }
  const errorMsg = truncateToolResult(toolCall.result, maxErrorLength);
  return `[Tool ${toolCall.name}${inputPart} status=${status}] error: ${errorMsg}`;
}
function truncateToolResult(result, maxLength = 500) {
  if (result.length > maxLength) {
    return `${result.slice(0, maxLength)}... (truncated)`;
  }
  return result;
}
function formatContextLine(message) {
  if (!message.currentNote) {
    return null;
  }
  return formatCurrentNote(message.currentNote);
}
function formatThinkingBlocks(message) {
  if (!message.contentBlocks) return [];
  const thinkingBlocks = message.contentBlocks.filter(
    (block) => block.type === "thinking"
  );
  if (thinkingBlocks.length === 0) return [];
  const totalDuration = thinkingBlocks.reduce(
    (sum, block) => {
      var _a;
      return sum + ((_a = block.durationSeconds) != null ? _a : 0);
    },
    0
  );
  const durationPart = totalDuration > 0 ? `, ${totalDuration.toFixed(1)}s total` : "";
  return [`[Thinking: ${thinkingBlocks.length} block(s)${durationPart}]`];
}
function buildContextFromHistory(messages) {
  var _a, _b, _c;
  const parts = [];
  for (const message of messages) {
    if (message.role !== "user" && message.role !== "assistant") {
      continue;
    }
    if (message.isInterrupt) {
      continue;
    }
    if (message.role === "assistant") {
      const hasContent = message.content && message.content.trim().length > 0;
      const hasToolCalls = message.toolCalls && message.toolCalls.length > 0;
      const hasThinking = (_a = message.contentBlocks) == null ? void 0 : _a.some((b) => b.type === "thinking");
      if (!hasContent && !hasToolCalls && !hasThinking) {
        continue;
      }
    }
    const role = message.role === "user" ? "User" : "Assistant";
    const lines = [];
    const content = (_b = message.content) == null ? void 0 : _b.trim();
    const contextLine = formatContextLine(message);
    const userPayload = contextLine ? content ? `${contextLine}

${content}` : contextLine : content;
    lines.push(userPayload ? `${role}: ${userPayload}` : `${role}:`);
    if (message.role === "assistant") {
      const thinkingLines = formatThinkingBlocks(message);
      if (thinkingLines.length > 0) {
        lines.push(...thinkingLines);
      }
    }
    if (message.role === "assistant" && ((_c = message.toolCalls) == null ? void 0 : _c.length)) {
      const toolLines = message.toolCalls.map((tc) => formatToolCallForContext(tc)).filter(Boolean);
      if (toolLines.length > 0) {
        lines.push(...toolLines);
      }
    }
    parts.push(lines.join("\n"));
  }
  return parts.join("\n\n");
}
function getLastUserMessage(messages) {
  for (let i = messages.length - 1; i >= 0; i--) {
    if (messages[i].role === "user") {
      return messages[i];
    }
  }
  return void 0;
}
function buildPromptWithHistoryContext(historyContext, prompt, actualPrompt, conversationHistory) {
  var _a, _b;
  if (!historyContext) return prompt;
  const lastUserMessage = getLastUserMessage(conversationHistory);
  const lastUserQuery = (_b = lastUserMessage == null ? void 0 : lastUserMessage.displayContent) != null ? _b : extractUserQuery((_a = lastUserMessage == null ? void 0 : lastUserMessage.content) != null ? _a : "");
  const currentUserQuery = extractUserQuery(actualPrompt);
  const shouldAppendPrompt = !lastUserMessage || lastUserQuery.trim() !== currentUserQuery.trim();
  return shouldAppendPrompt ? `${historyContext}

User: ${prompt}` : historyContext;
}

// src/core/sdk/selectModelUsage.ts
function selectModelUsage(usageByModel, messageModel, intendedModel) {
  var _a, _b, _c;
  const entries = Object.entries(usageByModel);
  if (entries.length === 0) return null;
  if (messageModel && usageByModel[messageModel]) {
    return { modelName: messageModel, usage: usageByModel[messageModel] };
  }
  if (intendedModel && usageByModel[intendedModel]) {
    return { modelName: intendedModel, usage: usageByModel[intendedModel] };
  }
  let bestEntry = null;
  let maxTokens = -1;
  for (const [modelName, usage] of entries) {
    const contextTokens = ((_a = usage.inputTokens) != null ? _a : 0) + ((_b = usage.cacheCreationInputTokens) != null ? _b : 0) + ((_c = usage.cacheReadInputTokens) != null ? _c : 0);
    if (contextTokens > maxTokens) {
      maxTokens = contextTokens;
      bestEntry = { modelName, usage };
    }
  }
  return bestEntry;
}

// src/core/sdk/transformSDKMessage.ts
function* transformSDKMessage(message, options) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  const parentToolUseId = message.type === "result" ? null : (_a = message.parent_tool_use_id) != null ? _a : null;
  switch (message.type) {
    case "system":
      if (message.subtype === "init" && message.session_id) {
        yield { type: "session_init", sessionId: message.session_id };
      }
      break;
    case "assistant":
      if (((_b = message.message) == null ? void 0 : _b.content) && Array.isArray(message.message.content)) {
        for (const block of message.message.content) {
          if (block.type === "thinking" && block.thinking) {
            yield { type: "thinking", content: block.thinking, parentToolUseId };
          } else if (block.type === "text" && block.text) {
            yield { type: "text", content: block.text, parentToolUseId };
          } else if (block.type === "tool_use") {
            yield {
              type: "tool_use",
              id: block.id || `tool-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
              name: block.name || "unknown",
              input: block.input || {},
              parentToolUseId
            };
          }
        }
      }
      break;
    case "user":
      if (message._blocked && message._blockReason) {
        yield {
          type: "blocked",
          content: message._blockReason
        };
        break;
      }
      if (message.tool_use_result !== void 0 && message.parent_tool_use_id) {
        yield {
          type: "tool_result",
          id: message.parent_tool_use_id,
          content: typeof message.tool_use_result === "string" ? message.tool_use_result : JSON.stringify(message.tool_use_result, null, 2),
          isError: false,
          parentToolUseId
        };
      }
      if (((_c = message.message) == null ? void 0 : _c.content) && Array.isArray(message.message.content)) {
        for (const block of message.message.content) {
          if (block.type === "tool_result") {
            yield {
              type: "tool_result",
              id: block.tool_use_id || message.parent_tool_use_id || "",
              content: typeof block.content === "string" ? block.content : JSON.stringify(block.content, null, 2),
              isError: block.is_error || false,
              parentToolUseId
            };
          }
        }
      }
      break;
    case "stream_event": {
      const event = message.event;
      if ((event == null ? void 0 : event.type) === "content_block_start" && ((_d = event.content_block) == null ? void 0 : _d.type) === "tool_use") {
        yield {
          type: "tool_use",
          id: event.content_block.id || `tool-${Date.now()}`,
          name: event.content_block.name || "unknown",
          input: event.content_block.input || {},
          parentToolUseId
        };
      } else if ((event == null ? void 0 : event.type) === "content_block_start" && ((_e = event.content_block) == null ? void 0 : _e.type) === "thinking") {
        if (event.content_block.thinking) {
          yield { type: "thinking", content: event.content_block.thinking, parentToolUseId };
        }
      } else if ((event == null ? void 0 : event.type) === "content_block_start" && ((_f = event.content_block) == null ? void 0 : _f.type) === "text") {
        if (event.content_block.text) {
          yield { type: "text", content: event.content_block.text, parentToolUseId };
        }
      } else if ((event == null ? void 0 : event.type) === "content_block_delta") {
        if (((_g = event.delta) == null ? void 0 : _g.type) === "thinking_delta" && event.delta.thinking) {
          yield { type: "thinking", content: event.delta.thinking, parentToolUseId };
        } else if (((_h = event.delta) == null ? void 0 : _h.type) === "text_delta" && event.delta.text) {
          yield { type: "text", content: event.delta.text, parentToolUseId };
        }
      }
      break;
    }
    case "result": {
      if (parentToolUseId) {
        break;
      }
      const usageByModel = message.modelUsage;
      if (usageByModel) {
        const selected = selectModelUsage(usageByModel, message.model, options == null ? void 0 : options.intendedModel);
        if (selected && selected.usage.contextWindow && selected.usage.contextWindow > 0) {
          const { modelName, usage } = selected;
          const inputTokens = (_i = usage.inputTokens) != null ? _i : 0;
          const cacheCreationInputTokens = (_j = usage.cacheCreationInputTokens) != null ? _j : 0;
          const cacheReadInputTokens = (_k = usage.cacheReadInputTokens) != null ? _k : 0;
          const contextTokens = inputTokens + cacheCreationInputTokens + cacheReadInputTokens;
          const percentage = Math.min(100, Math.max(0, Math.round(contextTokens / usage.contextWindow * 100)));
          const usageInfo = {
            model: modelName,
            inputTokens,
            cacheCreationInputTokens,
            cacheReadInputTokens,
            contextWindow: usage.contextWindow,
            contextTokens,
            percentage
          };
          yield { type: "usage", usage: usageInfo };
        }
      }
      break;
    }
    case "error":
      if (message.error) {
        yield { type: "error", content: message.error };
      }
      break;
  }
}

// src/core/sdk/typeGuards.ts
function isSessionInitEvent(event) {
  return event.type === "session_init";
}
function isStreamChunk(event) {
  return event.type !== "session_init";
}

// src/core/security/ApprovalManager.ts
function getActionPattern(toolName, input) {
  switch (toolName) {
    case TOOL_BASH:
      return typeof input.command === "string" ? input.command.trim() : "";
    case TOOL_READ:
    case TOOL_WRITE:
    case TOOL_EDIT:
      return input.file_path || "*";
    case TOOL_NOTEBOOK_EDIT:
      return input.notebook_path || input.file_path || "*";
    case TOOL_GLOB:
      return input.pattern || "*";
    case TOOL_GREP:
      return input.pattern || "*";
    default:
      return JSON.stringify(input);
  }
}
function generatePermissionRule(toolName, input) {
  const pattern = getActionPattern(toolName, input);
  if (!pattern || pattern === "*" || pattern.startsWith("{")) {
    return createPermissionRule(toolName);
  }
  return createPermissionRule(`${toolName}(${pattern})`);
}
function getActionDescription(toolName, input) {
  switch (toolName) {
    case TOOL_BASH:
      return `Run command: ${input.command}`;
    case TOOL_READ:
      return `Read file: ${input.file_path}`;
    case TOOL_WRITE:
      return `Write to file: ${input.file_path}`;
    case TOOL_EDIT:
      return `Edit file: ${input.file_path}`;
    case TOOL_GLOB:
      return `Search files matching: ${input.pattern}`;
    case TOOL_GREP:
      return `Search content matching: ${input.pattern}`;
    default:
      return `${toolName}: ${JSON.stringify(input)}`;
  }
}
function matchesRulePattern(toolName, actionPattern, rulePattern) {
  if (!rulePattern) return true;
  const normalizedAction = normalizeMatchPattern(actionPattern);
  const normalizedRule = normalizeMatchPattern(rulePattern);
  if (normalizedRule === "*") return true;
  if (normalizedAction === normalizedRule) return true;
  if (toolName === TOOL_BASH) {
    if (normalizedRule.endsWith("*")) {
      const prefix = normalizedRule.slice(0, -1);
      return normalizedAction.startsWith(prefix);
    }
    if (normalizedRule.endsWith(":*")) {
      const prefix = normalizedRule.slice(0, -2);
      return normalizedAction.startsWith(prefix);
    }
    return false;
  }
  if (toolName === TOOL_READ || toolName === TOOL_WRITE || toolName === TOOL_EDIT || toolName === TOOL_NOTEBOOK_EDIT) {
    return isPathPrefixMatch(normalizedAction, normalizedRule);
  }
  if (normalizedAction.startsWith(normalizedRule)) return true;
  return false;
}
function normalizeMatchPattern(value) {
  return value.replace(/\\/g, "/");
}
function isPathPrefixMatch(actionPath, approvedPath) {
  if (!actionPath.startsWith(approvedPath)) {
    return false;
  }
  if (approvedPath.endsWith("/")) {
    return true;
  }
  if (actionPath.length === approvedPath.length) {
    return true;
  }
  return actionPath.charAt(approvedPath.length) === "/";
}
function matchesAnyRule(rules, toolName, actionPattern) {
  if (!rules || rules.length === 0) return false;
  return rules.some((rule) => {
    const { tool, pattern } = parseCCPermissionRule(rule);
    if (tool !== toolName) return false;
    return matchesRulePattern(toolName, actionPattern, pattern);
  });
}
var ApprovalManager = class {
  constructor(getPermissions) {
    this.sessionPermissions = [];
    this.addAllowRuleCallback = null;
    this.addDenyRuleCallback = null;
    this.getPermissions = getPermissions;
  }
  /**
   * Set callback for adding rules to allow list.
   */
  setAddAllowRuleCallback(callback) {
    this.addAllowRuleCallback = callback;
  }
  /**
   * Set callback for adding rules to deny list.
   */
  setAddDenyRuleCallback(callback) {
    this.addDenyRuleCallback = callback;
  }
  /**
   * Check permission for an action.
   *
   * Priority (highest to lowest):
   * 1. Session deny (ephemeral, this session only)
   * 2. Permanent deny (persisted in settings.json)
   * 3. Permanent ask (forces prompt even if allow rule exists)
   * 4. Session allow (ephemeral, this session only)
   * 5. Permanent allow (persisted in settings.json)
   * 6. Fallback to ask (no matching rule found)
   *
   * @returns 'allow' | 'deny' | 'ask'
   */
  checkPermission(toolName, input) {
    const actionPattern = getActionPattern(toolName, input);
    const permissions = this.getPermissions();
    const sessionDenied = this.sessionPermissions.some(
      (sp) => sp.type === "deny" && this.matchesSessionPermission(sp.rule, toolName, actionPattern)
    );
    if (sessionDenied) return "deny";
    if (matchesAnyRule(permissions.deny, toolName, actionPattern)) {
      return "deny";
    }
    if (matchesAnyRule(permissions.ask, toolName, actionPattern)) {
      return "ask";
    }
    const sessionAllowed = this.sessionPermissions.some(
      (sp) => sp.type === "allow" && this.matchesSessionPermission(sp.rule, toolName, actionPattern)
    );
    if (sessionAllowed) return "allow";
    if (matchesAnyRule(permissions.allow, toolName, actionPattern)) {
      return "allow";
    }
    return "ask";
  }
  /**
   * Legacy method for compatibility.
   * @deprecated Use checkPermission instead
   */
  isActionApproved(toolName, input) {
    return this.checkPermission(toolName, input) === "allow";
  }
  /**
   * Check if a session permission matches an action.
   */
  matchesSessionPermission(rule, toolName, actionPattern) {
    const { tool, pattern } = parseCCPermissionRule(rule);
    if (tool !== toolName) return false;
    return matchesRulePattern(toolName, actionPattern, pattern);
  }
  /**
   * Approve an action (add to allow list).
   * @throws Error if scope is 'always' but no callback is registered
   */
  async approveAction(toolName, input, scope) {
    const rule = generatePermissionRule(toolName, input);
    if (scope === "session") {
      this.sessionPermissions.push({ rule, type: "allow" });
    } else {
      if (!this.addAllowRuleCallback) {
        throw new Error("[ApprovalManager] Cannot persist allow rule: addAllowRuleCallback not registered");
      }
      await this.addAllowRuleCallback(rule);
    }
  }
  /**
   * Deny an action (add to deny list).
   * @throws Error if scope is 'always' but no callback is registered
   */
  async denyAction(toolName, input, scope) {
    const rule = generatePermissionRule(toolName, input);
    if (scope === "session") {
      this.sessionPermissions.push({ rule, type: "deny" });
    } else {
      if (!this.addDenyRuleCallback) {
        throw new Error("[ApprovalManager] Cannot persist deny rule: addDenyRuleCallback not registered");
      }
      await this.addDenyRuleCallback(rule);
    }
  }
  /**
   * Clear session-scoped permissions.
   */
  clearSessionPermissions() {
    this.sessionPermissions = [];
  }
  /**
   * Get session-scoped permissions (for testing/debugging).
   */
  getSessionPermissions() {
    return [...this.sessionPermissions];
  }
};

// src/core/agent/types.ts
var MESSAGE_CHANNEL_CONFIG = {
  MAX_QUEUED_MESSAGES: 8,
  MAX_MERGED_CHARS: 12e3
};
function createResponseHandler(options) {
  let _sawStreamText = false;
  let _sawAnyChunk = false;
  return {
    id: options.id,
    onChunk: options.onChunk,
    onDone: options.onDone,
    onError: options.onError,
    get sawStreamText() {
      return _sawStreamText;
    },
    get sawAnyChunk() {
      return _sawAnyChunk;
    },
    markStreamTextSeen() {
      _sawStreamText = true;
    },
    resetStreamText() {
      _sawStreamText = false;
    },
    markChunkSeen() {
      _sawAnyChunk = true;
    }
  };
}
var UNSUPPORTED_SDK_TOOLS = [
  "AskUserQuestion",
  "EnterPlanMode",
  "ExitPlanMode"
];
function isTurnCompleteMessage(message) {
  const messageType = message.type;
  return messageType === "result" || messageType === "error";
}
function computeSystemPromptKey(settings11) {
  const parts = [
    settings11.mediaFolder || "",
    settings11.customPrompt || "",
    (settings11.allowedExportPaths || []).sort().join("|"),
    settings11.vaultPath || ""
    // Note: hasEditorContext is per-message, not tracked here
  ];
  return parts.join("::");
}

// src/core/agent/MessageChannel.ts
var MessageChannel = class {
  constructor(onWarning = () => {
  }) {
    this.queue = [];
    this.turnActive = false;
    this.closed = false;
    this.resolveNext = null;
    this.currentSessionId = null;
    this.onWarning = onWarning;
  }
  /** Set the session ID for outgoing messages. */
  setSessionId(sessionId) {
    this.currentSessionId = sessionId;
  }
  /** Check if a turn is currently active. */
  isTurnActive() {
    return this.turnActive;
  }
  /** Check if the channel is closed. */
  isClosed() {
    return this.closed;
  }
  /**
   * Enqueue a message. If a turn is active:
   * - Text-only: merge with queued text (up to MAX_MERGED_CHARS)
   * - With attachments: replace any existing queued attachment (one at a time)
   */
  enqueue(message) {
    if (this.closed) {
      throw new Error("MessageChannel is closed");
    }
    const hasAttachments = this.messageHasAttachments(message);
    if (!this.turnActive) {
      if (this.resolveNext) {
        this.turnActive = true;
        const resolve3 = this.resolveNext;
        this.resolveNext = null;
        resolve3({ value: message, done: false });
      } else {
        if (this.queue.length >= MESSAGE_CHANNEL_CONFIG.MAX_QUEUED_MESSAGES) {
          this.onWarning(`[MessageChannel] Queue full (${MESSAGE_CHANNEL_CONFIG.MAX_QUEUED_MESSAGES}), dropping newest`);
          return;
        }
        if (hasAttachments) {
          this.queue.push({ type: "attachment", message });
        } else {
          this.queue.push({ type: "text", content: this.extractTextContent(message) });
        }
      }
      return;
    }
    if (hasAttachments) {
      const existingIdx = this.queue.findIndex((m) => m.type === "attachment");
      if (existingIdx >= 0) {
        this.queue[existingIdx] = { type: "attachment", message };
        this.onWarning("[MessageChannel] Attachment message replaced (only one can be queued)");
      } else {
        this.queue.push({ type: "attachment", message });
      }
      return;
    }
    const textContent = this.extractTextContent(message);
    const existingTextIdx = this.queue.findIndex((m) => m.type === "text");
    if (existingTextIdx >= 0) {
      const existing = this.queue[existingTextIdx];
      const mergedContent = existing.content + "\n\n" + textContent;
      if (mergedContent.length > MESSAGE_CHANNEL_CONFIG.MAX_MERGED_CHARS) {
        this.onWarning(`[MessageChannel] Merged content exceeds ${MESSAGE_CHANNEL_CONFIG.MAX_MERGED_CHARS} chars, dropping newest`);
        return;
      }
      existing.content = mergedContent;
    } else {
      if (this.queue.length >= MESSAGE_CHANNEL_CONFIG.MAX_QUEUED_MESSAGES) {
        this.onWarning(`[MessageChannel] Queue full (${MESSAGE_CHANNEL_CONFIG.MAX_QUEUED_MESSAGES}), dropping newest`);
        return;
      }
      this.queue.push({ type: "text", content: textContent });
    }
  }
  /** Signal that the current turn has completed. */
  onTurnComplete() {
    this.turnActive = false;
    if (this.queue.length > 0 && this.resolveNext) {
      const pending = this.queue.shift();
      this.turnActive = true;
      const resolve3 = this.resolveNext;
      this.resolveNext = null;
      resolve3({ value: this.pendingToMessage(pending), done: false });
    }
  }
  /** Close the channel. */
  close() {
    this.closed = true;
    this.queue = [];
    if (this.resolveNext) {
      const resolve3 = this.resolveNext;
      this.resolveNext = null;
      resolve3({ value: void 0, done: true });
    }
  }
  /** Reset the channel for reuse. */
  reset() {
    this.queue = [];
    this.turnActive = false;
    this.closed = false;
    this.resolveNext = null;
  }
  /** Get the number of queued messages. */
  getQueueLength() {
    return this.queue.length;
  }
  /** AsyncIterable implementation. */
  [Symbol.asyncIterator]() {
    return {
      next: () => {
        if (this.closed) {
          return Promise.resolve({ value: void 0, done: true });
        }
        if (this.queue.length > 0 && !this.turnActive) {
          const pending = this.queue.shift();
          this.turnActive = true;
          return Promise.resolve({ value: this.pendingToMessage(pending), done: false });
        }
        return new Promise((resolve3) => {
          this.resolveNext = resolve3;
        });
      }
    };
  }
  messageHasAttachments(message) {
    var _a;
    if (!((_a = message.message) == null ? void 0 : _a.content)) return false;
    if (typeof message.message.content === "string") return false;
    return message.message.content.some((block) => block.type === "image");
  }
  extractTextContent(message) {
    var _a;
    if (!((_a = message.message) == null ? void 0 : _a.content)) return "";
    if (typeof message.message.content === "string") return message.message.content;
    return message.message.content.filter((block) => block.type === "text").map((block) => block.text).join("\n\n");
  }
  pendingToMessage(pending) {
    if (pending.type === "attachment") {
      return pending.message;
    }
    return {
      type: "user",
      message: {
        role: "user",
        content: pending.content
      },
      parent_tool_use_id: null,
      session_id: this.currentSessionId || ""
    };
  }
};

// src/utils/date.ts
function getTodayDate() {
  const now = /* @__PURE__ */ new Date();
  const readable = now.toLocaleDateString("en-US", {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric"
  });
  const iso = now.toISOString().split("T")[0];
  return `${readable} (${iso})`;
}

// src/core/prompts/mainAgent.ts
function getBaseSystemPrompt(vaultPath) {
  const vaultInfo = vaultPath ? `

Vault absolute path: ${vaultPath}` : "";
  return `## Time Context

- **Current Date**: ${getTodayDate()}
- **Knowledge Status**: You possess extensive internal knowledge up to your training cutoff. You do not know the exact date of your cutoff, but you must assume that your internal weights are static and "past," while the Current Date is "present."

## Identity & Role

You are **Claudian**, an expert AI assistant specialized in Obsidian vault management, knowledge organization, and code analysis. You operate directly inside the user's Obsidian vault.

**Core Principles:**
1.  **Obsidian Native**: You understand Markdown, YAML frontmatter, Wiki-links, and the "second brain" philosophy.
2.  **Safety First**: You never overwrite data without understanding context. You always use relative paths.
3.  **Proactive Thinking**: You do not just execute; you *plan* and *verify*. You anticipate potential issues (like broken links or missing files).
4.  **Clarity**: Your changes are precise, minimizing "noise" in the user's notes or code.

The current working directory is the user's vault root.${vaultInfo}

## Path Rules (MUST FOLLOW)

| Location | Access | Path Format | Example |
|----------|--------|-------------|---------|
| **Vault** | Read/Write | Relative from vault root | \`notes/my-note.md\`, \`.\` |
| **Export paths** | Write-only | \`~\` or absolute | \`~/Desktop/output.docx\` |
| **External contexts** | Full access | Absolute path | \`/Users/me/Workspace/file.ts\` |

**Vault files** (default):
- \u2713 Correct: \`notes/my-note.md\`, \`my-note.md\`, \`folder/subfolder/file.md\`, \`.\`
- \u2717 WRONG: \`/notes/my-note.md\`, \`${vaultPath || "/absolute/path"}/file.md\`
- A leading slash or absolute path will FAIL for vault operations.

**Path specificity**: When paths overlap, the **more specific path wins**:
- If \`~/Desktop\` is export (write-only) and \`~/Desktop/Workspace\` is external context (full access)
- \u2192 Files in \`~/Desktop/Workspace\` have full read/write access
- \u2192 Files directly in \`~/Desktop\` remain write-only

## User Message Format

User messages use XML tags for structured context:

\`\`\`xml
<current_note>
path/to/note.md
</current_note>

<query>
User's question or request here
</query>
\`\`\`

- \`<current_note>\`: The note the user is currently viewing/focused on. Read this to understand context. Only appears when the focused note changes.
- \`<query>\`: The user's actual question or request.
- \`@filename.md\`: Files mentioned with @ in the query. Read these files when referenced.

## Obsidian Context

- **Structure**: Files are Markdown (.md). Folders organize content.
- **Frontmatter**: YAML at the top of files (metadata). Respect existing fields.
- **Links**: Internal Wiki-links \`[[note-name]]\` or \`[[folder/note-name]]\`. External links \`[text](url)\`.
- **Tags**: #tag-name for categorization.
- **Dataview**: You may encounter Dataview queries (in \`\`\`dataview\`\`\` blocks). Do not break them unless asked.
- **Vault Config**: \`.obsidian/\` contains internal config. Touch only if you know what you are doing.

**File References in Responses:**
When mentioning vault files in your responses, use wikilink format so users can click to open them:
- \u2713 Use: \`[[folder/note.md]]\` or \`[[note]]\`
- \u2717 Avoid: plain paths like \`folder/note.md\` (not clickable)

**Image embeds:** Use \`![[image.png]]\` to display images directly in chat. Images render visually, making it easy to show diagrams, screenshots, or visual content you're discussing.

Examples:
- "I found your notes in [[30.areas/finance/Investment lessons/2024.Current trading lessons.md]]"
- "See [[daily notes/2024-01-15]] for more details"
- "Here's the diagram: ![[attachments/architecture.png]]"

## Tool Usage Guidelines

Standard tools (Read, Write, Edit, Glob, Grep, LS, Bash, WebSearch, WebFetch, Skills) work as expected.

**Thinking Process:**
Before taking action, explicitly THINK about:
1.  **Context**: Do I have enough information? (Use Read/Search if not).
2.  **Impact**: What will this change affect? (Links, other files).
3.  **Plan**: What are the steps? (Use TodoWrite for >2 steps).

**Tool-Specific Rules:**
- **Read**:
    - Always Read a file before Editing it.
    - Read can view images (PNG, JPG, GIF, WebP) for visual analysis.
- **Edit**:
    - Requires **EXACT** \`old_string\` match including whitespace/indentation.
    - If Edit fails, Read the file again to check the current content.
- **Bash**:
    - Runs with vault as working directory.
    - **Prefer** Read/Write/Edit over shell commands for file operations (safer).
    - **Stdout-capable tools** (pandoc, jq, imagemagick): Prefer piping output directly instead of creating temporary files when the result will be used immediately.
    - Use BashOutput/KillShell to manage background processes.
- **LS**: Uses "." for vault root.
- **WebFetch**: For text/HTML/PDF only. Avoid binaries.

### WebSearch

Use WebSearch strictly according to the following logic:

1.  **Static/Historical**: Rely on internal knowledge for established facts, history, or older code libraries.
2.  **Dynamic/Recent**: **MUST** search for:
    - "Latest" news, versions, docs.
    - Events in the current/previous year.
    - Volatile data (prices, weather).
3.  **Date Awareness**: If user says "yesterday", calculate the date relative to **Current Date**.
4.  **Ambiguity**: If unsure if knowledge is outdated, SEARCH.

### Task (Subagents)

Spawn subagents for complex multi-step tasks. Parameters: \`prompt\`, \`description\`, \`subagent_type\`, \`run_in_background\`.

**CRITICAL - Subagent Path Rules:**
- Subagents inherit the vault as their working directory.
- Reference files using **RELATIVE** paths.
- NEVER use absolute paths in subagent prompts.

**When to use:**
- Parallelizable work (main + subagent or multiple subagents)
- Preserve main context budget for sub-tasks
- Offload contained tasks while continuing other work

**Sync Mode (Default - \`run_in_background=false\`)**:
- Runs inline, result returned directly.
- **DEFAULT** to this unless explicitly asked or the task is very long-running.

**Async Mode (\`run_in_background=true\`)**:
- Use ONLY when explicitly requested or task is clearly long-running.
- Returns \`agent_id\` immediately.
- **Must retrieve result** with \`AgentOutputTool\` (poll with block=false, then block=true).
- Never end response without retrieving async results.

**Async workflow:**
1. Launch: \`Task prompt="..." run_in_background=true\` \u2192 get \`agent_id\`
2. Check immediately: \`AgentOutputTool agentId="..." block=false\`
3. Poll while working: \`AgentOutputTool agentId="..." block=false\`
4. When idle: \`AgentOutputTool agentId="..." block=true\` (wait for completion)
5. Report result to user

**Critical:** Never end response without retrieving async task results.

### TodoWrite

Track task progress. Parameter: \`todos\` (array of {content, status, activeForm}).
- Statuses: \`pending\`, \`in_progress\`, \`completed\`
- \`content\`: imperative ("Fix the bug")
- \`activeForm\`: present continuous ("Fixing the bug")

**Use for:** Tasks with 3+ steps, multi-file changes, complex operations.
Use proactively for any task meeting these criteria to keep progress visible.

**Workflow:**
1.  **Plan**: Create the todo list at the start.
2.  **Execute**: Mark \`in_progress\` -> do work -> Mark \`completed\`.
3.  **Update**: If new tasks arise, add them.

**Example:** User asks "refactor auth and add tests"
\`\`\`
[
  {content: "Analyze auth module", status: "in_progress", activeForm: "Analyzing auth module"},
  {content: "Refactor auth code", status: "pending", activeForm: "Refactoring auth code"},
  {content: "Add unit tests", status: "pending", activeForm: "Adding unit tests"}
]
\`\`\`

### Skills

Reusable capability modules. Use the \`Skill\` tool to invoke them when their description matches the user's need.

## Editor Selection

User messages may include an \`<editor_selection>\` tag showing text the user selected:

\`\`\`xml
<editor_selection path="path/to/file.md">
selected text here
possibly multiple lines
</editor_selection>
\`\`\`

**When present:** The user selected this text before sending their message. Use this context to understand what they're referring to.`;
}
function getImageInstructions(mediaFolder) {
  const folder = mediaFolder.trim();
  const mediaPath = folder ? "./" + folder : ".";
  const examplePath = folder ? folder + "/" : "";
  return `

## Embedded Images in Notes

**Proactive image reading**: When reading a note with embedded images, read them alongside text for full context. Images often contain critical information (diagrams, screenshots, charts).

**Local images** (\`![[image.jpg]]\`):
- Located in media folder: \`${mediaPath}\`
- Read with: \`Read file_path="${examplePath}image.jpg"\`
- Formats: PNG, JPG/JPEG, GIF, WebP

**External images** (\`![alt](url)\`):
- WebFetch does NOT support images
- Download to media folder \u2192 Read \u2192 Replace URL with wiki-link:

\`\`\`bash
# Download to media folder with descriptive name
mkdir -p ${mediaPath}
img_name="downloaded_\\$(date +%s).png"
curl -sfo "${examplePath}$img_name" 'URL'
\`\`\`

Then read with \`Read file_path="${examplePath}$img_name"\`, and replace the markdown link \`![alt](url)\` with \`![[${examplePath}$img_name]]\` in the note.

**Benefits**: Image becomes a permanent vault asset, works offline, and uses Obsidian's native embed syntax.`;
}
function getExportInstructions(allowedExportPaths) {
  if (!allowedExportPaths || allowedExportPaths.length === 0) {
    return "";
  }
  const uniquePaths = Array.from(new Set(allowedExportPaths.map((p) => p.trim()).filter(Boolean)));
  if (uniquePaths.length === 0) {
    return "";
  }
  const formattedPaths = uniquePaths.map((p) => `- ${p}`).join("\n");
  return `

## Allowed Export Paths

Write-only destinations outside the vault:

${formattedPaths}

Examples:
\`\`\`bash
pandoc ./note.md -o ~/Desktop/note.docx   # Direct export
pandoc ./note.md | head -100              # Pipe to stdout (no temp file)
cp ./note.md ~/Desktop/note.md
\`\`\``;
}
function buildSystemPrompt(settings11 = {}) {
  var _a;
  let prompt = getBaseSystemPrompt(settings11.vaultPath);
  prompt += getImageInstructions(settings11.mediaFolder || "");
  prompt += getExportInstructions(settings11.allowedExportPaths || []);
  if ((_a = settings11.customPrompt) == null ? void 0 : _a.trim()) {
    prompt += "\n\n## Custom Instructions\n\n" + settings11.customPrompt.trim();
  }
  return prompt;
}

// src/core/agent/QueryOptionsBuilder.ts
var QueryOptionsBuilder = class _QueryOptionsBuilder {
  /**
   * Checks if the persistent query needs to be restarted based on configuration changes.
   *
   * Compares current config against new config to detect changes that require restart.
   * Some changes (model, thinking tokens) can be updated dynamically; others require restart.
   */
  static needsRestart(currentConfig, newConfig) {
    if (!currentConfig) return true;
    if (currentConfig.systemPromptKey !== newConfig.systemPromptKey) return true;
    if (currentConfig.disallowedToolsKey !== newConfig.disallowedToolsKey) return true;
    if (currentConfig.pluginsKey !== newConfig.pluginsKey) return true;
    if (currentConfig.settingSources !== newConfig.settingSources) return true;
    if (currentConfig.claudeCliPath !== newConfig.claudeCliPath) return true;
    if (currentConfig.show1MModel !== newConfig.show1MModel) return true;
    const oldExport = [...currentConfig.allowedExportPaths || []].sort().join("|");
    const newExport = [...newConfig.allowedExportPaths || []].sort().join("|");
    if (oldExport !== newExport) return true;
    const oldExternal = [...currentConfig.externalContextPaths || []].sort().join("|");
    const newExternal = [...newConfig.externalContextPaths || []].sort().join("|");
    if (oldExternal !== newExternal) return true;
    return false;
  }
  /**
   * Builds configuration object for tracking changes.
   *
   * Used to detect when the persistent query needs to be restarted
   * due to configuration changes that cannot be applied dynamically.
   *
   * @param ctx - The query options context
   * @param externalContextPaths - External context paths for additionalDirectories
   */
  static buildPersistentQueryConfig(ctx, externalContextPaths) {
    var _a;
    const systemPromptSettings = {
      mediaFolder: ctx.settings.mediaFolder,
      customPrompt: ctx.settings.systemPrompt,
      allowedExportPaths: ctx.settings.allowedExportPaths,
      vaultPath: ctx.vaultPath
    };
    const budgetSetting = ctx.settings.thinkingBudget;
    const budgetConfig = THINKING_BUDGETS.find((b) => b.value === budgetSetting);
    const thinkingTokens = (_a = budgetConfig == null ? void 0 : budgetConfig.tokens) != null ? _a : null;
    const allDisallowedTools = ctx.mcpManager.getAllDisallowedMcpTools();
    const disallowedToolsKey = allDisallowedTools.join("|");
    const pluginsKey = ctx.pluginManager.getPluginsKey();
    return {
      model: ctx.settings.model,
      thinkingTokens: thinkingTokens && thinkingTokens > 0 ? thinkingTokens : null,
      permissionMode: ctx.settings.permissionMode,
      systemPromptKey: computeSystemPromptKey(systemPromptSettings),
      disallowedToolsKey,
      mcpServersKey: "",
      // Dynamic via setMcpServers, not tracked for restart
      pluginsKey,
      externalContextPaths: externalContextPaths || [],
      allowedExportPaths: ctx.settings.allowedExportPaths,
      settingSources: ctx.settings.loadUserClaudeSettings ? "user,project" : "project",
      claudeCliPath: ctx.cliPath,
      show1MModel: ctx.settings.show1MModel
    };
  }
  /**
   * Builds SDK options for the persistent query.
   *
   * Persistent queries maintain a long-running connection to Claude,
   * eliminating cold-start latency for follow-up messages.
   */
  static buildPersistentQueryOptions(ctx) {
    const permissionMode = ctx.settings.permissionMode;
    const resolved = resolveModelWithBetas(ctx.settings.model, ctx.settings.show1MModel);
    const systemPrompt = buildSystemPrompt({
      mediaFolder: ctx.settings.mediaFolder,
      customPrompt: ctx.settings.systemPrompt,
      allowedExportPaths: ctx.settings.allowedExportPaths,
      vaultPath: ctx.vaultPath,
      hasEditorContext: true
      // Always include editor selection instructions
    });
    const options = {
      cwd: ctx.vaultPath,
      systemPrompt,
      model: resolved.model,
      abortController: ctx.abortController,
      pathToClaudeCodeExecutable: ctx.cliPath,
      settingSources: ctx.settings.loadUserClaudeSettings ? ["user", "project"] : ["project"],
      env: {
        ...process.env,
        ...ctx.customEnv,
        PATH: ctx.enhancedPath
      },
      includePartialMessages: true
      // Enable streaming
    };
    if (resolved.betas) {
      options.betas = resolved.betas;
    }
    const allDisallowedTools = [
      ...ctx.mcpManager.getAllDisallowedMcpTools(),
      ...UNSUPPORTED_SDK_TOOLS
    ];
    options.disallowedTools = allDisallowedTools;
    const pluginConfigs = ctx.pluginManager.getActivePluginConfigs();
    if (pluginConfigs.length > 0) {
      options.plugins = pluginConfigs;
    }
    _QueryOptionsBuilder.applyPermissionMode(options, permissionMode, ctx.canUseTool);
    _QueryOptionsBuilder.applyThinkingBudget(options, ctx.settings.thinkingBudget);
    options.hooks = ctx.hooks;
    if (ctx.resumeSessionId) {
      options.resume = ctx.resumeSessionId;
    }
    if (ctx.externalContextPaths && ctx.externalContextPaths.length > 0) {
      options.additionalDirectories = ctx.externalContextPaths;
    }
    return options;
  }
  /**
   * Builds SDK options for a cold-start query.
   *
   * Cold-start queries are used for:
   * - Inline edit (separate context)
   * - Title generation (lightweight)
   * - Session recovery (interrupted or expired sessions)
   * - When persistent query is not available
   * - When forceColdStart option is set
   */
  static buildColdStartQueryOptions(ctx) {
    var _a;
    const permissionMode = ctx.settings.permissionMode;
    const selectedModel = (_a = ctx.modelOverride) != null ? _a : ctx.settings.model;
    const resolved = resolveModelWithBetas(selectedModel, ctx.settings.show1MModel);
    const systemPrompt = buildSystemPrompt({
      mediaFolder: ctx.settings.mediaFolder,
      customPrompt: ctx.settings.systemPrompt,
      allowedExportPaths: ctx.settings.allowedExportPaths,
      vaultPath: ctx.vaultPath,
      hasEditorContext: ctx.hasEditorContext
    });
    const options = {
      cwd: ctx.vaultPath,
      systemPrompt,
      model: resolved.model,
      abortController: ctx.abortController,
      pathToClaudeCodeExecutable: ctx.cliPath,
      // Load project settings. Optionally load user settings if enabled.
      // Note: User settings (~/.claude/settings.json) may contain permission rules
      // that bypass Claudian's permission system. Skills from ~/.claude/skills/
      // are still discovered regardless (not in settings.json).
      settingSources: ctx.settings.loadUserClaudeSettings ? ["user", "project"] : ["project"],
      env: {
        ...process.env,
        ...ctx.customEnv,
        PATH: ctx.enhancedPath
      },
      includePartialMessages: true
      // Enable streaming
    };
    if (resolved.betas) {
      options.betas = resolved.betas;
    }
    const mcpMentions = ctx.mcpMentions || /* @__PURE__ */ new Set();
    const uiEnabledServers = ctx.enabledMcpServers || /* @__PURE__ */ new Set();
    const combinedMentions = /* @__PURE__ */ new Set([...mcpMentions, ...uiEnabledServers]);
    const mcpServers = ctx.mcpManager.getActiveServers(combinedMentions);
    if (Object.keys(mcpServers).length > 0) {
      options.mcpServers = mcpServers;
    }
    const disallowedMcpTools = ctx.mcpManager.getDisallowedMcpTools(combinedMentions);
    options.disallowedTools = [
      ...disallowedMcpTools,
      ...UNSUPPORTED_SDK_TOOLS
    ];
    const pluginConfigs = ctx.pluginManager.getActivePluginConfigs();
    if (pluginConfigs.length > 0) {
      options.plugins = pluginConfigs;
    }
    _QueryOptionsBuilder.applyPermissionMode(options, permissionMode, ctx.canUseTool);
    options.hooks = ctx.hooks;
    _QueryOptionsBuilder.applyThinkingBudget(options, ctx.settings.thinkingBudget);
    if (ctx.allowedTools !== void 0 && ctx.allowedTools.length > 0) {
      options.tools = ctx.allowedTools;
    }
    if (ctx.sessionId) {
      options.resume = ctx.sessionId;
    }
    if (ctx.externalContextPaths && ctx.externalContextPaths.length > 0) {
      options.additionalDirectories = ctx.externalContextPaths;
    }
    return options;
  }
  /**
   * Gets active MCP servers and their configuration for dynamic updates.
   */
  static getMcpServersConfig(mcpManager, mcpMentions, enabledMcpServers) {
    const mentions = mcpMentions || /* @__PURE__ */ new Set();
    const uiEnabled = enabledMcpServers || /* @__PURE__ */ new Set();
    const combined = /* @__PURE__ */ new Set([...mentions, ...uiEnabled]);
    const servers = mcpManager.getActiveServers(combined);
    return {
      servers,
      key: JSON.stringify(servers)
    };
  }
  // ============================================
  // Private Helpers
  // ============================================
  /**
   * Applies permission mode settings to options.
   *
   * Always sets allowDangerouslySkipPermissions: true to enable dynamic
   * switching between permission modes via setPermissionMode() without
   * requiring a process restart. This mimics Claude Code CLI behavior.
   */
  static applyPermissionMode(options, permissionMode, canUseTool) {
    options.allowDangerouslySkipPermissions = true;
    if (permissionMode === "yolo") {
      options.permissionMode = "bypassPermissions";
    } else {
      options.permissionMode = "default";
      if (canUseTool) {
        options.canUseTool = canUseTool;
      }
    }
  }
  /**
   * Applies thinking budget settings to options.
   */
  static applyThinkingBudget(options, budgetSetting) {
    const budgetConfig = THINKING_BUDGETS.find((b) => b.value === budgetSetting);
    if (budgetConfig && budgetConfig.tokens > 0) {
      options.maxThinkingTokens = budgetConfig.tokens;
    }
  }
};

// src/core/agent/SessionManager.ts
var SessionManager = class {
  constructor() {
    this.state = {
      sessionId: null,
      sessionModel: null,
      pendingSessionModel: null,
      wasInterrupted: false,
      needsHistoryRebuild: false,
      sessionInvalidated: false
    };
  }
  getSessionId() {
    return this.state.sessionId;
  }
  setSessionId(id, defaultModel) {
    this.state.sessionId = id;
    this.state.sessionModel = id ? defaultModel != null ? defaultModel : null : null;
    this.state.needsHistoryRebuild = false;
    this.state.sessionInvalidated = false;
  }
  wasInterrupted() {
    return this.state.wasInterrupted;
  }
  markInterrupted() {
    this.state.wasInterrupted = true;
  }
  clearInterrupted() {
    this.state.wasInterrupted = false;
  }
  setPendingModel(model) {
    this.state.pendingSessionModel = model;
  }
  clearPendingModel() {
    this.state.pendingSessionModel = null;
  }
  /**
   * Captures a session ID from SDK response.
   * Detects mismatch if we had a different session ID before (context lost).
   */
  captureSession(sessionId) {
    const hadSession = this.state.sessionId !== null;
    const isDifferent = this.state.sessionId !== sessionId;
    if (hadSession && isDifferent) {
      this.state.needsHistoryRebuild = true;
    }
    this.state.sessionId = sessionId;
    this.state.sessionModel = this.state.pendingSessionModel;
    this.state.pendingSessionModel = null;
    this.state.sessionInvalidated = false;
  }
  /** Check if history rebuild is needed due to session mismatch. */
  needsHistoryRebuild() {
    return this.state.needsHistoryRebuild;
  }
  /** Clear the history rebuild flag after injecting history. */
  clearHistoryRebuild() {
    this.state.needsHistoryRebuild = false;
  }
  invalidateSession() {
    this.state.sessionId = null;
    this.state.sessionModel = null;
    this.state.sessionInvalidated = true;
  }
  /** Consume the invalidation flag (returns true once). */
  consumeInvalidation() {
    const wasInvalidated = this.state.sessionInvalidated;
    this.state.sessionInvalidated = false;
    return wasInvalidated;
  }
  reset() {
    this.state = {
      sessionId: null,
      sessionModel: null,
      pendingSessionModel: null,
      wasInterrupted: false,
      needsHistoryRebuild: false,
      sessionInvalidated: false
    };
  }
};

// src/core/agent/ClaudianService.ts
var ClaudianService = class {
  // Prevent consumer error restarts during cold-start
  constructor(plugin, mcpManager) {
    this.abortController = null;
    this.approvalCallback = null;
    this.vaultPath = null;
    this.currentExternalContextPaths = [];
    // Modular components
    this.sessionManager = new SessionManager();
    this.ccPermissions = { allow: [], deny: [], ask: [] };
    // ============================================
    // Persistent Query State (Phase 1)
    // ============================================
    this.persistentQuery = null;
    this.messageChannel = null;
    this.queryAbortController = null;
    this.responseHandlers = [];
    this.responseConsumerRunning = false;
    this.shuttingDown = false;
    // Tracked configuration for detecting changes that require restart
    this.currentConfig = null;
    // Current allowed tools for canUseTool enforcement (null = no restriction)
    this.currentAllowedTools = null;
    // Last sent message for crash recovery (Phase 1.3)
    this.lastSentMessage = null;
    this.lastSentQueryOptions = null;
    this.crashRecoveryAttempted = false;
    this.coldStartInProgress = false;
    this.plugin = plugin;
    this.mcpManager = mcpManager;
    this.approvalManager = new ApprovalManager(
      () => this.ccPermissions
    );
    this.approvalManager.setAddAllowRuleCallback(async (rule) => {
      try {
        await this.plugin.storage.addAllowRule(rule);
        await this.loadCCPermissions();
      } catch (e) {
        new import_obsidian2.Notice("Failed to save permission rule");
      }
    });
    this.approvalManager.setAddDenyRuleCallback(async (rule) => {
      try {
        await this.plugin.storage.addDenyRule(rule);
        await this.loadCCPermissions();
      } catch (e) {
        new import_obsidian2.Notice("Failed to save permission rule");
      }
    });
  }
  /**
   * Load CC permissions from storage.
   * Called during initialization and after permission changes.
   */
  async loadCCPermissions() {
    this.ccPermissions = await this.plugin.storage.getPermissions();
  }
  /** Load MCP server configurations from storage. */
  async loadMcpServers() {
    await this.mcpManager.loadServers();
  }
  /** Reload MCP server configurations (call after settings change). */
  async reloadMcpServers() {
    await this.mcpManager.loadServers();
  }
  // ============================================
  // Persistent Query Lifecycle (Phase 1.3)
  // ============================================
  /**
   * Ensures the persistent query is running with current configuration.
   * Unified API that replaces preWarm() and restartPersistentQuery().
   *
   * Behavior:
   * - If not running  start (if paths available)
   * - If running and force=true  close and restart
   * - If running and config changed  close and restart
   * - If running and config unchanged  no-op
   *
   * Note: When restart is needed, the query is closed BEFORE checking if we can
   * start a new one. This ensures fallback to cold-start if CLI becomes unavailable.
   *
   * @returns true if the query was (re)started, false otherwise
   */
  async ensureReady(options) {
    var _a, _b, _c;
    const vaultPath = getVaultPath(this.plugin.app);
    if (options && options.externalContextPaths !== void 0) {
      this.currentExternalContextPaths = options.externalContextPaths;
    }
    const effectiveSessionId = (_b = (_a = options == null ? void 0 : options.sessionId) != null ? _a : this.sessionManager.getSessionId()) != null ? _b : void 0;
    const externalContextPaths = (_c = options == null ? void 0 : options.externalContextPaths) != null ? _c : this.currentExternalContextPaths;
    if (!this.persistentQuery) {
      if (!vaultPath) return false;
      const cliPath2 = this.plugin.getResolvedClaudeCliPath();
      if (!cliPath2) return false;
      await this.startPersistentQuery(vaultPath, cliPath2, effectiveSessionId, externalContextPaths);
      return true;
    }
    if (options == null ? void 0 : options.force) {
      this.closePersistentQuery("forced restart", { preserveHandlers: options.preserveHandlers });
      if (!vaultPath) return false;
      const cliPath2 = this.plugin.getResolvedClaudeCliPath();
      if (!cliPath2) return false;
      await this.startPersistentQuery(vaultPath, cliPath2, effectiveSessionId, externalContextPaths);
      return true;
    }
    if (!vaultPath) return false;
    const cliPath = this.plugin.getResolvedClaudeCliPath();
    if (!cliPath) return false;
    const newConfig = this.buildPersistentQueryConfig(vaultPath, cliPath, externalContextPaths);
    if (this.needsRestart(newConfig)) {
      this.closePersistentQuery("config changed", { preserveHandlers: options == null ? void 0 : options.preserveHandlers });
      const cliPathAfterClose = this.plugin.getResolvedClaudeCliPath();
      if (cliPathAfterClose) {
        await this.startPersistentQuery(vaultPath, cliPathAfterClose, effectiveSessionId, externalContextPaths);
        return true;
      }
      return false;
    }
    return false;
  }
  /**
   * Starts the persistent query for the active chat conversation.
   */
  async startPersistentQuery(vaultPath, cliPath, resumeSessionId, externalContextPaths) {
    if (this.persistentQuery) {
      return;
    }
    this.shuttingDown = false;
    this.vaultPath = vaultPath;
    this.messageChannel = new MessageChannel();
    if (resumeSessionId) {
      this.messageChannel.setSessionId(resumeSessionId);
      this.sessionManager.setSessionId(resumeSessionId, this.plugin.settings.model);
    }
    this.queryAbortController = new AbortController();
    const config2 = this.buildPersistentQueryConfig(vaultPath, cliPath, externalContextPaths);
    this.currentConfig = config2;
    const options = await this.buildPersistentQueryOptions(
      vaultPath,
      cliPath,
      resumeSessionId,
      externalContextPaths
    );
    this.persistentQuery = query({
      prompt: this.messageChannel,
      options
    });
    this.attachPersistentQueryStdinErrorHandler(this.persistentQuery);
    this.startResponseConsumer();
  }
  attachPersistentQueryStdinErrorHandler(query2) {
    var _a;
    const stdin = (_a = query2.transport) == null ? void 0 : _a.processStdin;
    if (!stdin || typeof stdin.on !== "function" || typeof stdin.once !== "function") {
      return;
    }
    const handler = (error2) => {
      if (this.shuttingDown || this.isPipeError(error2)) {
        return;
      }
      this.closePersistentQuery("stdin error");
    };
    stdin.on("error", handler);
    stdin.once("close", () => {
      stdin.removeListener("error", handler);
    });
  }
  isPipeError(error2) {
    if (!error2 || typeof error2 !== "object") {
      return false;
    }
    const maybeError = error2;
    if (maybeError.code === "EPIPE") {
      return true;
    }
    return typeof maybeError.message === "string" && maybeError.message.includes("EPIPE");
  }
  /**
   * Closes the persistent query and cleans up resources.
   */
  closePersistentQuery(_reason, options) {
    var _a, _b, _c;
    if (!this.persistentQuery) {
      return;
    }
    const preserveHandlers = (_a = options == null ? void 0 : options.preserveHandlers) != null ? _a : false;
    this.shuttingDown = true;
    (_b = this.messageChannel) == null ? void 0 : _b.close();
    void this.persistentQuery.interrupt().catch(() => {
    });
    (_c = this.queryAbortController) == null ? void 0 : _c.abort();
    if (!preserveHandlers) {
      for (const handler of this.responseHandlers) {
        handler.onDone();
      }
    }
    this.persistentQuery = null;
    this.messageChannel = null;
    this.queryAbortController = null;
    this.responseConsumerRunning = false;
    this.currentConfig = null;
    if (!preserveHandlers) {
      this.responseHandlers = [];
      this.currentAllowedTools = null;
    }
    this.shuttingDown = false;
  }
  /**
   * Checks if the persistent query needs to be restarted based on configuration changes.
   */
  needsRestart(newConfig) {
    return QueryOptionsBuilder.needsRestart(this.currentConfig, newConfig);
  }
  /**
   * Builds configuration object for tracking changes.
   */
  buildPersistentQueryConfig(vaultPath, cliPath, externalContextPaths) {
    return QueryOptionsBuilder.buildPersistentQueryConfig(
      this.buildQueryOptionsContext(vaultPath, cliPath),
      externalContextPaths
    );
  }
  /**
   * Builds the base query options context from current state.
   */
  buildQueryOptionsContext(vaultPath, cliPath) {
    const customEnv = parseEnvironmentVariables(this.plugin.getActiveEnvironmentVariables());
    const enhancedPath = getEnhancedPath(customEnv.PATH, cliPath);
    return {
      vaultPath,
      cliPath,
      settings: this.plugin.settings,
      customEnv,
      enhancedPath,
      mcpManager: this.mcpManager,
      pluginManager: this.plugin.pluginManager
    };
  }
  /**
   * Builds SDK options for the persistent query.
   */
  buildPersistentQueryOptions(vaultPath, cliPath, resumeSessionId, externalContextPaths) {
    var _a;
    const baseContext = this.buildQueryOptionsContext(vaultPath, cliPath);
    const hooks = this.buildHooks(vaultPath);
    const permissionMode = this.plugin.settings.permissionMode;
    const ctx = {
      ...baseContext,
      abortController: (_a = this.queryAbortController) != null ? _a : void 0,
      resumeSessionId,
      canUseTool: permissionMode !== "yolo" ? this.createApprovalCallback() : void 0,
      hooks,
      externalContextPaths
    };
    return QueryOptionsBuilder.buildPersistentQueryOptions(ctx);
  }
  /**
   * Builds the hooks for SDK options.
   * Hooks need access to `this` for dynamic settings, so they're built here.
   *
   * @param vaultPath - The vault path for file operations.
   * @param externalContextPaths - Optional external context paths for cold-start queries.
   *        If not provided, the closure reads this.currentExternalContextPaths at execution
   *        time (for persistent queries where the value may change dynamically).
   */
  buildHooks(vaultPath, externalContextPaths) {
    const blocklistHook = createBlocklistHook(() => ({
      blockedCommands: this.plugin.settings.blockedCommands,
      enableBlocklist: this.plugin.settings.enableBlocklist
    }));
    const vaultRestrictionHook = createVaultRestrictionHook({
      getPathAccessType: (p) => {
        if (!this.vaultPath) return "vault";
        const paths = externalContextPaths != null ? externalContextPaths : this.currentExternalContextPaths;
        return getPathAccessType(
          p,
          paths,
          this.plugin.settings.allowedExportPaths,
          this.vaultPath
        );
      }
    });
    const postCallback = {
      trackEditedFile: async () => {
      }
    };
    const fileHashPreHook = createFileHashPreHook(vaultPath);
    const fileHashPostHook = createFileHashPostHook(vaultPath, postCallback);
    return {
      PreToolUse: [blocklistHook, vaultRestrictionHook, fileHashPreHook],
      PostToolUse: [fileHashPostHook]
    };
  }
  // ============================================
  // Response Consumer Loop (Phase 1.4)
  // ============================================
  /**
   * Starts the background consumer loop that routes chunks to handlers.
   */
  startResponseConsumer() {
    if (this.responseConsumerRunning) {
      return;
    }
    this.responseConsumerRunning = true;
    const queryForThisConsumer = this.persistentQuery;
    void (async () => {
      var _a;
      if (!this.persistentQuery) return;
      try {
        for await (const message of this.persistentQuery) {
          if (this.shuttingDown) break;
          await this.routeMessage(message);
        }
      } catch (error2) {
        if (this.persistentQuery !== queryForThisConsumer && this.persistentQuery !== null) {
          return;
        }
        if (!this.shuttingDown && !this.coldStartInProgress) {
          const handler = this.responseHandlers[this.responseHandlers.length - 1];
          const errorInstance = error2 instanceof Error ? error2 : new Error(String(error2));
          const messageToReplay = this.lastSentMessage;
          if (!this.crashRecoveryAttempted && messageToReplay && handler && !handler.sawAnyChunk) {
            this.crashRecoveryAttempted = true;
            try {
              await this.ensureReady({ force: true, preserveHandlers: true });
              if (!this.messageChannel) {
                throw new Error("Persistent query restart did not create message channel");
              }
              await this.applyDynamicUpdates((_a = this.lastSentQueryOptions) != null ? _a : void 0, { preserveHandlers: true });
              this.messageChannel.enqueue(messageToReplay);
              return;
            } catch (restartError) {
              if (isSessionExpiredError(restartError)) {
                this.sessionManager.invalidateSession();
              }
              handler.onError(errorInstance);
              return;
            }
          }
          if (handler) {
            handler.onError(errorInstance);
          }
          if (!this.crashRecoveryAttempted) {
            this.crashRecoveryAttempted = true;
            try {
              await this.ensureReady({ force: true });
            } catch (restartError) {
              if (isSessionExpiredError(restartError)) {
                this.sessionManager.invalidateSession();
              }
            }
          }
        }
      } finally {
        if (this.persistentQuery === queryForThisConsumer || this.persistentQuery === null) {
          this.responseConsumerRunning = false;
        }
      }
    })();
  }
  /**
   * Routes an SDK message to the active response handler.
   *
   * Design: Only one handler exists at a time because MessageChannel enforces
   * single-turn processing. When a turn is active, new messages are queued/merged.
   * The next message only dequeues after onTurnComplete(), which calls onDone()
   * on the current handler. A new handler is registered only when the next query starts.
   */
  async routeMessage(message) {
    var _a, _b;
    const handler = this.responseHandlers[this.responseHandlers.length - 1];
    if (handler && this.isStreamTextEvent(message)) {
      handler.markStreamTextSeen();
    }
    const selectedModel = this.plugin.settings.model;
    for (const event of transformSDKMessage(message, { intendedModel: selectedModel })) {
      if (isSessionInitEvent(event)) {
        this.sessionManager.captureSession(event.sessionId);
        (_a = this.messageChannel) == null ? void 0 : _a.setSessionId(event.sessionId);
      } else if (isStreamChunk(event)) {
        if (message.type === "assistant" && (handler == null ? void 0 : handler.sawStreamText) && event.type === "text") {
          continue;
        }
        if (handler) {
          if (event.type === "usage") {
            handler.onChunk({ ...event, sessionId: this.sessionManager.getSessionId() });
          } else {
            handler.onChunk(event);
          }
        }
      }
    }
    if (isTurnCompleteMessage(message)) {
      (_b = this.messageChannel) == null ? void 0 : _b.onTurnComplete();
      if (handler) {
        handler.resetStreamText();
        handler.onDone();
      }
    }
  }
  /**
   * Registers a response handler for an active query.
   */
  registerResponseHandler(handler) {
    this.responseHandlers.push(handler);
  }
  /**
   * Unregisters a response handler.
   */
  unregisterResponseHandler(handlerId) {
    const idx = this.responseHandlers.findIndex((h) => h.id === handlerId);
    if (idx >= 0) {
      this.responseHandlers.splice(idx, 1);
    }
  }
  /** Check if persistent query is active. */
  isPersistentQueryActive() {
    return this.persistentQuery !== null && !this.shuttingDown;
  }
  /**
   * Sends a query to Claude and streams the response.
   *
   * Query selection:
   * - Persistent query: default chat conversation
   * - Cold-start query: only when forceColdStart is set
   */
  async *query(prompt, images, conversationHistory, queryOptions) {
    var _a;
    const vaultPath = getVaultPath(this.plugin.app);
    if (!vaultPath) {
      yield { type: "error", content: "Could not determine vault path" };
      return;
    }
    const resolvedClaudePath = this.plugin.getResolvedClaudeCliPath();
    if (!resolvedClaudePath) {
      yield { type: "error", content: "Claude CLI not found. Please install Claude Code CLI." };
      return;
    }
    let promptToSend = prompt;
    let forceColdStart = false;
    if (this.sessionManager.wasInterrupted()) {
      this.sessionManager.clearInterrupted();
    }
    if (this.sessionManager.needsHistoryRebuild() && conversationHistory && conversationHistory.length > 0) {
      const historyContext = buildContextFromHistory(conversationHistory);
      const actualPrompt = stripCurrentNotePrefix(prompt);
      promptToSend = buildPromptWithHistoryContext(historyContext, prompt, actualPrompt, conversationHistory);
      this.sessionManager.clearHistoryRebuild();
    }
    const noSessionButHasHistory = !this.sessionManager.getSessionId() && conversationHistory && conversationHistory.length > 0;
    if (noSessionButHasHistory) {
      const historyContext = buildContextFromHistory(conversationHistory);
      const actualPrompt = stripCurrentNotePrefix(prompt);
      promptToSend = buildPromptWithHistoryContext(historyContext, prompt, actualPrompt, conversationHistory);
      forceColdStart = true;
    }
    const effectiveQueryOptions = forceColdStart ? { ...queryOptions, forceColdStart: true } : queryOptions;
    if (forceColdStart) {
      this.coldStartInProgress = true;
      this.closePersistentQuery("session invalidated");
    }
    const shouldUsePersistent = this.shouldUsePersistentQuery(effectiveQueryOptions);
    if (shouldUsePersistent) {
      if (!this.persistentQuery && !this.shuttingDown) {
        await this.startPersistentQuery(
          vaultPath,
          resolvedClaudePath,
          (_a = this.sessionManager.getSessionId()) != null ? _a : void 0
        );
      }
      if (this.persistentQuery && !this.shuttingDown) {
        try {
          yield* this.queryViaPersistent(promptToSend, images, vaultPath, resolvedClaudePath, effectiveQueryOptions);
          return;
        } catch (error2) {
          if (isSessionExpiredError(error2) && conversationHistory && conversationHistory.length > 0) {
            this.sessionManager.invalidateSession();
            const retryRequest = this.buildHistoryRebuildRequest(prompt, conversationHistory);
            this.coldStartInProgress = true;
            this.abortController = new AbortController();
            try {
              yield* this.queryViaSDK(
                retryRequest.prompt,
                vaultPath,
                resolvedClaudePath,
                // Use current message's images, fallback to history images
                images != null ? images : retryRequest.images,
                effectiveQueryOptions
              );
            } catch (retryError) {
              const msg = retryError instanceof Error ? retryError.message : "Unknown error";
              yield { type: "error", content: msg };
            } finally {
              this.coldStartInProgress = false;
              this.abortController = null;
            }
            return;
          }
          throw error2;
        }
      }
    }
    this.coldStartInProgress = true;
    this.abortController = new AbortController();
    try {
      yield* this.queryViaSDK(promptToSend, vaultPath, resolvedClaudePath, images, effectiveQueryOptions);
    } catch (error2) {
      if (isSessionExpiredError(error2) && conversationHistory && conversationHistory.length > 0) {
        this.sessionManager.invalidateSession();
        const retryRequest = this.buildHistoryRebuildRequest(prompt, conversationHistory);
        try {
          yield* this.queryViaSDK(
            retryRequest.prompt,
            vaultPath,
            resolvedClaudePath,
            // Use current message's images, fallback to history images
            images != null ? images : retryRequest.images,
            effectiveQueryOptions
          );
        } catch (retryError) {
          const msg2 = retryError instanceof Error ? retryError.message : "Unknown error";
          yield { type: "error", content: msg2 };
        }
        return;
      }
      const msg = error2 instanceof Error ? error2.message : "Unknown error";
      yield { type: "error", content: msg };
    } finally {
      this.coldStartInProgress = false;
      this.abortController = null;
    }
  }
  buildHistoryRebuildRequest(prompt, conversationHistory) {
    const historyContext = buildContextFromHistory(conversationHistory);
    const actualPrompt = stripCurrentNotePrefix(prompt);
    const fullPrompt = buildPromptWithHistoryContext(historyContext, prompt, actualPrompt, conversationHistory);
    const lastUserMessage = getLastUserMessage(conversationHistory);
    return {
      prompt: fullPrompt,
      images: lastUserMessage == null ? void 0 : lastUserMessage.images
    };
  }
  /**
   * Determines if the persistent query should be used.
   * Cold-start is only used when forceColdStart is set.
   */
  shouldUsePersistentQuery(queryOptions) {
    if (queryOptions == null ? void 0 : queryOptions.forceColdStart) return false;
    return true;
  }
  /**
   * Query via persistent query (Phase 1.5).
   * Uses the message channel to send messages without cold-start latency.
   */
  async *queryViaPersistent(prompt, images, vaultPath, cliPath, queryOptions) {
    if (!this.persistentQuery || !this.messageChannel) {
      yield* this.queryViaSDK(prompt, vaultPath, cliPath, images, queryOptions);
      return;
    }
    if ((queryOptions == null ? void 0 : queryOptions.allowedTools) !== void 0) {
      this.currentAllowedTools = queryOptions.allowedTools.length > 0 ? [...queryOptions.allowedTools, TOOL_SKILL] : [];
    } else {
      this.currentAllowedTools = null;
    }
    const savedAllowedTools = this.currentAllowedTools;
    await this.applyDynamicUpdates(queryOptions);
    this.currentAllowedTools = savedAllowedTools;
    if (!this.persistentQuery || !this.messageChannel) {
      yield* this.queryViaSDK(prompt, vaultPath, cliPath, images, queryOptions);
      return;
    }
    if (!this.responseConsumerRunning) {
      yield* this.queryViaSDK(prompt, vaultPath, cliPath, images, queryOptions);
      return;
    }
    const message = this.buildSDKUserMessage(prompt, images);
    const state = {
      chunks: [],
      resolveChunk: null,
      done: false,
      error: null
    };
    const handlerId = `handler-${Date.now()}-${Math.random().toString(36).slice(2)}`;
    const handler = createResponseHandler({
      id: handlerId,
      onChunk: (chunk) => {
        handler.markChunkSeen();
        if (state.resolveChunk) {
          state.resolveChunk(chunk);
          state.resolveChunk = null;
        } else {
          state.chunks.push(chunk);
        }
      },
      onDone: () => {
        state.done = true;
        if (state.resolveChunk) {
          state.resolveChunk(null);
          state.resolveChunk = null;
        }
      },
      onError: (err) => {
        state.error = err;
        state.done = true;
        if (state.resolveChunk) {
          state.resolveChunk(null);
          state.resolveChunk = null;
        }
      }
    });
    this.registerResponseHandler(handler);
    try {
      this.lastSentMessage = message;
      this.lastSentQueryOptions = queryOptions != null ? queryOptions : null;
      this.crashRecoveryAttempted = false;
      try {
        this.messageChannel.enqueue(message);
      } catch (error2) {
        if (error2 instanceof Error && error2.message.includes("closed")) {
          yield* this.queryViaSDK(prompt, vaultPath, cliPath, images, queryOptions);
          return;
        }
        throw error2;
      }
      while (!state.done) {
        if (state.chunks.length > 0) {
          yield state.chunks.shift();
        } else {
          const chunk = await new Promise((resolve3) => {
            state.resolveChunk = resolve3;
          });
          if (chunk) {
            yield chunk;
          }
        }
      }
      while (state.chunks.length > 0) {
        yield state.chunks.shift();
      }
      if (state.error) {
        if (isSessionExpiredError(state.error)) {
          throw state.error;
        }
        yield { type: "error", content: state.error.message };
      }
      this.lastSentMessage = null;
      this.lastSentQueryOptions = null;
      yield { type: "done" };
    } finally {
      this.unregisterResponseHandler(handlerId);
      this.currentAllowedTools = null;
    }
  }
  /**
   * Builds an SDKUserMessage from prompt and images.
   */
  buildSDKUserMessage(prompt, images) {
    const sessionId = this.sessionManager.getSessionId() || "";
    if (!images || images.length === 0) {
      return {
        type: "user",
        message: {
          role: "user",
          content: prompt
        },
        parent_tool_use_id: null,
        session_id: sessionId
      };
    }
    const content = [];
    for (const image of images) {
      content.push({
        type: "image",
        source: {
          type: "base64",
          media_type: image.mediaType,
          data: image.data
        }
      });
    }
    if (prompt.trim()) {
      content.push({
        type: "text",
        text: prompt
      });
    }
    return {
      type: "user",
      message: {
        role: "user",
        content
      },
      parent_tool_use_id: null,
      session_id: sessionId
    };
  }
  /**
   * Apply dynamic updates to the persistent query before sending a message (Phase 1.6).
   */
  async applyDynamicUpdates(queryOptions, restartOptions, allowRestart = true) {
    var _a, _b, _c;
    if (!this.persistentQuery) return;
    if (!this.vaultPath) {
      return;
    }
    const cliPath = this.plugin.getResolvedClaudeCliPath();
    if (!cliPath) {
      return;
    }
    const selectedModel = (queryOptions == null ? void 0 : queryOptions.model) || this.plugin.settings.model;
    const permissionMode = this.plugin.settings.permissionMode;
    const budgetSetting = this.plugin.settings.thinkingBudget;
    const budgetConfig = THINKING_BUDGETS.find((b) => b.value === budgetSetting);
    const thinkingTokens = (_a = budgetConfig == null ? void 0 : budgetConfig.tokens) != null ? _a : null;
    const show1MModel = this.plugin.settings.show1MModel;
    if (this.currentConfig && selectedModel !== this.currentConfig.model) {
      const resolved = resolveModelWithBetas(selectedModel, show1MModel);
      try {
        await this.persistentQuery.setModel(resolved.model);
        this.currentConfig.model = selectedModel;
      } catch (e) {
      }
    }
    const currentThinking = (_c = (_b = this.currentConfig) == null ? void 0 : _b.thinkingTokens) != null ? _c : null;
    if (thinkingTokens !== currentThinking) {
      try {
        await this.persistentQuery.setMaxThinkingTokens(thinkingTokens);
        if (this.currentConfig) {
          this.currentConfig.thinkingTokens = thinkingTokens;
        }
      } catch (e) {
      }
    }
    if (this.currentConfig && permissionMode !== this.currentConfig.permissionMode) {
      const sdkMode = permissionMode === "yolo" ? "bypassPermissions" : "default";
      try {
        await this.persistentQuery.setPermissionMode(sdkMode);
        this.currentConfig.permissionMode = permissionMode;
      } catch (e) {
      }
    }
    const mcpMentions = (queryOptions == null ? void 0 : queryOptions.mcpMentions) || /* @__PURE__ */ new Set();
    const uiEnabledServers = (queryOptions == null ? void 0 : queryOptions.enabledMcpServers) || /* @__PURE__ */ new Set();
    const combinedMentions = /* @__PURE__ */ new Set([...mcpMentions, ...uiEnabledServers]);
    const mcpServers = this.mcpManager.getActiveServers(combinedMentions);
    const mcpServersKey = JSON.stringify(mcpServers);
    if (this.currentConfig && mcpServersKey !== this.currentConfig.mcpServersKey) {
      const serverConfigs = {};
      for (const [name, config2] of Object.entries(mcpServers)) {
        serverConfigs[name] = config2;
      }
      try {
        await this.persistentQuery.setMcpServers(serverConfigs);
        this.currentConfig.mcpServersKey = mcpServersKey;
      } catch (e) {
      }
    }
    const newExternalContextPaths = (queryOptions == null ? void 0 : queryOptions.externalContextPaths) || [];
    this.currentExternalContextPaths = newExternalContextPaths;
    if (!allowRestart) {
      return;
    }
    const newConfig = this.buildPersistentQueryConfig(this.vaultPath, cliPath, newExternalContextPaths);
    if (!this.needsRestart(newConfig)) {
      return;
    }
    const restarted = await this.ensureReady({
      externalContextPaths: newExternalContextPaths,
      preserveHandlers: restartOptions == null ? void 0 : restartOptions.preserveHandlers,
      force: true
    });
    if (restarted && this.persistentQuery) {
      await this.applyDynamicUpdates(queryOptions, restartOptions, false);
    }
  }
  isStreamTextEvent(message) {
    var _a, _b;
    if (message.type !== "stream_event") return false;
    const event = message.event;
    if (!event) return false;
    if (event.type === "content_block_start") {
      return ((_a = event.content_block) == null ? void 0 : _a.type) === "text";
    }
    if (event.type === "content_block_delta") {
      return ((_b = event.delta) == null ? void 0 : _b.type) === "text_delta";
    }
    return false;
  }
  /**
   * Build a prompt with images as content blocks
   */
  buildPromptWithImages(prompt, images) {
    if (!images || images.length === 0) {
      return prompt;
    }
    const content = [];
    for (const image of images) {
      content.push({
        type: "image",
        source: {
          type: "base64",
          media_type: image.mediaType,
          data: image.data
        }
      });
    }
    if (prompt.trim()) {
      content.push({
        type: "text",
        text: prompt
      });
    }
    async function* messageGenerator() {
      yield {
        type: "user",
        message: {
          role: "user",
          content
        }
      };
    }
    return messageGenerator();
  }
  async *queryViaSDK(prompt, cwd2, cliPath, images, queryOptions) {
    var _a, _b, _c;
    const selectedModel = (queryOptions == null ? void 0 : queryOptions.model) || this.plugin.settings.model;
    const permissionMode = this.plugin.settings.permissionMode;
    this.sessionManager.setPendingModel(selectedModel);
    this.vaultPath = cwd2;
    const queryPrompt = this.buildPromptWithImages(prompt, images);
    const baseContext = this.buildQueryOptionsContext(cwd2, cliPath);
    const externalContextPaths = (queryOptions == null ? void 0 : queryOptions.externalContextPaths) || [];
    const hooks = this.buildHooks(cwd2, externalContextPaths);
    const hasEditorContext = prompt.includes("<editor_selection");
    let allowedTools;
    if ((queryOptions == null ? void 0 : queryOptions.allowedTools) !== void 0 && queryOptions.allowedTools.length > 0) {
      const toolSet = /* @__PURE__ */ new Set([...queryOptions.allowedTools, TOOL_SKILL]);
      allowedTools = [...toolSet];
    }
    const ctx = {
      ...baseContext,
      abortController: (_a = this.abortController) != null ? _a : void 0,
      sessionId: (_b = this.sessionManager.getSessionId()) != null ? _b : void 0,
      modelOverride: queryOptions == null ? void 0 : queryOptions.model,
      canUseTool: permissionMode !== "yolo" ? this.createApprovalCallback() : void 0,
      hooks,
      mcpMentions: queryOptions == null ? void 0 : queryOptions.mcpMentions,
      enabledMcpServers: queryOptions == null ? void 0 : queryOptions.enabledMcpServers,
      allowedTools,
      hasEditorContext,
      externalContextPaths
    };
    const options = QueryOptionsBuilder.buildColdStartQueryOptions(ctx);
    let sawStreamText = false;
    try {
      const response = query({ prompt: queryPrompt, options });
      let streamSessionId = this.sessionManager.getSessionId();
      for await (const message of response) {
        if (this.isStreamTextEvent(message)) {
          sawStreamText = true;
        }
        if ((_c = this.abortController) == null ? void 0 : _c.signal.aborted) {
          await response.interrupt();
          break;
        }
        for (const event of transformSDKMessage(message, { intendedModel: selectedModel })) {
          if (isSessionInitEvent(event)) {
            this.sessionManager.captureSession(event.sessionId);
            streamSessionId = event.sessionId;
          } else if (isStreamChunk(event)) {
            if (message.type === "assistant" && sawStreamText && event.type === "text") {
              continue;
            }
            if (event.type === "usage") {
              yield { ...event, sessionId: streamSessionId };
            } else {
              yield event;
            }
          }
        }
        if (message.type === "result") {
          sawStreamText = false;
        }
      }
    } catch (error2) {
      if (isSessionExpiredError(error2)) {
        throw error2;
      }
      const msg = error2 instanceof Error ? error2.message : "Unknown error";
      yield { type: "error", content: msg };
    } finally {
      this.sessionManager.clearPendingModel();
      this.currentAllowedTools = null;
    }
    yield { type: "done" };
  }
  /** Cancel the current query. */
  cancel() {
    if (this.abortController) {
      this.abortController.abort();
      this.sessionManager.markInterrupted();
    }
    if (this.persistentQuery && !this.shuttingDown) {
      void this.persistentQuery.interrupt().catch(() => {
      });
    }
  }
  /**
   * Reset the conversation session.
   * Closes the persistent query since session is changing.
   */
  resetSession() {
    this.closePersistentQuery("session reset");
    this.crashRecoveryAttempted = false;
    this.sessionManager.reset();
    this.approvalManager.clearSessionPermissions();
  }
  /** Get the current session ID. */
  getSessionId() {
    return this.sessionManager.getSessionId();
  }
  /** Consume session invalidation flag for persistence updates. */
  consumeSessionInvalidation() {
    return this.sessionManager.consumeInvalidation();
  }
  /**
   * Set the session ID (for restoring from saved conversation).
   * Closes persistent query synchronously if session is changing, then ensures query is ready.
   *
   * @param id - Session ID to restore, or null for new session
   * @param externalContextPaths - External context paths for the session (prevents stale contexts)
   */
  setSessionId(id, externalContextPaths) {
    const currentId = this.sessionManager.getSessionId();
    const sessionChanged = currentId !== id;
    if (sessionChanged) {
      this.closePersistentQuery("session switch");
      this.crashRecoveryAttempted = false;
    }
    this.sessionManager.setSessionId(id, this.plugin.settings.model);
    this.ensureReady({
      sessionId: id != null ? id : void 0,
      externalContextPaths
    }).catch(() => {
    });
  }
  /**
   * Cleanup resources (Phase 5).
   * Called on plugin unload to close persistent query and abort any cold-start query.
   */
  cleanup() {
    this.closePersistentQuery("plugin cleanup");
    this.cancel();
    this.resetSession();
  }
  /** Sets the approval callback for UI prompts. */
  setApprovalCallback(callback) {
    this.approvalCallback = callback;
  }
  /**
   * Create approval callback for normal mode.
   * Enforces tool restrictions and handles approval flow.
   */
  createApprovalCallback() {
    return async (toolName, input) => {
      if (this.currentAllowedTools !== null) {
        if (!this.currentAllowedTools.includes(toolName) && toolName !== TOOL_SKILL) {
          const allowedList = this.currentAllowedTools.length > 0 ? ` Allowed tools: ${this.currentAllowedTools.join(", ")}.` : " No tools are allowed for this query type.";
          return {
            behavior: "deny",
            message: `Tool "${toolName}" is not allowed for this query.${allowedList}`
          };
        }
      }
      return this.handleNormalModeApproval(toolName, input);
    };
  }
  /**
   * Handle normal mode approval - check approved actions, then prompt user.
   */
  async handleNormalModeApproval(toolName, input) {
    if (this.approvalManager.isActionApproved(toolName, input)) {
      return { behavior: "allow", updatedInput: input };
    }
    if (!this.approvalCallback) {
      return {
        behavior: "deny",
        message: "No approval handler available. Please enable YOLO mode or configure permissions."
      };
    }
    const description = getActionDescription(toolName, input);
    try {
      const decision = await this.approvalCallback(toolName, input, description);
      if (decision === "cancel") {
        return {
          behavior: "deny",
          message: "User interrupted.",
          interrupt: true
        };
      }
      if (decision === "deny") {
        await this.approvalManager.denyAction(toolName, input, "session");
        return {
          behavior: "deny",
          message: "User denied this action.",
          interrupt: false
        };
      }
      if (decision === "deny-always") {
        await this.approvalManager.denyAction(toolName, input, "always");
        return {
          behavior: "deny",
          message: "User denied this action.",
          interrupt: false
        };
      }
      if (decision === "allow-always") {
        await this.approvalManager.approveAction(toolName, input, "always");
      } else if (decision === "allow") {
        await this.approvalManager.approveAction(toolName, input, "session");
      }
      return { behavior: "allow", updatedInput: input };
    } catch (error2) {
      return {
        behavior: "deny",
        message: `Approval request failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`,
        interrupt: true
      };
    }
  }
};

// src/core/commands/builtInCommands.ts
var BUILT_IN_COMMANDS = [
  {
    name: "clear",
    aliases: ["new"],
    description: "Start a new conversation",
    action: "clear"
  }
];
var commandMap = /* @__PURE__ */ new Map();
for (const cmd of BUILT_IN_COMMANDS) {
  commandMap.set(cmd.name.toLowerCase(), cmd);
  if (cmd.aliases) {
    for (const alias of cmd.aliases) {
      commandMap.set(alias.toLowerCase(), cmd);
    }
  }
}
function detectBuiltInCommand(input) {
  var _a;
  const trimmed = input.trim();
  if (!trimmed.startsWith("/")) return null;
  const match = trimmed.match(/^\/([a-zA-Z0-9_-]+)(?:\s|$)/);
  if (!match) return null;
  const cmdName = match[1].toLowerCase();
  return (_a = commandMap.get(cmdName)) != null ? _a : null;
}
function getBuiltInCommandsForDropdown() {
  return BUILT_IN_COMMANDS.map((cmd) => ({
    id: `builtin:${cmd.name}`,
    name: cmd.name,
    description: cmd.description,
    content: ""
    // Built-in commands don't have prompt content
  }));
}

// src/core/commands/SlashCommandManager.ts
var import_child_process3 = require("child_process");
var import_obsidian3 = require("obsidian");
var SlashCommandManager = class {
  constructor(app, vaultPath, options = {}) {
    this.commands = /* @__PURE__ */ new Map();
    var _a;
    this.app = app;
    this.vaultPath = vaultPath;
    this.bashRunner = (_a = options.bashRunner) != null ? _a : defaultBashRunner;
  }
  /** Registers commands from settings. */
  setCommands(commands) {
    this.commands.clear();
    for (const cmd of commands) {
      this.commands.set(cmd.name.toLowerCase(), cmd);
    }
  }
  /** Gets all registered commands. */
  getCommands() {
    return Array.from(this.commands.values());
  }
  /** Gets a command by name. */
  getCommand(name) {
    return this.commands.get(name.toLowerCase());
  }
  /** Gets filtered commands matching a prefix, sorted alphabetically. */
  getMatchingCommands(prefix) {
    const prefixLower = prefix.toLowerCase();
    return this.getCommands().filter(
      (cmd) => {
        var _a;
        return cmd.name.toLowerCase().includes(prefixLower) || ((_a = cmd.description) == null ? void 0 : _a.toLowerCase().includes(prefixLower));
      }
    ).sort((a, b) => a.name.localeCompare(b.name)).slice(0, 10);
  }
  /**
   * Detects if input starts with a slash command.
   * Returns the command name and arguments if found.
   * Command must be at position 0 (no leading whitespace).
   */
  detectCommand(input) {
    if (!input.startsWith("/")) return null;
    const match = input.match(/^\/([a-zA-Z0-9_/:-]+)(?:\s+([\s\S]*))?$/);
    if (!match) return null;
    const commandName = match[1];
    const args = (match[2] || "").trim();
    if (!this.commands.has(commandName.toLowerCase())) {
      return null;
    }
    return { commandName, args };
  }
  /**
   * Expands a command with arguments.
   * Processes frontmatter, placeholders, file references, and bash execution.
   */
  async expandCommand(command, args, options = {}) {
    const errors = [];
    const parsed = parseSlashCommandContent(command.content);
    let result = parsed.promptContent;
    result = this.replaceArgumentPlaceholders(result, args);
    try {
      const bashResult = await this.executeInlineBash(result, options.bash);
      result = bashResult.content;
      errors.push(...bashResult.errors);
    } catch (error2) {
      errors.push(`Bash execution error: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
    try {
      const fileResult = await this.resolveFileReferences(result);
      result = fileResult.content;
      errors.push(...fileResult.errors);
    } catch (error2) {
      errors.push(`File reference error: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
    return {
      expandedPrompt: result.trim(),
      allowedTools: command.allowedTools || parsed.allowedTools,
      model: command.model || parsed.model,
      errors
    };
  }
  /**
   * Replaces argument placeholders in content.
   * Handles $ARGUMENTS (all args) and $1, $2, etc. (positional).
   * If no placeholders exist, appends args at the end.
   */
  replaceArgumentPlaceholders(content, args) {
    if (!args.trim()) return content;
    const hasArgumentsPlaceholder = content.includes("$ARGUMENTS");
    const hasPositionalPlaceholder = /\$\d+/.test(content);
    if (!hasArgumentsPlaceholder && !hasPositionalPlaceholder) {
      return content + "\n\n" + args;
    }
    const argParts = this.parseArguments(args);
    let result = content.replace(/\$ARGUMENTS/g, args);
    for (let i = 0; i < argParts.length; i++) {
      const pattern = new RegExp(`\\$${i + 1}(?![0-9])`, "g");
      result = result.replace(pattern, argParts[i]);
    }
    result = result.replace(/\$\d+/g, "");
    return result;
  }
  /**
   * Parses arguments respecting quoted strings.
   * "arg with spaces" and 'single quotes' are treated as single args.
   */
  parseArguments(args) {
    var _a, _b;
    if (!args.trim()) return [];
    const parts = [];
    const regex = /[^\s"']+|"([^"]*)"|'([^']*)'/g;
    let match;
    while ((match = regex.exec(args)) !== null) {
      parts.push((_b = (_a = match[1]) != null ? _a : match[2]) != null ? _b : match[0]);
    }
    return parts;
  }
  /**
   * Resolves @file references in content.
   * Replaces @path/to/file.md with file contents.
   */
  async resolveFileReferences(content) {
    var _a;
    const pattern = /(^|[^\w])@(?:"([^"]+)"|'([^']+)'|([^\s]+\.\w+))/g;
    const errors = [];
    const matches = [];
    let match;
    while ((match = pattern.exec(content)) !== null) {
      const prefix = (_a = match[1]) != null ? _a : "";
      const filePath = match[2] || match[3] || match[4];
      matches.push({ full: match[0], prefix, path: filePath, index: match.index });
    }
    let result = content;
    for (let i = matches.length - 1; i >= 0; i--) {
      const m = matches[i];
      try {
        const normalizedPath = m.path.replace(/\\/g, "/");
        const file = this.app.vault.getAbstractFileByPath(normalizedPath);
        if (file instanceof import_obsidian3.TFile) {
          const fileContent = await this.app.vault.read(file);
          result = result.slice(0, m.index) + m.prefix + fileContent + result.slice(m.index + m.full.length);
        } else {
          errors.push(`File reference not found: ${normalizedPath}`);
        }
      } catch (error2) {
        errors.push(
          `File reference failed: ${m.path} (${error2 instanceof Error ? error2.message : "Unknown error"})`
        );
      }
    }
    return { content: result, errors };
  }
  /**
   * Executes inline bash commands.
   * Replaces !`command` with command output.
   */
  async executeInlineBash(content, bashOptions) {
    var _a;
    const pattern = /!`([^`]+)`/g;
    const errors = [];
    const matches = [];
    let match;
    while ((match = pattern.exec(content)) !== null) {
      matches.push({ full: match[0], command: match[1], index: match.index });
    }
    let result = content;
    for (let i = matches.length - 1; i >= 0; i--) {
      const m = matches[i];
      try {
        if (!(bashOptions == null ? void 0 : bashOptions.enabled)) {
          errors.push(`Inline bash is disabled: ${m.command}`);
          result = result.slice(0, m.index) + `[Inline bash disabled]` + result.slice(m.index + m.full.length);
          continue;
        }
        if ((_a = bashOptions.shouldBlockCommand) == null ? void 0 : _a.call(bashOptions, m.command)) {
          errors.push(`Inline bash blocked by blocklist: ${m.command}`);
          result = result.slice(0, m.index) + `[Blocked]` + result.slice(m.index + m.full.length);
          continue;
        }
        if (bashOptions.requestApproval) {
          const approved = await bashOptions.requestApproval(m.command);
          if (!approved) {
            errors.push(`Inline bash denied by user: ${m.command}`);
            result = result.slice(0, m.index) + `[Denied]` + result.slice(m.index + m.full.length);
            continue;
          }
        }
        const output = await this.bashRunner(m.command, this.vaultPath);
        result = result.slice(0, m.index) + output.trim() + result.slice(m.index + m.full.length);
      } catch (error2) {
        const errorMsg = `[Error: ${error2 instanceof Error ? error2.message : "Command failed"}]`;
        errors.push(`Inline bash failed: ${m.command}`);
        result = result.slice(0, m.index) + errorMsg + result.slice(m.index + m.full.length);
      }
    }
    return { content: result, errors };
  }
};
function defaultBashRunner(command, cwd2) {
  return new Promise((resolve3, reject) => {
    (0, import_child_process3.exec)(
      command,
      {
        cwd: cwd2,
        timeout: 1e4,
        maxBuffer: 1024 * 1024,
        // Enhance PATH for GUI apps (Obsidian has minimal PATH)
        env: { ...process.env, PATH: getEnhancedPath() }
      },
      (error2, stdout, stderr) => {
        if (error2) {
          reject(new Error(stderr || error2.message));
        } else {
          resolve3(stdout);
        }
      }
    );
  });
}

// src/shared/components/SlashCommandDropdown.ts
var SlashCommandDropdown = class {
  constructor(containerEl, inputEl, callbacks, options = {}) {
    this.dropdownEl = null;
    this.slashStartIndex = -1;
    this.selectedIndex = 0;
    this.filteredCommands = [];
    var _a;
    this.containerEl = containerEl;
    this.inputEl = inputEl;
    this.callbacks = callbacks;
    this.isFixed = (_a = options.fixed) != null ? _a : false;
    this.onInput = () => this.handleInputChange();
    this.inputEl.addEventListener("input", this.onInput);
  }
  /** Handles input changes to detect / trigger. */
  handleInputChange() {
    const text = this.getInputValue();
    const cursorPos = this.getCursorPosition();
    const textBeforeCursor = text.substring(0, cursorPos);
    if (text.charAt(0) !== "/") {
      this.hide();
      return;
    }
    const slashIndex = 0;
    const searchText = textBeforeCursor.substring(slashIndex + 1);
    if (/\s/.test(searchText)) {
      this.hide();
      return;
    }
    this.slashStartIndex = slashIndex;
    this.showDropdown(searchText);
  }
  /** Handles keyboard navigation. Returns true if handled. */
  handleKeydown(e) {
    if (!this.isVisible()) return false;
    switch (e.key) {
      case "ArrowDown":
        e.preventDefault();
        this.navigate(1);
        return true;
      case "ArrowUp":
        e.preventDefault();
        this.navigate(-1);
        return true;
      case "Enter":
      case "Tab":
        if (this.filteredCommands.length > 0) {
          e.preventDefault();
          this.selectItem();
          return true;
        }
        return false;
      case "Escape":
        e.preventDefault();
        this.hide();
        return true;
    }
    return false;
  }
  /** Checks if dropdown is currently visible. */
  isVisible() {
    var _a, _b;
    return (_b = (_a = this.dropdownEl) == null ? void 0 : _a.hasClass("visible")) != null ? _b : false;
  }
  /** Hides the dropdown. */
  hide() {
    if (this.dropdownEl) {
      this.dropdownEl.removeClass("visible");
    }
    this.slashStartIndex = -1;
    this.callbacks.onHide();
  }
  /** Destroys the dropdown and cleans up. */
  destroy() {
    this.inputEl.removeEventListener("input", this.onInput);
    if (this.dropdownEl) {
      this.dropdownEl.remove();
      this.dropdownEl = null;
    }
  }
  getInputValue() {
    return this.inputEl.value;
  }
  getCursorPosition() {
    return this.inputEl.selectionStart || 0;
  }
  setInputValue(value) {
    this.inputEl.value = value;
  }
  setCursorPosition(pos) {
    this.inputEl.selectionStart = pos;
    this.inputEl.selectionEnd = pos;
  }
  showDropdown(searchText) {
    const userCommands = this.callbacks.getCommands();
    const builtInCommands = getBuiltInCommandsForDropdown();
    const searchLower = searchText.toLowerCase();
    const allCommands = [...builtInCommands, ...userCommands];
    this.filteredCommands = allCommands.filter(
      (cmd) => {
        var _a;
        return cmd.name.toLowerCase().includes(searchLower) || ((_a = cmd.description) == null ? void 0 : _a.toLowerCase().includes(searchLower));
      }
    ).sort((a, b) => a.name.localeCompare(b.name)).slice(0, 10);
    if (searchText.length > 0 && this.filteredCommands.length === 0) {
      this.hide();
      return;
    }
    this.selectedIndex = 0;
    this.render();
  }
  render() {
    if (!this.dropdownEl) {
      this.dropdownEl = this.createDropdownElement();
    }
    this.dropdownEl.empty();
    if (this.filteredCommands.length === 0) {
      const emptyEl = this.dropdownEl.createDiv({ cls: "claudian-slash-empty" });
      emptyEl.setText("No matching commands");
    } else {
      for (let i = 0; i < this.filteredCommands.length; i++) {
        const cmd = this.filteredCommands[i];
        const itemEl = this.dropdownEl.createDiv({ cls: "claudian-slash-item" });
        if (i === this.selectedIndex) {
          itemEl.addClass("selected");
        }
        const nameEl = itemEl.createSpan({ cls: "claudian-slash-name" });
        nameEl.setText(`/${cmd.name}`);
        if (cmd.argumentHint) {
          const hintEl = itemEl.createSpan({ cls: "claudian-slash-hint" });
          hintEl.setText(`[${cmd.argumentHint}]`);
        }
        if (cmd.description) {
          const descEl = itemEl.createDiv({ cls: "claudian-slash-desc" });
          descEl.setText(cmd.description);
        }
        itemEl.addEventListener("click", () => {
          this.selectedIndex = i;
          this.selectItem();
        });
        itemEl.addEventListener("mouseenter", () => {
          this.selectedIndex = i;
          this.updateSelection();
        });
      }
    }
    this.dropdownEl.addClass("visible");
    if (this.isFixed) {
      this.positionFixed();
    }
  }
  createDropdownElement() {
    if (this.isFixed) {
      const dropdown = this.containerEl.createDiv({
        cls: "claudian-slash-dropdown claudian-slash-dropdown-fixed"
      });
      return dropdown;
    } else {
      return this.containerEl.createDiv({ cls: "claudian-slash-dropdown" });
    }
  }
  positionFixed() {
    if (!this.dropdownEl || !this.isFixed) return;
    const inputRect = this.inputEl.getBoundingClientRect();
    this.dropdownEl.style.position = "fixed";
    this.dropdownEl.style.bottom = `${window.innerHeight - inputRect.top + 4}px`;
    this.dropdownEl.style.left = `${inputRect.left}px`;
    this.dropdownEl.style.right = "auto";
    this.dropdownEl.style.width = `${Math.max(inputRect.width, 280)}px`;
    this.dropdownEl.style.zIndex = "10001";
  }
  navigate(direction) {
    const maxIndex = this.filteredCommands.length - 1;
    this.selectedIndex = Math.max(0, Math.min(maxIndex, this.selectedIndex + direction));
    this.updateSelection();
  }
  updateSelection() {
    var _a;
    const items = (_a = this.dropdownEl) == null ? void 0 : _a.querySelectorAll(".claudian-slash-item");
    items == null ? void 0 : items.forEach((item, index) => {
      if (index === this.selectedIndex) {
        item.addClass("selected");
        item.scrollIntoView({ block: "nearest" });
      } else {
        item.removeClass("selected");
      }
    });
  }
  selectItem() {
    if (this.filteredCommands.length === 0) return;
    const selected = this.filteredCommands[this.selectedIndex];
    if (!selected) return;
    const text = this.getInputValue();
    const beforeSlash = text.substring(0, this.slashStartIndex);
    const afterCursor = text.substring(this.getCursorPosition());
    const replacement = `/${selected.name} `;
    this.setInputValue(beforeSlash + replacement + afterCursor);
    this.setCursorPosition(beforeSlash.length + replacement.length);
    this.hide();
    this.callbacks.onSelect(selected);
    this.inputEl.focus();
  }
};

// src/features/chat/controllers/ConversationController.ts
var import_obsidian9 = require("obsidian");

// src/core/tools/todo.ts
function isValidTodoItem(item) {
  if (typeof item !== "object" || item === null) return false;
  const record2 = item;
  return typeof record2.content === "string" && record2.content.length > 0 && typeof record2.activeForm === "string" && record2.activeForm.length > 0 && typeof record2.status === "string" && ["pending", "in_progress", "completed"].includes(record2.status);
}
function parseTodoInput(input) {
  if (!input.todos || !Array.isArray(input.todos)) {
    return null;
  }
  const validTodos = [];
  const invalidItems = [];
  for (const item of input.todos) {
    if (isValidTodoItem(item)) {
      validTodos.push(item);
    } else {
      invalidItems.push(item);
    }
  }
  return validTodos.length > 0 ? validTodos : null;
}
function extractLastTodosFromMessages(messages) {
  for (let i = messages.length - 1; i >= 0; i--) {
    const msg = messages[i];
    if (msg.role === "assistant" && msg.toolCalls) {
      for (let j = msg.toolCalls.length - 1; j >= 0; j--) {
        const toolCall = msg.toolCalls[j];
        if (toolCall.name === TOOL_TODO_WRITE) {
          const todos = parseTodoInput(toolCall.input);
          return todos;
        }
      }
    }
  }
  return null;
}

// src/core/tools/toolIcons.ts
var TOOL_ICONS = {
  [TOOL_READ]: "file-text",
  [TOOL_WRITE]: "edit-3",
  [TOOL_EDIT]: "edit",
  [TOOL_NOTEBOOK_EDIT]: "edit",
  [TOOL_BASH]: "terminal",
  [TOOL_BASH_OUTPUT]: "terminal",
  [TOOL_KILL_SHELL]: "terminal",
  [TOOL_GLOB]: "folder-search",
  [TOOL_GREP]: "search",
  [TOOL_LS]: "list",
  [TOOL_TODO_WRITE]: "list-checks",
  [TOOL_TASK]: "list-checks",
  [TOOL_LIST_MCP_RESOURCES]: "list",
  [TOOL_READ_MCP_RESOURCE]: "file-text",
  [TOOL_MCP]: "wrench",
  [TOOL_WEB_SEARCH]: "globe",
  [TOOL_WEB_FETCH]: "download",
  [TOOL_AGENT_OUTPUT]: "bot",
  [TOOL_SKILL]: "zap"
};
var MCP_ICON_MARKER = "__mcp_icon__";
function getToolIcon(toolName) {
  if (toolName.startsWith("mcp__")) {
    return MCP_ICON_MARKER;
  }
  return TOOL_ICONS[toolName] || "wrench";
}

// src/features/chat/rendering/DiffRenderer.ts
function computeLineDiff(oldText, newText) {
  const oldLines = oldText.replace(/\r\n/g, "\n").split("\n");
  const newLines = newText.replace(/\r\n/g, "\n").split("\n");
  const m = oldLines.length;
  const n = newLines.length;
  const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
  for (let i2 = 1; i2 <= m; i2++) {
    for (let j2 = 1; j2 <= n; j2++) {
      dp[i2][j2] = oldLines[i2 - 1] === newLines[j2 - 1] ? dp[i2 - 1][j2 - 1] + 1 : Math.max(dp[i2 - 1][j2], dp[i2][j2 - 1]);
    }
  }
  const result = [];
  let i = m, j = n;
  const temp = [];
  while (i > 0 || j > 0) {
    if (i > 0 && j > 0 && oldLines[i - 1] === newLines[j - 1]) {
      temp.push({ type: "equal", text: oldLines[i - 1] });
      i--;
      j--;
    } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
      temp.push({ type: "insert", text: newLines[j - 1] });
      j--;
    } else {
      temp.push({ type: "delete", text: oldLines[i - 1] });
      i--;
    }
  }
  temp.reverse();
  let oldLineNum = 1;
  let newLineNum = 1;
  for (const line of temp) {
    if (line.type === "equal") {
      result.push({ ...line, oldLineNum: oldLineNum++, newLineNum: newLineNum++ });
    } else if (line.type === "delete") {
      result.push({ ...line, oldLineNum: oldLineNum++ });
    } else {
      result.push({ ...line, newLineNum: newLineNum++ });
    }
  }
  return result;
}
function countLineChanges(diffLines) {
  let added = 0;
  let removed = 0;
  for (const line of diffLines) {
    if (line.type === "insert") added++;
    else if (line.type === "delete") removed++;
  }
  return { added, removed };
}
function splitIntoHunks(diffLines, contextLines = 3) {
  if (diffLines.length === 0) return [];
  const changedIndices = [];
  for (let i = 0; i < diffLines.length; i++) {
    if (diffLines[i].type !== "equal") {
      changedIndices.push(i);
    }
  }
  if (changedIndices.length === 0) return [];
  const ranges = [];
  for (const idx of changedIndices) {
    const start = Math.max(0, idx - contextLines);
    const end = Math.min(diffLines.length - 1, idx + contextLines);
    if (ranges.length > 0 && start <= ranges[ranges.length - 1].end + 1) {
      ranges[ranges.length - 1].end = end;
    } else {
      ranges.push({ start, end });
    }
  }
  const hunks = [];
  for (const range of ranges) {
    const lines = diffLines.slice(range.start, range.end + 1);
    let oldStart = 1;
    let newStart = 1;
    for (let i = 0; i < range.start; i++) {
      const line = diffLines[i];
      if (line.type === "equal" || line.type === "delete") oldStart++;
      if (line.type === "equal" || line.type === "insert") newStart++;
    }
    hunks.push({ lines, oldStart, newStart });
  }
  return hunks;
}
function renderDiffContent(containerEl, diffLines, contextLines = 3) {
  containerEl.empty();
  const hunks = splitIntoHunks(diffLines, contextLines);
  if (hunks.length === 0) {
    const noChanges = containerEl.createDiv({ cls: "claudian-diff-no-changes" });
    noChanges.setText("No changes");
    return;
  }
  hunks.forEach((hunk, hunkIndex) => {
    if (hunkIndex > 0) {
      const separator = containerEl.createDiv({ cls: "claudian-diff-separator" });
      separator.setText("...");
    }
    const hunkEl = containerEl.createDiv({ cls: "claudian-diff-hunk" });
    for (const line of hunk.lines) {
      const lineEl = hunkEl.createDiv({ cls: `claudian-diff-line claudian-diff-${line.type}` });
      const prefix = line.type === "insert" ? "+" : line.type === "delete" ? "-" : " ";
      const prefixEl = lineEl.createSpan({ cls: "claudian-diff-prefix" });
      prefixEl.setText(prefix);
      const contentEl = lineEl.createSpan({ cls: "claudian-diff-text" });
      contentEl.setText(line.text || " ");
    }
  });
}
function isBinaryContent(content) {
  const nonPrintable = content.match(/[\x00-\x08\x0B\x0C\x0E-\x1F]/g);
  if (nonPrintable && nonPrintable.length > content.length * 0.1) {
    return true;
  }
  return content.includes("\0");
}

// src/features/chat/rendering/MessageRenderer.ts
var import_obsidian8 = require("obsidian");

// src/utils/fileLink.ts
var WIKILINK_PATTERN_SOURCE = "(?<!!)\\[\\[([^\\]|#^]+)(?:#[^\\]|]+)?(?:\\^[^\\]|]+)?(?:\\|[^\\]]+)?\\]\\]";
function createWikilinkPattern() {
  return new RegExp(WIKILINK_PATTERN_SOURCE, "g");
}
function extractLinkTarget(fullMatch) {
  const inner = fullMatch.slice(2, -2);
  const pipeIndex = inner.indexOf("|");
  return pipeIndex >= 0 ? inner.slice(0, pipeIndex) : inner;
}
function findWikilinks(app, text) {
  const pattern = createWikilinkPattern();
  const matches = [];
  let match;
  while ((match = pattern.exec(text)) !== null) {
    const fullMatch = match[0];
    const linkPath = match[1];
    const linkTarget = extractLinkTarget(fullMatch);
    if (!fileExistsInVault(app, linkPath)) continue;
    const pipeIndex = fullMatch.lastIndexOf("|");
    const displayText = pipeIndex > 0 ? fullMatch.slice(pipeIndex + 1, -2) : linkPath;
    matches.push({ index: match.index, fullMatch, linkPath, linkTarget, displayText });
  }
  return matches.sort((a, b) => b.index - a.index);
}
function fileExistsInVault(app, linkPath) {
  const file = app.metadataCache.getFirstLinkpathDest(linkPath, "");
  if (file) {
    return true;
  }
  const directFile = app.vault.getFileByPath(linkPath);
  if (directFile) {
    return true;
  }
  if (!linkPath.endsWith(".md")) {
    const withExt = app.vault.getFileByPath(linkPath + ".md");
    if (withExt) {
      return true;
    }
  }
  return false;
}
function createWikilink(linkTarget, displayText) {
  const link = document.createElement("a");
  link.className = "claudian-file-link internal-link";
  link.textContent = displayText;
  link.setAttribute("data-href", linkTarget);
  link.setAttribute("href", linkTarget);
  return link;
}
function registerFileLinkHandler(app, container, component) {
  component.registerDomEvent(container, "click", (event) => {
    const target = event.target;
    const link = target.closest(".claudian-file-link, .internal-link");
    if (link) {
      event.preventDefault();
      const linkTarget = link.dataset.href || link.getAttribute("href");
      if (linkTarget) {
        void app.workspace.openLinkText(linkTarget, "", "tab");
      }
    }
  });
}
function buildFragmentWithLinks(text, matches) {
  const fragment = document.createDocumentFragment();
  let currentIndex = text.length;
  for (const { index, fullMatch, linkTarget, displayText } of matches) {
    const endIndex = index + fullMatch.length;
    if (endIndex < currentIndex) {
      fragment.insertBefore(
        document.createTextNode(text.slice(endIndex, currentIndex)),
        fragment.firstChild
      );
    }
    fragment.insertBefore(createWikilink(linkTarget, displayText), fragment.firstChild);
    currentIndex = index;
  }
  if (currentIndex > 0) {
    fragment.insertBefore(
      document.createTextNode(text.slice(0, currentIndex)),
      fragment.firstChild
    );
  }
  return fragment;
}
function processTextNode(app, node) {
  var _a;
  const text = node.textContent;
  if (!text || !text.includes("[[")) return false;
  const matches = findWikilinks(app, text);
  if (matches.length === 0) return false;
  (_a = node.parentNode) == null ? void 0 : _a.replaceChild(buildFragmentWithLinks(text, matches), node);
  return true;
}
function processFileLinks(app, container) {
  if (!app || !container) return;
  container.querySelectorAll("code").forEach((codeEl) => {
    var _a;
    if (((_a = codeEl.parentElement) == null ? void 0 : _a.tagName) === "PRE") return;
    const text = codeEl.textContent;
    if (!text || !text.includes("[[")) return;
    const matches = findWikilinks(app, text);
    if (matches.length === 0) return;
    codeEl.textContent = "";
    codeEl.appendChild(buildFragmentWithLinks(text, matches));
  });
  const walker = document.createTreeWalker(
    container,
    NodeFilter.SHOW_TEXT,
    {
      acceptNode(node2) {
        const parent = node2.parentElement;
        if (!parent) return NodeFilter.FILTER_REJECT;
        const tagName = parent.tagName.toUpperCase();
        if (tagName === "PRE" || tagName === "CODE" || tagName === "A") {
          return NodeFilter.FILTER_REJECT;
        }
        if (parent.closest("pre, code, a, .claudian-file-link, .internal-link")) {
          return NodeFilter.FILTER_REJECT;
        }
        return NodeFilter.FILTER_ACCEPT;
      }
    }
  );
  const textNodes = [];
  let node;
  while (node = walker.nextNode()) {
    textNodes.push(node);
  }
  for (const textNode of textNodes) {
    processTextNode(app, textNode);
  }
}

// src/utils/imageEmbed.ts
var IMAGE_EXTENSIONS = /* @__PURE__ */ new Set([
  "png",
  "jpg",
  "jpeg",
  "gif",
  "webp",
  "svg",
  "bmp",
  "ico"
]);
var IMAGE_EMBED_PATTERN = /!\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g;
function isImagePath(path9) {
  var _a;
  const ext = (_a = path9.split(".").pop()) == null ? void 0 : _a.toLowerCase();
  return ext ? IMAGE_EXTENSIONS.has(ext) : false;
}
function resolveImageFile(app, imagePath, mediaFolder) {
  let file = app.vault.getFileByPath(imagePath);
  if (file) return file;
  if (mediaFolder) {
    const withFolder = `${mediaFolder}/${imagePath}`;
    file = app.vault.getFileByPath(withFolder);
    if (file) return file;
  }
  const resolved = app.metadataCache.getFirstLinkpathDest(imagePath, "");
  if (resolved) return resolved;
  return null;
}
function escapeHtml(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}
function buildStyleAttribute(altText) {
  if (!altText) return "";
  const dimMatch = altText.match(/^(\d+)(?:x(\d+))?$/);
  if (!dimMatch) return "";
  const width = dimMatch[1];
  const height = dimMatch[2];
  if (height) {
    return ` style="width: ${width}px; height: ${height}px;"`;
  }
  return ` style="width: ${width}px;"`;
}
function createImageHtml(app, file, altText) {
  const src = app.vault.getResourcePath(file);
  const alt = escapeHtml(altText || file.basename);
  const style = buildStyleAttribute(altText);
  return `<span class="claudian-embedded-image"><img src="${escapeHtml(src)}" alt="${alt}" loading="lazy"${style}></span>`;
}
function createFallbackHtml(wikilink) {
  return `<span class="claudian-embedded-image-fallback">${escapeHtml(wikilink)}</span>`;
}
function replaceImageEmbedsWithHtml(markdown, app, mediaFolder = "") {
  if (!(app == null ? void 0 : app.vault) || !(app == null ? void 0 : app.metadataCache)) {
    return markdown;
  }
  IMAGE_EMBED_PATTERN.lastIndex = 0;
  return markdown.replace(
    IMAGE_EMBED_PATTERN,
    (match, imagePath, altText) => {
      try {
        if (!isImagePath(imagePath)) {
          return match;
        }
        const file = resolveImageFile(app, imagePath, mediaFolder);
        if (!file) {
          return createFallbackHtml(match);
        }
        return createImageHtml(app, file, altText);
      } catch (e) {
        return createFallbackHtml(match);
      }
    }
  );
}

// src/features/chat/rendering/SubagentRenderer.ts
var import_obsidian6 = require("obsidian");

// src/features/chat/rendering/collapsible.ts
function setupCollapsible(wrapperEl, headerEl, contentEl, state, options = {}) {
  const { initiallyExpanded = false, onToggle, baseAriaLabel } = options;
  const updateAriaLabel = (isExpanded) => {
    if (baseAriaLabel) {
      const action = isExpanded ? "click to collapse" : "click to expand";
      headerEl.setAttribute("aria-label", `${baseAriaLabel} - ${action}`);
    }
  };
  state.isExpanded = initiallyExpanded;
  if (initiallyExpanded) {
    wrapperEl.addClass("expanded");
    contentEl.style.display = "block";
    headerEl.setAttribute("aria-expanded", "true");
  } else {
    contentEl.style.display = "none";
    headerEl.setAttribute("aria-expanded", "false");
  }
  updateAriaLabel(initiallyExpanded);
  const toggleExpand = () => {
    state.isExpanded = !state.isExpanded;
    if (state.isExpanded) {
      wrapperEl.addClass("expanded");
      contentEl.style.display = "block";
      headerEl.setAttribute("aria-expanded", "true");
    } else {
      wrapperEl.removeClass("expanded");
      contentEl.style.display = "none";
      headerEl.setAttribute("aria-expanded", "false");
    }
    updateAriaLabel(state.isExpanded);
    onToggle == null ? void 0 : onToggle(state.isExpanded);
  };
  headerEl.addEventListener("click", toggleExpand);
  headerEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter" || e.key === " ") {
      e.preventDefault();
      toggleExpand();
    }
  });
}
function collapseElement(wrapperEl, headerEl, contentEl, state) {
  state.isExpanded = false;
  wrapperEl.removeClass("expanded");
  contentEl.style.display = "none";
  headerEl.setAttribute("aria-expanded", "false");
}

// src/features/chat/rendering/ToolCallRenderer.ts
var import_obsidian5 = require("obsidian");

// src/shared/icons.ts
var MCP_ICON_SVG = `<svg fill="currentColor" fill-rule="evenodd" height="1em" viewBox="0 0 24 24" width="1em" xmlns="http://www.w3.org/2000/svg"><title>MCP</title><path d="M15.688 2.343a2.588 2.588 0 00-3.61 0l-9.626 9.44a.863.863 0 01-1.203 0 .823.823 0 010-1.18l9.626-9.44a4.313 4.313 0 016.016 0 4.116 4.116 0 011.204 3.54 4.3 4.3 0 013.609 1.18l.05.05a4.115 4.115 0 010 5.9l-8.706 8.537a.274.274 0 000 .393l1.788 1.754a.823.823 0 010 1.18.863.863 0 01-1.203 0l-1.788-1.753a1.92 1.92 0 010-2.754l8.706-8.538a2.47 2.47 0 000-3.54l-.05-.049a2.588 2.588 0 00-3.607-.003l-7.172 7.034-.002.002-.098.097a.863.863 0 01-1.204 0 .823.823 0 010-1.18l7.273-7.133a2.47 2.47 0 00-.003-3.537z"></path><path d="M14.485 4.703a.823.823 0 000-1.18.863.863 0 00-1.204 0l-7.119 6.982a4.115 4.115 0 000 5.9 4.314 4.314 0 006.016 0l7.12-6.982a.823.823 0 000-1.18.863.863 0 00-1.204 0l-7.119 6.982a2.588 2.588 0 01-3.61 0 2.47 2.47 0 010-3.54l7.12-6.982z"></path></svg>`;
var CHECK_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`;

// src/features/chat/rendering/todoUtils.ts
var import_obsidian4 = require("obsidian");
function getTodoStatusIcon(status) {
  return status === "completed" ? "check" : "dot";
}
function getTodoDisplayText(todo) {
  return todo.status === "in_progress" ? todo.activeForm : todo.content;
}
function renderTodoItems(container, todos) {
  container.empty();
  for (const todo of todos) {
    const item = container.createDiv({ cls: `claudian-todo-item claudian-todo-${todo.status}` });
    const icon = item.createSpan({ cls: "claudian-todo-status-icon" });
    icon.setAttribute("aria-hidden", "true");
    (0, import_obsidian4.setIcon)(icon, getTodoStatusIcon(todo.status));
    const text = item.createSpan({ cls: "claudian-todo-text" });
    text.setText(getTodoDisplayText(todo));
  }
}

// src/features/chat/rendering/ToolCallRenderer.ts
function setToolIcon(el, name) {
  const icon = getToolIcon(name);
  if (icon === MCP_ICON_MARKER) {
    el.innerHTML = MCP_ICON_SVG;
  } else {
    (0, import_obsidian5.setIcon)(el, icon);
  }
}
function getToolLabel(name, input) {
  switch (name) {
    case "Read":
      return `Read: ${shortenPath(input.file_path) || "file"}`;
    case "Write":
      return `Write: ${shortenPath(input.file_path) || "file"}`;
    case "Edit":
      return `Edit: ${shortenPath(input.file_path) || "file"}`;
    case "Bash": {
      const cmd = input.command || "command";
      return `Bash: ${cmd.length > 40 ? cmd.substring(0, 40) + "..." : cmd}`;
    }
    case "Glob":
      return `Glob: ${input.pattern || "files"}`;
    case "Grep":
      return `Grep: ${input.pattern || "pattern"}`;
    case "WebSearch": {
      const query2 = input.query || "search";
      return `WebSearch: ${query2.length > 40 ? query2.substring(0, 40) + "..." : query2}`;
    }
    case "WebFetch": {
      const url = input.url || "url";
      return `WebFetch: ${url.length > 40 ? url.substring(0, 40) + "..." : url}`;
    }
    case "LS":
      return `LS: ${shortenPath(input.path) || "."}`;
    case "TodoWrite": {
      const todos = input.todos;
      if (todos && Array.isArray(todos)) {
        const completed = todos.filter((t2) => t2.status === "completed").length;
        return `Tasks (${completed}/${todos.length})`;
      }
      return "Tasks";
    }
    case "Skill": {
      const skillName = input.skill || "skill";
      return `Skill: ${skillName}`;
    }
    default:
      return name;
  }
}
function shortenPath(filePath) {
  if (!filePath) return "";
  const normalized = filePath.replace(/\\/g, "/");
  const parts = normalized.split("/");
  if (parts.length <= 3) return normalized;
  return ".../" + parts.slice(-2).join("/");
}
function parseWebSearchResult(result) {
  const linksMatch = result.match(/Links:\s*(\[[\s\S]*\])/);
  if (!linksMatch) return null;
  try {
    const links = JSON.parse(linksMatch[1]);
    if (!Array.isArray(links) || links.length === 0) return null;
    return links;
  } catch (e) {
    return null;
  }
}
function renderWebSearchResult(container, result, maxItems = 3) {
  const links = parseWebSearchResult(result);
  if (!links) return false;
  container.empty();
  const displayItems = links.slice(0, maxItems);
  displayItems.forEach((link) => {
    const item = container.createSpan({ cls: "claudian-tool-result-bullet" });
    item.setText(`\u2022 ${link.title}`);
  });
  if (links.length > maxItems) {
    const more = container.createSpan({ cls: "claudian-tool-result-item" });
    more.setText(`${links.length - maxItems} more results`);
  }
  return true;
}
function renderReadResult(container, result) {
  container.empty();
  const lines = result.split(/\r?\n/).filter((line) => line.trim() !== "");
  const item = container.createSpan({ cls: "claudian-tool-result-item" });
  item.setText(`${lines.length} lines read`);
}
function renderTodoWriteResult(container, input) {
  container.empty();
  container.addClass("claudian-todo-panel-content");
  const todos = input.todos;
  if (!todos || !Array.isArray(todos)) {
    const item = container.createSpan({ cls: "claudian-tool-result-item" });
    item.setText("Tasks updated");
    return;
  }
  renderTodoItems(container, todos);
}
function renderResultLines(container, result, maxLines = 3) {
  container.empty();
  const lines = result.split(/\r?\n/);
  const displayLines = lines.slice(0, maxLines);
  displayLines.forEach((line) => {
    const stripped = line.replace(/^\s*\d+/, "");
    const item = container.createSpan({ cls: "claudian-tool-result-item" });
    item.setText(stripped);
  });
  if (lines.length > maxLines) {
    const more = container.createSpan({ cls: "claudian-tool-result-item" });
    more.setText(`${lines.length - maxLines} more lines`);
  }
}
function isBlockedToolResult(content, isError) {
  const lower = content.toLowerCase();
  if (lower.includes("blocked by blocklist")) return true;
  if (lower.includes("outside the vault")) return true;
  if (lower.includes("access denied")) return true;
  if (lower.includes("user denied")) return true;
  if (lower.includes("approval")) return true;
  if (isError && lower.includes("deny")) return true;
  return false;
}
function renderToolCall(parentEl, toolCall, toolCallElements) {
  const toolEl = parentEl.createDiv({ cls: "claudian-tool-call" });
  toolEl.dataset.toolId = toolCall.id;
  toolCallElements.set(toolCall.id, toolEl);
  const header = toolEl.createDiv({ cls: "claudian-tool-header" });
  header.setAttribute("tabindex", "0");
  header.setAttribute("role", "button");
  const iconEl = header.createSpan({ cls: "claudian-tool-icon" });
  iconEl.setAttribute("aria-hidden", "true");
  setToolIcon(iconEl, toolCall.name);
  const labelEl = header.createSpan({ cls: "claudian-tool-label" });
  labelEl.setText(getToolLabel(toolCall.name, toolCall.input));
  const statusEl = header.createSpan({ cls: "claudian-tool-status" });
  statusEl.addClass(`status-${toolCall.status}`);
  statusEl.setAttribute("aria-label", `Status: ${toolCall.status}`);
  const content = toolEl.createDiv({ cls: "claudian-tool-content" });
  if (toolCall.name === "TodoWrite") {
    renderTodoWriteResult(content, toolCall.input);
  } else {
    const resultRow = content.createDiv({ cls: "claudian-tool-result-row" });
    const branch = resultRow.createSpan({ cls: "claudian-tool-branch" });
    branch.setText("\u2514\u2500");
    const resultText = resultRow.createSpan({ cls: "claudian-tool-result-text" });
    resultText.setText("Running...");
  }
  const state = { isExpanded: false };
  toolCall.isExpanded = false;
  setupCollapsible(toolEl, header, content, state, {
    initiallyExpanded: false,
    onToggle: (expanded) => {
      toolCall.isExpanded = expanded;
    },
    baseAriaLabel: getToolLabel(toolCall.name, toolCall.input)
  });
  return toolEl;
}
function updateToolCallResult(toolId, toolCall, toolCallElements) {
  const toolEl = toolCallElements.get(toolId);
  if (!toolEl) return;
  const statusEl = toolEl.querySelector(".claudian-tool-status");
  if (statusEl) {
    statusEl.className = "claudian-tool-status";
    statusEl.addClass(`status-${toolCall.status}`);
    statusEl.empty();
    if (toolCall.status === "completed") {
      (0, import_obsidian5.setIcon)(statusEl, "check");
    } else if (toolCall.status === "error") {
      (0, import_obsidian5.setIcon)(statusEl, "x");
    } else if (toolCall.status === "blocked") {
      (0, import_obsidian5.setIcon)(statusEl, "shield-off");
    }
  }
  if (toolCall.name === "TodoWrite") {
    const content = toolEl.querySelector(".claudian-tool-content");
    if (content) {
      renderTodoWriteResult(content, toolCall.input);
    }
    return;
  }
  const resultText = toolEl.querySelector(".claudian-tool-result-text");
  if (resultText && toolCall.result) {
    if (toolCall.name === "WebSearch") {
      if (!renderWebSearchResult(resultText, toolCall.result, 3)) {
        renderResultLines(resultText, toolCall.result, 3);
      }
    } else if (toolCall.name === "Read") {
      renderReadResult(resultText, toolCall.result);
    } else {
      renderResultLines(resultText, toolCall.result, 3);
    }
  }
}
function renderStoredToolCall(parentEl, toolCall) {
  const toolEl = parentEl.createDiv({ cls: "claudian-tool-call" });
  const header = toolEl.createDiv({ cls: "claudian-tool-header" });
  header.setAttribute("tabindex", "0");
  header.setAttribute("role", "button");
  const iconEl = header.createSpan({ cls: "claudian-tool-icon" });
  iconEl.setAttribute("aria-hidden", "true");
  setToolIcon(iconEl, toolCall.name);
  const labelEl = header.createSpan({ cls: "claudian-tool-label" });
  labelEl.setText(getToolLabel(toolCall.name, toolCall.input));
  const statusEl = header.createSpan({ cls: "claudian-tool-status" });
  statusEl.addClass(`status-${toolCall.status}`);
  statusEl.setAttribute("aria-label", `Status: ${toolCall.status}`);
  if (toolCall.status === "completed") {
    (0, import_obsidian5.setIcon)(statusEl, "check");
  } else if (toolCall.status === "error") {
    (0, import_obsidian5.setIcon)(statusEl, "x");
  } else if (toolCall.status === "blocked") {
    (0, import_obsidian5.setIcon)(statusEl, "shield-off");
  }
  const content = toolEl.createDiv({ cls: "claudian-tool-content" });
  if (toolCall.name === "TodoWrite") {
    renderTodoWriteResult(content, toolCall.input);
  } else {
    const resultRow = content.createDiv({ cls: "claudian-tool-result-row" });
    const branch = resultRow.createSpan({ cls: "claudian-tool-branch" });
    branch.setText("\u2514\u2500");
    const resultText = resultRow.createSpan({ cls: "claudian-tool-result-text" });
    if (toolCall.result) {
      if (toolCall.name === "WebSearch") {
        if (!renderWebSearchResult(resultText, toolCall.result, 3)) {
          renderResultLines(resultText, toolCall.result, 3);
        }
      } else if (toolCall.name === "Read") {
        renderReadResult(resultText, toolCall.result);
      } else {
        renderResultLines(resultText, toolCall.result, 3);
      }
    } else {
      resultText.setText("No result");
    }
  }
  const state = { isExpanded: false };
  setupCollapsible(toolEl, header, content, state, {
    initiallyExpanded: false,
    baseAriaLabel: getToolLabel(toolCall.name, toolCall.input)
  });
  return toolEl;
}

// src/features/chat/rendering/SubagentRenderer.ts
function extractTaskDescription(input) {
  return input.description || "Subagent task";
}
function truncateDescription(description, maxLength = 40) {
  if (description.length <= maxLength) return description;
  return description.substring(0, maxLength) + "...";
}
function truncateResult(result) {
  const lines = result.split(/\r?\n/).filter((line) => line.trim());
  if (lines.length <= 2) {
    return lines.join("\n");
  }
  return lines.slice(0, 2).join("\n") + "...";
}
function createSubagentBlock(parentEl, taskToolId, taskInput) {
  const description = extractTaskDescription(taskInput);
  const info = {
    id: taskToolId,
    description,
    status: "running",
    toolCalls: [],
    isExpanded: false
    // Collapsed by default
  };
  const wrapperEl = parentEl.createDiv({ cls: "claudian-subagent-list" });
  wrapperEl.dataset.subagentId = taskToolId;
  const headerEl = wrapperEl.createDiv({ cls: "claudian-subagent-header" });
  headerEl.setAttribute("tabindex", "0");
  headerEl.setAttribute("role", "button");
  headerEl.setAttribute("aria-expanded", "false");
  headerEl.setAttribute("aria-label", `Subagent task: ${truncateDescription(description)} - click to expand`);
  const iconEl = headerEl.createDiv({ cls: "claudian-subagent-icon" });
  iconEl.setAttribute("aria-hidden", "true");
  (0, import_obsidian6.setIcon)(iconEl, "bot");
  const labelEl = headerEl.createDiv({ cls: "claudian-subagent-label" });
  labelEl.setText(truncateDescription(description));
  const countEl = headerEl.createDiv({ cls: "claudian-subagent-count" });
  countEl.setText("0 tool uses");
  const statusEl = headerEl.createDiv({ cls: "claudian-subagent-status status-running" });
  statusEl.setAttribute("aria-label", "Status: running");
  const contentEl = wrapperEl.createDiv({ cls: "claudian-subagent-content" });
  setupCollapsible(wrapperEl, headerEl, contentEl, info);
  return {
    wrapperEl,
    contentEl,
    headerEl,
    labelEl,
    countEl,
    statusEl,
    info,
    currentToolEl: null,
    currentResultEl: null
  };
}
function addSubagentToolCall(state, toolCall) {
  state.info.toolCalls.push(toolCall);
  const toolCount = state.info.toolCalls.length;
  state.countEl.setText(`${toolCount} tool uses`);
  state.contentEl.empty();
  state.currentResultEl = null;
  const itemEl = state.contentEl.createDiv({
    cls: `claudian-subagent-tool-item claudian-subagent-tool-${toolCall.status}`
  });
  itemEl.dataset.toolId = toolCall.id;
  state.currentToolEl = itemEl;
  const toolRowEl = itemEl.createDiv({ cls: "claudian-subagent-tool-row" });
  const branchEl = toolRowEl.createDiv({ cls: "claudian-subagent-branch" });
  branchEl.setText("\u2514\u2500");
  const labelEl = toolRowEl.createDiv({ cls: "claudian-subagent-tool-text" });
  labelEl.setText(getToolLabel(toolCall.name, toolCall.input));
}
function updateSubagentToolResult(state, toolId, toolCall) {
  const idx = state.info.toolCalls.findIndex((tc) => tc.id === toolId);
  if (idx !== -1) {
    state.info.toolCalls[idx] = toolCall;
  }
  if (state.currentToolEl && state.currentToolEl.dataset.toolId === toolId) {
    state.currentToolEl.className = `claudian-subagent-tool-item claudian-subagent-tool-${toolCall.status}`;
    if (toolCall.result) {
      if (!state.currentResultEl) {
        state.currentResultEl = state.currentToolEl.createDiv({ cls: "claudian-subagent-tool-result" });
        const branchEl = state.currentResultEl.createDiv({ cls: "claudian-subagent-branch" });
        branchEl.setText("\u2514\u2500");
        const textEl = state.currentResultEl.createDiv({ cls: "claudian-subagent-result-text" });
        textEl.setText(truncateResult(toolCall.result));
      } else {
        const textEl = state.currentResultEl.querySelector(".claudian-subagent-result-text");
        if (textEl) {
          textEl.setText(truncateResult(toolCall.result));
        }
      }
    }
  }
}
function finalizeSubagentBlock(state, result, isError) {
  state.info.status = isError ? "error" : "completed";
  state.info.result = result;
  state.labelEl.setText(truncateDescription(state.info.description));
  const toolCount = state.info.toolCalls.length;
  state.countEl.setText(`${toolCount} tool uses`);
  state.statusEl.className = "claudian-subagent-status";
  state.statusEl.addClass(`status-${state.info.status}`);
  state.statusEl.empty();
  if (state.info.status === "completed") {
    (0, import_obsidian6.setIcon)(state.statusEl, "check");
  } else {
    (0, import_obsidian6.setIcon)(state.statusEl, "x");
  }
  if (state.info.status === "completed") {
    state.wrapperEl.addClass("done");
  } else if (state.info.status === "error") {
    state.wrapperEl.addClass("error");
  }
  state.contentEl.empty();
  state.currentToolEl = null;
  state.currentResultEl = null;
  const doneEl = state.contentEl.createDiv({ cls: "claudian-subagent-done" });
  const branchEl = doneEl.createDiv({ cls: "claudian-subagent-branch" });
  branchEl.setText("\u2514\u2500");
  const textEl = doneEl.createDiv({ cls: "claudian-subagent-done-text" });
  textEl.setText(isError ? "ERROR" : "DONE");
}
function renderStoredSubagent(parentEl, subagent) {
  const wrapperEl = parentEl.createDiv({ cls: "claudian-subagent-list" });
  if (subagent.status === "completed") {
    wrapperEl.addClass("done");
  } else if (subagent.status === "error") {
    wrapperEl.addClass("error");
  }
  wrapperEl.dataset.subagentId = subagent.id;
  const toolCount = subagent.toolCalls.length;
  const headerEl = wrapperEl.createDiv({ cls: "claudian-subagent-header" });
  headerEl.setAttribute("tabindex", "0");
  headerEl.setAttribute("role", "button");
  headerEl.setAttribute("aria-label", `Subagent task: ${truncateDescription(subagent.description)} - ${toolCount} tool uses - Status: ${subagent.status}`);
  const iconEl = headerEl.createDiv({ cls: "claudian-subagent-icon" });
  iconEl.setAttribute("aria-hidden", "true");
  (0, import_obsidian6.setIcon)(iconEl, "bot");
  const labelEl = headerEl.createDiv({ cls: "claudian-subagent-label" });
  labelEl.setText(truncateDescription(subagent.description));
  const countEl = headerEl.createDiv({ cls: "claudian-subagent-count" });
  countEl.setText(`${toolCount} tool uses`);
  const statusEl = headerEl.createDiv({ cls: `claudian-subagent-status status-${subagent.status}` });
  statusEl.setAttribute("aria-label", `Status: ${subagent.status}`);
  if (subagent.status === "completed") {
    (0, import_obsidian6.setIcon)(statusEl, "check");
  } else if (subagent.status === "error") {
    (0, import_obsidian6.setIcon)(statusEl, "x");
  }
  const contentEl = wrapperEl.createDiv({ cls: "claudian-subagent-content" });
  if (subagent.status === "completed" || subagent.status === "error") {
    const doneEl = contentEl.createDiv({ cls: "claudian-subagent-done" });
    const branchEl = doneEl.createDiv({ cls: "claudian-subagent-branch" });
    branchEl.setText("\u2514\u2500");
    const textEl = doneEl.createDiv({ cls: "claudian-subagent-done-text" });
    textEl.setText(subagent.status === "error" ? "ERROR" : "DONE");
  } else {
    const lastTool = subagent.toolCalls[subagent.toolCalls.length - 1];
    if (lastTool) {
      const itemEl = contentEl.createDiv({
        cls: `claudian-subagent-tool-item claudian-subagent-tool-${lastTool.status}`
      });
      const toolRowEl = itemEl.createDiv({ cls: "claudian-subagent-tool-row" });
      const branchEl = toolRowEl.createDiv({ cls: "claudian-subagent-branch" });
      branchEl.setText("\u2514\u2500");
      const toolLabelEl = toolRowEl.createDiv({ cls: "claudian-subagent-tool-text" });
      toolLabelEl.setText(getToolLabel(lastTool.name, lastTool.input));
      if (lastTool.result) {
        const resultEl = itemEl.createDiv({ cls: "claudian-subagent-tool-result" });
        const resultBranchEl = resultEl.createDiv({ cls: "claudian-subagent-branch" });
        resultBranchEl.setText("\u2514\u2500");
        const textEl = resultEl.createDiv({ cls: "claudian-subagent-result-text" });
        textEl.setText(truncateResult(lastTool.result));
      }
    }
  }
  const state = { isExpanded: false };
  setupCollapsible(wrapperEl, headerEl, contentEl, state);
  return wrapperEl;
}
function setAsyncWrapperStatus(wrapperEl, status) {
  const classes = ["pending", "running", "awaiting", "completed", "error", "orphaned", "async"];
  classes.forEach((cls) => wrapperEl.removeClass(cls));
  wrapperEl.addClass("async");
  wrapperEl.addClass(status);
}
function getAsyncDisplayStatus(asyncStatus) {
  if (asyncStatus === "completed") return "completed";
  if (asyncStatus === "error") return "error";
  if (asyncStatus === "orphaned") return "orphaned";
  return "running";
}
function getAsyncStatusText(asyncStatus) {
  const display = getAsyncDisplayStatus(asyncStatus);
  if (display === "completed") return "Completed";
  if (display === "error") return "Error";
  if (display === "orphaned") return "Orphaned";
  return "Running";
}
function updateAsyncLabel(state, _displayStatus) {
  state.labelEl.setText(truncateDescription(state.info.description));
}
function createAsyncSubagentBlock(parentEl, taskToolId, taskInput) {
  const description = taskInput.description || "Background task";
  const info = {
    id: taskToolId,
    description,
    mode: "async",
    status: "running",
    toolCalls: [],
    isExpanded: false,
    // Collapsed by default for async
    asyncStatus: "pending"
  };
  const wrapperEl = parentEl.createDiv({ cls: "claudian-subagent-list" });
  setAsyncWrapperStatus(wrapperEl, "pending");
  wrapperEl.dataset.asyncSubagentId = taskToolId;
  const headerEl = wrapperEl.createDiv({ cls: "claudian-subagent-header" });
  headerEl.setAttribute("tabindex", "0");
  headerEl.setAttribute("role", "button");
  headerEl.setAttribute("aria-expanded", "false");
  headerEl.setAttribute("aria-label", `Background task: ${description} - Status: running`);
  const iconEl = headerEl.createDiv({ cls: "claudian-subagent-icon" });
  iconEl.setAttribute("aria-hidden", "true");
  (0, import_obsidian6.setIcon)(iconEl, "bot");
  const labelEl = headerEl.createDiv({ cls: "claudian-subagent-label" });
  labelEl.setText(truncateDescription(description));
  const statusTextEl = headerEl.createDiv({ cls: "claudian-subagent-status-text" });
  statusTextEl.setText("Running");
  const statusEl = headerEl.createDiv({ cls: "claudian-subagent-status status-running" });
  statusEl.setAttribute("aria-label", "Status: running");
  const contentEl = wrapperEl.createDiv({ cls: "claudian-subagent-content" });
  const statusRow = contentEl.createDiv({ cls: "claudian-subagent-done" });
  const branchEl = statusRow.createDiv({ cls: "claudian-subagent-branch" });
  branchEl.setText("\u2514\u2500");
  const textEl = statusRow.createDiv({ cls: "claudian-subagent-done-text" });
  textEl.setText("run in background");
  setupCollapsible(wrapperEl, headerEl, contentEl, info);
  return {
    wrapperEl,
    contentEl,
    headerEl,
    labelEl,
    statusTextEl,
    statusEl,
    info
  };
}
function updateAsyncSubagentRunning(state, agentId) {
  state.info.asyncStatus = "running";
  state.info.agentId = agentId;
  setAsyncWrapperStatus(state.wrapperEl, "running");
  updateAsyncLabel(state, "running");
  state.statusTextEl.setText("Running");
  state.contentEl.empty();
  const statusRow = state.contentEl.createDiv({ cls: "claudian-subagent-done" });
  const branchEl = statusRow.createDiv({ cls: "claudian-subagent-branch" });
  branchEl.setText("\u2514\u2500");
  const textEl = statusRow.createDiv({ cls: "claudian-subagent-done-text claudian-async-agent-id" });
  const shortId = agentId.length > 12 ? agentId.substring(0, 12) + "..." : agentId;
  textEl.setText(`run in background (${shortId})`);
}
function finalizeAsyncSubagent(state, result, isError) {
  state.info.asyncStatus = isError ? "error" : "completed";
  state.info.status = isError ? "error" : "completed";
  state.info.result = result;
  setAsyncWrapperStatus(state.wrapperEl, isError ? "error" : "completed");
  updateAsyncLabel(state, isError ? "error" : "completed");
  state.statusTextEl.setText(isError ? "Error" : "Completed");
  state.statusEl.className = "claudian-subagent-status";
  state.statusEl.addClass(`status-${isError ? "error" : "completed"}`);
  state.statusEl.empty();
  if (isError) {
    (0, import_obsidian6.setIcon)(state.statusEl, "x");
  } else {
    (0, import_obsidian6.setIcon)(state.statusEl, "check");
  }
  if (isError) {
    state.wrapperEl.addClass("error");
  } else {
    state.wrapperEl.addClass("done");
  }
  state.contentEl.empty();
  const resultEl = state.contentEl.createDiv({ cls: "claudian-subagent-done" });
  const branchEl = resultEl.createDiv({ cls: "claudian-subagent-branch" });
  branchEl.setText("\u2514\u2500");
  const textEl = resultEl.createDiv({ cls: "claudian-subagent-done-text" });
  if (isError && result) {
    const truncated = result.length > 80 ? result.substring(0, 80) + "..." : result;
    textEl.setText(`ERROR: ${truncated}`);
  } else {
    textEl.setText(isError ? "ERROR" : "DONE");
  }
}
function markAsyncSubagentOrphaned(state) {
  state.info.asyncStatus = "orphaned";
  state.info.status = "error";
  state.info.result = "Conversation ended before task completed";
  setAsyncWrapperStatus(state.wrapperEl, "orphaned");
  updateAsyncLabel(state, "orphaned");
  state.statusTextEl.setText("Orphaned");
  state.statusEl.className = "claudian-subagent-status status-error";
  state.statusEl.empty();
  (0, import_obsidian6.setIcon)(state.statusEl, "alert-circle");
  state.wrapperEl.addClass("error");
  state.wrapperEl.addClass("orphaned");
  state.contentEl.empty();
  const orphanEl = state.contentEl.createDiv({ cls: "claudian-subagent-done claudian-async-orphaned" });
  const branchEl = orphanEl.createDiv({ cls: "claudian-subagent-branch" });
  branchEl.setText("\u2514\u2500");
  const textEl = orphanEl.createDiv({ cls: "claudian-subagent-done-text" });
  textEl.setText("\u26A0\uFE0F Task orphaned");
}
function renderStoredAsyncSubagent(parentEl, subagent) {
  const wrapperEl = parentEl.createDiv({ cls: "claudian-subagent-list" });
  const statusClass = getAsyncDisplayStatus(subagent.asyncStatus);
  setAsyncWrapperStatus(wrapperEl, statusClass);
  if (subagent.asyncStatus === "completed") {
    wrapperEl.addClass("done");
  } else if (subagent.asyncStatus === "error" || subagent.asyncStatus === "orphaned") {
    wrapperEl.addClass("error");
  }
  wrapperEl.dataset.asyncSubagentId = subagent.id;
  const displayStatus = getAsyncDisplayStatus(subagent.asyncStatus);
  const statusText = getAsyncStatusText(subagent.asyncStatus);
  const headerEl = wrapperEl.createDiv({ cls: "claudian-subagent-header" });
  headerEl.setAttribute("tabindex", "0");
  headerEl.setAttribute("role", "button");
  headerEl.setAttribute("aria-label", `Background task: ${subagent.description} - Status: ${statusText}`);
  const iconEl = headerEl.createDiv({ cls: "claudian-subagent-icon" });
  iconEl.setAttribute("aria-hidden", "true");
  (0, import_obsidian6.setIcon)(iconEl, "bot");
  const labelEl = headerEl.createDiv({ cls: "claudian-subagent-label" });
  labelEl.setText(truncateDescription(subagent.description));
  const statusTextEl = headerEl.createDiv({ cls: "claudian-subagent-status-text" });
  statusTextEl.setText(statusText);
  const statusIconClass = displayStatus === "error" || displayStatus === "orphaned" ? "status-error" : displayStatus === "completed" ? "status-completed" : "status-running";
  const statusEl = headerEl.createDiv({ cls: `claudian-subagent-status ${statusIconClass}` });
  statusEl.setAttribute("aria-label", `Status: ${statusText}`);
  if (subagent.asyncStatus === "completed") {
    (0, import_obsidian6.setIcon)(statusEl, "check");
  } else if (subagent.asyncStatus === "error" || subagent.asyncStatus === "orphaned") {
    (0, import_obsidian6.setIcon)(statusEl, subagent.asyncStatus === "orphaned" ? "alert-circle" : "x");
  }
  const contentEl = wrapperEl.createDiv({ cls: "claudian-subagent-content" });
  const statusRow = contentEl.createDiv({ cls: "claudian-subagent-done" });
  const branchEl = statusRow.createDiv({ cls: "claudian-subagent-branch" });
  branchEl.setText("\u2514\u2500");
  const textEl = statusRow.createDiv({ cls: "claudian-subagent-done-text" });
  if (subagent.asyncStatus === "completed") {
    textEl.setText("DONE");
  } else if (subagent.asyncStatus === "error") {
    textEl.setText("ERROR");
  } else if (subagent.asyncStatus === "orphaned") {
    textEl.setText("\u26A0\uFE0F Task orphaned");
  } else if (subagent.agentId) {
    const shortId = subagent.agentId.length > 12 ? subagent.agentId.substring(0, 12) + "..." : subagent.agentId;
    textEl.setText(`run in background (${shortId})`);
  } else {
    textEl.setText("run in background");
  }
  const state = { isExpanded: false };
  setupCollapsible(wrapperEl, headerEl, contentEl, state);
  return wrapperEl;
}

// src/features/chat/rendering/ThinkingBlockRenderer.ts
function createThinkingBlock(parentEl, renderContent) {
  const wrapperEl = parentEl.createDiv({ cls: "claudian-thinking-block" });
  const header = wrapperEl.createDiv({ cls: "claudian-thinking-header" });
  header.setAttribute("tabindex", "0");
  header.setAttribute("role", "button");
  header.setAttribute("aria-expanded", "false");
  header.setAttribute("aria-label", "Extended thinking - click to expand");
  const labelEl = header.createSpan({ cls: "claudian-thinking-label" });
  const startTime = Date.now();
  labelEl.setText("Thinking 0s...");
  const timerInterval = setInterval(() => {
    const elapsed = Math.floor((Date.now() - startTime) / 1e3);
    labelEl.setText(`Thinking ${elapsed}s...`);
  }, 1e3);
  const contentEl = wrapperEl.createDiv({ cls: "claudian-thinking-content" });
  const state = {
    wrapperEl,
    contentEl,
    labelEl,
    content: "",
    startTime,
    timerInterval,
    isExpanded: false
  };
  setupCollapsible(wrapperEl, header, contentEl, state);
  return state;
}
async function appendThinkingContent(state, content, renderContent) {
  state.content += content;
  await renderContent(state.contentEl, state.content);
}
function finalizeThinkingBlock(state) {
  if (state.timerInterval) {
    clearInterval(state.timerInterval);
    state.timerInterval = null;
  }
  const durationSeconds = Math.floor((Date.now() - state.startTime) / 1e3);
  state.labelEl.setText(`Thought for ${durationSeconds}s`);
  const header = state.wrapperEl.querySelector(".claudian-thinking-header");
  if (header) {
    collapseElement(state.wrapperEl, header, state.contentEl, state);
  }
  return durationSeconds;
}
function cleanupThinkingBlock(state) {
  if (state == null ? void 0 : state.timerInterval) {
    clearInterval(state.timerInterval);
  }
}
function renderStoredThinkingBlock(parentEl, content, durationSeconds, renderContent) {
  const wrapperEl = parentEl.createDiv({ cls: "claudian-thinking-block" });
  const header = wrapperEl.createDiv({ cls: "claudian-thinking-header" });
  header.setAttribute("tabindex", "0");
  header.setAttribute("role", "button");
  header.setAttribute("aria-label", "Extended thinking - click to expand");
  const labelEl = header.createSpan({ cls: "claudian-thinking-label" });
  const labelText = durationSeconds !== void 0 ? `Thought for ${durationSeconds}s` : "Thinking";
  labelEl.setText(labelText);
  const contentEl = wrapperEl.createDiv({ cls: "claudian-thinking-content" });
  renderContent(contentEl, content);
  const state = { isExpanded: false };
  setupCollapsible(wrapperEl, header, contentEl, state);
  return wrapperEl;
}

// src/features/chat/rendering/WriteEditRenderer.ts
var import_obsidian7 = require("obsidian");
function shortenPath2(filePath, maxLength = 40) {
  if (!filePath) return "file";
  const normalized = filePath.replace(/\\/g, "/");
  if (normalized.length <= maxLength) return normalized;
  const parts = normalized.split("/");
  if (parts.length <= 2) {
    return "..." + normalized.slice(-maxLength + 3);
  }
  const filename = parts[parts.length - 1];
  const firstDir = parts[0];
  const available = maxLength - firstDir.length - filename.length - 5;
  if (available < 0) {
    return "..." + filename.slice(-maxLength + 3);
  }
  return `${firstDir}/.../${filename}`;
}
function createWriteEditBlock(parentEl, toolCall) {
  const filePath = toolCall.input.file_path || "file";
  const toolName = toolCall.name;
  const wrapperEl = parentEl.createDiv({ cls: "claudian-write-edit-block" });
  wrapperEl.dataset.toolId = toolCall.id;
  const headerEl = wrapperEl.createDiv({ cls: "claudian-write-edit-header" });
  headerEl.setAttribute("tabindex", "0");
  headerEl.setAttribute("role", "button");
  headerEl.setAttribute("aria-label", `${toolName}: ${shortenPath2(filePath)} - click to expand`);
  const iconEl = headerEl.createDiv({ cls: "claudian-write-edit-icon" });
  iconEl.setAttribute("aria-hidden", "true");
  (0, import_obsidian7.setIcon)(iconEl, toolName === TOOL_EDIT ? "file-pen" : "file-plus");
  const labelEl = headerEl.createDiv({ cls: "claudian-write-edit-label" });
  labelEl.setText(`${toolName}: ${shortenPath2(filePath)}`);
  const statsEl = headerEl.createDiv({ cls: "claudian-write-edit-stats" });
  const statusEl = headerEl.createDiv({ cls: "claudian-write-edit-status status-running" });
  statusEl.setAttribute("aria-label", "Status: running");
  const contentEl = wrapperEl.createDiv({ cls: "claudian-write-edit-content" });
  const loadingRow = contentEl.createDiv({ cls: "claudian-write-edit-diff-row" });
  const loadingEl = loadingRow.createDiv({ cls: "claudian-write-edit-loading" });
  loadingEl.setText("Writing...");
  const state = {
    wrapperEl,
    contentEl,
    headerEl,
    labelEl,
    statsEl,
    statusEl,
    toolCall,
    isExpanded: false
  };
  setupCollapsible(wrapperEl, headerEl, contentEl, state);
  return state;
}
function updateWriteEditWithDiff(state, diffData) {
  state.statsEl.empty();
  state.contentEl.empty();
  if (diffData.skippedReason === "too_large") {
    const row2 = state.contentEl.createDiv({ cls: "claudian-write-edit-diff-row" });
    const skipEl = row2.createDiv({ cls: "claudian-write-edit-binary" });
    skipEl.setText("Diff skipped: file too large");
    return;
  }
  if (diffData.skippedReason === "unavailable" || diffData.originalContent === void 0 || diffData.newContent === void 0) {
    const row2 = state.contentEl.createDiv({ cls: "claudian-write-edit-diff-row" });
    const skipEl = row2.createDiv({ cls: "claudian-write-edit-binary" });
    skipEl.setText("Diff unavailable");
    return;
  }
  const { originalContent, newContent } = diffData;
  if (isBinaryContent(originalContent) || isBinaryContent(newContent)) {
    const row2 = state.contentEl.createDiv({ cls: "claudian-write-edit-diff-row" });
    const binaryEl = row2.createDiv({ cls: "claudian-write-edit-binary" });
    binaryEl.setText("Binary file");
    return;
  }
  const diffLines = computeLineDiff(originalContent, newContent);
  state.diffLines = diffLines;
  const stats = countLineChanges(diffLines);
  if (stats.added > 0) {
    const addedEl = state.statsEl.createSpan({ cls: "added" });
    addedEl.setText(`+${stats.added}`);
  }
  if (stats.removed > 0) {
    if (stats.added > 0) {
      state.statsEl.createSpan({ text: " " });
    }
    const removedEl = state.statsEl.createSpan({ cls: "removed" });
    removedEl.setText(`-${stats.removed}`);
  }
  const row = state.contentEl.createDiv({ cls: "claudian-write-edit-diff-row" });
  const diffEl = row.createDiv({ cls: "claudian-write-edit-diff" });
  renderDiffContent(diffEl, diffLines);
}
function finalizeWriteEditBlock(state, isError) {
  state.statusEl.className = "claudian-write-edit-status";
  state.statusEl.empty();
  if (isError) {
    state.statusEl.addClass("status-error");
    (0, import_obsidian7.setIcon)(state.statusEl, "x");
    state.statusEl.setAttribute("aria-label", "Status: error");
    if (!state.diffLines) {
      state.contentEl.empty();
      const row = state.contentEl.createDiv({ cls: "claudian-write-edit-diff-row" });
      const errorEl = row.createDiv({ cls: "claudian-write-edit-error" });
      errorEl.setText(state.toolCall.result || "Error");
    }
  }
  if (isError) {
    state.wrapperEl.addClass("error");
  } else {
    state.wrapperEl.addClass("done");
  }
}
function renderStoredWriteEdit(parentEl, toolCall) {
  const filePath = toolCall.input.file_path || "file";
  const toolName = toolCall.name;
  const isError = toolCall.status === "error" || toolCall.status === "blocked";
  const wrapperEl = parentEl.createDiv({ cls: "claudian-write-edit-block" });
  if (isError) {
    wrapperEl.addClass("error");
  } else if (toolCall.status === "completed") {
    wrapperEl.addClass("done");
  }
  wrapperEl.dataset.toolId = toolCall.id;
  const headerEl = wrapperEl.createDiv({ cls: "claudian-write-edit-header" });
  headerEl.setAttribute("tabindex", "0");
  headerEl.setAttribute("role", "button");
  const iconEl = headerEl.createDiv({ cls: "claudian-write-edit-icon" });
  iconEl.setAttribute("aria-hidden", "true");
  (0, import_obsidian7.setIcon)(iconEl, toolName === TOOL_EDIT ? "file-pen" : "file-plus");
  const labelEl = headerEl.createDiv({ cls: "claudian-write-edit-label" });
  labelEl.setText(`${toolName}: ${shortenPath2(filePath)}`);
  const statsEl = headerEl.createDiv({ cls: "claudian-write-edit-stats" });
  if (toolCall.diffData && !toolCall.diffData.skippedReason && toolCall.diffData.originalContent !== void 0 && toolCall.diffData.newContent !== void 0) {
    const diffLines = computeLineDiff(toolCall.diffData.originalContent, toolCall.diffData.newContent);
    const stats = countLineChanges(diffLines);
    if (stats.added > 0) {
      const addedEl = statsEl.createSpan({ cls: "added" });
      addedEl.setText(`+${stats.added}`);
    }
    if (stats.removed > 0) {
      if (stats.added > 0) {
        statsEl.createSpan({ text: " " });
      }
      const removedEl = statsEl.createSpan({ cls: "removed" });
      removedEl.setText(`-${stats.removed}`);
    }
  }
  const statusEl = headerEl.createDiv({ cls: "claudian-write-edit-status" });
  if (isError) {
    statusEl.addClass("status-error");
    (0, import_obsidian7.setIcon)(statusEl, "x");
  }
  const contentEl = wrapperEl.createDiv({ cls: "claudian-write-edit-content" });
  const row = contentEl.createDiv({ cls: "claudian-write-edit-diff-row" });
  if (toolCall.diffData) {
    if (toolCall.diffData.skippedReason === "too_large") {
      const skipEl = row.createDiv({ cls: "claudian-write-edit-binary" });
      skipEl.setText("Diff skipped: file too large");
    } else if (toolCall.diffData.skippedReason === "unavailable" || toolCall.diffData.originalContent === void 0 || toolCall.diffData.newContent === void 0) {
      const skipEl = row.createDiv({ cls: "claudian-write-edit-binary" });
      skipEl.setText("Diff unavailable");
    } else {
      const diffEl = row.createDiv({ cls: "claudian-write-edit-diff" });
      const diffLines = computeLineDiff(toolCall.diffData.originalContent, toolCall.diffData.newContent);
      renderDiffContent(diffEl, diffLines);
    }
  } else if (isError && toolCall.result) {
    const errorEl = row.createDiv({ cls: "claudian-write-edit-error" });
    errorEl.setText(toolCall.result);
  } else {
    const doneEl = row.createDiv({ cls: "claudian-write-edit-done-text" });
    doneEl.setText(isError ? "ERROR" : "DONE");
  }
  const state = { isExpanded: false };
  setupCollapsible(wrapperEl, headerEl, contentEl, state);
  return wrapperEl;
}

// src/features/chat/rendering/MessageRenderer.ts
var _MessageRenderer = class _MessageRenderer {
  constructor(plugin, component, messagesEl) {
    this.app = plugin.app;
    this.plugin = plugin;
    this.component = component;
    this.messagesEl = messagesEl;
    registerFileLinkHandler(this.app, this.messagesEl, this.component);
  }
  /** Sets the messages container element. */
  setMessagesEl(el) {
    this.messagesEl = el;
  }
  // ============================================
  // Streaming Message Rendering
  // ============================================
  /**
   * Adds a new message to the chat during streaming.
   * Returns the message element for content updates.
   */
  addMessage(msg) {
    var _a, _b;
    if (msg.role === "user" && msg.images && msg.images.length > 0) {
      this.renderMessageImages(this.messagesEl, msg.images);
    }
    if (msg.role === "user") {
      const textToShow = (_a = msg.displayContent) != null ? _a : msg.content;
      if (!textToShow) {
        this.scrollToBottom();
        const lastChild = this.messagesEl.lastElementChild;
        return lastChild != null ? lastChild : this.messagesEl;
      }
    }
    const msgEl = this.messagesEl.createDiv({
      cls: `claudian-message claudian-message-${msg.role}`
    });
    const contentEl = msgEl.createDiv({ cls: "claudian-message-content" });
    if (msg.role === "user") {
      const textToShow = (_b = msg.displayContent) != null ? _b : msg.content;
      if (textToShow) {
        const textEl = contentEl.createDiv({ cls: "claudian-text-block" });
        void this.renderContent(textEl, textToShow);
      }
    }
    this.scrollToBottom();
    return msgEl;
  }
  // ============================================
  // Stored Message Rendering (Batch/Replay)
  // ============================================
  /**
   * Renders all messages for conversation load/switch.
   * @param messages Array of messages to render
   * @param getGreeting Function to get greeting text
   * @returns The newly created welcome element
   */
  renderMessages(messages, getGreeting) {
    this.messagesEl.empty();
    const newWelcomeEl = this.messagesEl.createDiv({ cls: "claudian-welcome" });
    newWelcomeEl.createDiv({ cls: "claudian-welcome-greeting", text: getGreeting() });
    for (const msg of messages) {
      this.renderStoredMessage(msg);
    }
    this.scrollToBottom();
    return newWelcomeEl;
  }
  /**
   * Renders a persisted message from history.
   */
  renderStoredMessage(msg) {
    var _a, _b;
    if (msg.isInterrupt) {
      this.renderInterruptMessage();
      return;
    }
    if (msg.isRebuiltContext) {
      return;
    }
    if (msg.role === "user" && msg.images && msg.images.length > 0) {
      this.renderMessageImages(this.messagesEl, msg.images);
    }
    if (msg.role === "user") {
      const textToShow = (_a = msg.displayContent) != null ? _a : msg.content;
      if (!textToShow) {
        return;
      }
    }
    const msgEl = this.messagesEl.createDiv({
      cls: `claudian-message claudian-message-${msg.role}`
    });
    const contentEl = msgEl.createDiv({ cls: "claudian-message-content" });
    if (msg.role === "user") {
      const textToShow = (_b = msg.displayContent) != null ? _b : msg.content;
      if (textToShow) {
        const textEl = contentEl.createDiv({ cls: "claudian-text-block" });
        void this.renderContent(textEl, textToShow);
      }
    } else if (msg.role === "assistant") {
      this.renderAssistantContent(msg, contentEl);
    }
  }
  /**
   * Renders an interrupt indicator (stored interrupts from SDK history).
   * Uses the same styling as streaming interrupts.
   */
  renderInterruptMessage() {
    const msgEl = this.messagesEl.createDiv({ cls: "claudian-message claudian-message-assistant" });
    const contentEl = msgEl.createDiv({ cls: "claudian-message-content" });
    const textEl = contentEl.createDiv({ cls: "claudian-text-block" });
    textEl.innerHTML = '<span class="claudian-interrupted">Interrupted</span> <span class="claudian-interrupted-hint">\xB7 What should Claudian do instead?</span>';
  }
  /**
   * Renders assistant message content (content blocks or fallback).
   */
  renderAssistantContent(msg, contentEl) {
    var _a, _b;
    if (msg.contentBlocks && msg.contentBlocks.length > 0) {
      for (const block of msg.contentBlocks) {
        if (block.type === "thinking") {
          renderStoredThinkingBlock(
            contentEl,
            block.content,
            block.durationSeconds,
            (el, md) => this.renderContent(el, md)
          );
        } else if (block.type === "text") {
          if (!block.content || !block.content.trim()) {
            continue;
          }
          const textEl = contentEl.createDiv({ cls: "claudian-text-block" });
          void this.renderContent(textEl, block.content);
          this.addTextCopyButton(textEl, block.content);
        } else if (block.type === "tool_use") {
          const toolCall = (_a = msg.toolCalls) == null ? void 0 : _a.find((tc) => tc.id === block.toolId);
          if (toolCall) {
            this.renderToolCall(contentEl, toolCall);
          }
        } else if (block.type === "subagent") {
          const subagent = (_b = msg.subagents) == null ? void 0 : _b.find((s) => s.id === block.subagentId);
          if (subagent) {
            const mode = block.mode || subagent.mode || "sync";
            if (mode === "async") {
              renderStoredAsyncSubagent(contentEl, subagent);
            } else {
              renderStoredSubagent(contentEl, subagent);
            }
          }
        }
      }
    } else {
      if (msg.content) {
        const textEl = contentEl.createDiv({ cls: "claudian-text-block" });
        void this.renderContent(textEl, msg.content);
        this.addTextCopyButton(textEl, msg.content);
      }
      if (msg.toolCalls) {
        for (const toolCall of msg.toolCalls) {
          this.renderToolCall(contentEl, toolCall);
        }
      }
    }
  }
  /**
   * Renders a tool call with special handling for Write/Edit.
   */
  renderToolCall(contentEl, toolCall) {
    if (isWriteEditTool(toolCall.name)) {
      renderStoredWriteEdit(contentEl, toolCall);
    } else {
      renderStoredToolCall(contentEl, toolCall);
    }
  }
  // ============================================
  // Image Rendering
  // ============================================
  /**
   * Renders image attachments above a message.
   */
  renderMessageImages(containerEl, images) {
    const imagesEl = containerEl.createDiv({ cls: "claudian-message-images" });
    for (const image of images) {
      const imageWrapper = imagesEl.createDiv({ cls: "claudian-message-image" });
      const imgEl = imageWrapper.createEl("img", {
        attr: {
          alt: image.name
        }
      });
      void this.setImageSrc(imgEl, image);
      imgEl.addEventListener("click", () => {
        void this.showFullImage(image);
      });
    }
  }
  /**
   * Shows full-size image in modal overlay.
   */
  showFullImage(image) {
    const dataUri = `data:${image.mediaType};base64,${image.data}`;
    const overlay = document.body.createDiv({ cls: "claudian-image-modal-overlay" });
    const modal = overlay.createDiv({ cls: "claudian-image-modal" });
    modal.createEl("img", {
      attr: {
        src: dataUri,
        alt: image.name
      }
    });
    const closeBtn = modal.createDiv({ cls: "claudian-image-modal-close" });
    closeBtn.setText("\xD7");
    const handleEsc = (e) => {
      if (e.key === "Escape") {
        close();
      }
    };
    const close = () => {
      document.removeEventListener("keydown", handleEsc);
      overlay.remove();
    };
    closeBtn.addEventListener("click", close);
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) close();
    });
    document.addEventListener("keydown", handleEsc);
  }
  /**
   * Sets image src from attachment data.
   */
  setImageSrc(imgEl, image) {
    const dataUri = `data:${image.mediaType};base64,${image.data}`;
    imgEl.setAttribute("src", dataUri);
  }
  // ============================================
  // Content Rendering
  // ============================================
  /**
   * Renders markdown content with code block enhancements.
   */
  async renderContent(el, markdown) {
    el.empty();
    try {
      const processedMarkdown = replaceImageEmbedsWithHtml(
        markdown,
        this.app,
        this.plugin.settings.mediaFolder
      );
      await import_obsidian8.MarkdownRenderer.renderMarkdown(processedMarkdown, el, "", this.component);
      el.querySelectorAll("pre").forEach((pre) => {
        var _a, _b;
        if ((_a = pre.parentElement) == null ? void 0 : _a.classList.contains("claudian-code-wrapper")) return;
        const wrapper = createEl("div", { cls: "claudian-code-wrapper" });
        (_b = pre.parentElement) == null ? void 0 : _b.insertBefore(wrapper, pre);
        wrapper.appendChild(pre);
        const code = pre.querySelector('code[class*="language-"]');
        if (code) {
          const match = code.className.match(/language-(\w+)/);
          if (match) {
            wrapper.classList.add("has-language");
            const label = createEl("span", {
              cls: "claudian-code-lang-label",
              text: match[1]
            });
            wrapper.appendChild(label);
            label.addEventListener("click", async () => {
              try {
                await navigator.clipboard.writeText(code.textContent || "");
                label.setText("copied!");
                setTimeout(() => label.setText(match[1]), 1500);
              } catch (e) {
              }
            });
          }
        }
        const copyBtn = pre.querySelector(".copy-code-button");
        if (copyBtn) {
          wrapper.appendChild(copyBtn);
        }
      });
      processFileLinks(this.app, el);
    } catch (e) {
      el.createDiv({
        cls: "claudian-render-error",
        text: "Failed to render message content."
      });
    }
  }
  /**
   * Adds a copy button to a text block.
   * Button shows clipboard icon on hover, changes to "copied!" on click.
   * @param textEl The rendered text element
   * @param markdown The original markdown content to copy
   */
  addTextCopyButton(textEl, markdown) {
    const copyBtn = textEl.createSpan({ cls: "claudian-text-copy-btn" });
    copyBtn.innerHTML = _MessageRenderer.COPY_ICON;
    let feedbackTimeout = null;
    copyBtn.addEventListener("click", async (e) => {
      e.stopPropagation();
      try {
        await navigator.clipboard.writeText(markdown);
      } catch (e2) {
        return;
      }
      if (feedbackTimeout) {
        clearTimeout(feedbackTimeout);
      }
      copyBtn.innerHTML = "";
      copyBtn.setText("copied!");
      copyBtn.classList.add("copied");
      feedbackTimeout = setTimeout(() => {
        copyBtn.innerHTML = _MessageRenderer.COPY_ICON;
        copyBtn.classList.remove("copied");
        feedbackTimeout = null;
      }, 1500);
    });
  }
  // ============================================
  // Utilities
  // ============================================
  /** Scrolls messages container to bottom. */
  scrollToBottom() {
    this.messagesEl.scrollTop = this.messagesEl.scrollHeight;
  }
  /** Scrolls to bottom if already near bottom (within threshold). */
  scrollToBottomIfNeeded(threshold = 100) {
    const { scrollTop, scrollHeight, clientHeight } = this.messagesEl;
    const isNearBottom = scrollHeight - scrollTop - clientHeight < threshold;
    if (isNearBottom) {
      requestAnimationFrame(() => {
        this.messagesEl.scrollTop = this.messagesEl.scrollHeight;
      });
    }
  }
};
// ============================================
// Copy Button
// ============================================
/** Clipboard icon SVG for copy button. */
_MessageRenderer.COPY_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`;
var MessageRenderer = _MessageRenderer;

// src/features/chat/controllers/ConversationController.ts
var ConversationController = class {
  constructor(deps, callbacks = {}) {
    this.deps = deps;
    this.callbacks = callbacks;
  }
  /** Gets the agent service from the tab. */
  getAgentService() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.deps).getAgentService) == null ? void 0 : _b.call(_a)) != null ? _c : null;
  }
  // ============================================
  // Conversation Lifecycle
  // ============================================
  /**
   * Resets to entry point state (New Chat).
   *
   * Entry point is a blank UI state - no conversation is created until the
   * first message is sent. This prevents empty conversations cluttering history.
   */
  async createNew(options = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { plugin, state, asyncSubagentManager } = this.deps;
    const force = options.force === true;
    if (state.isStreaming && !force) return;
    if (state.isCreatingConversation) return;
    if (state.isSwitchingConversation) return;
    state.isCreatingConversation = true;
    try {
      if (force && state.isStreaming) {
        state.cancelRequested = true;
        state.bumpStreamGeneration();
        (_a = this.getAgentService()) == null ? void 0 : _a.cancel();
      }
      if (state.currentConversationId && state.messages.length > 0) {
        await this.save();
      }
      asyncSubagentManager.orphanAllActive();
      state.asyncSubagentStates.clear();
      cleanupThinkingBlock(state.currentThinkingState);
      state.currentContentEl = null;
      state.currentTextEl = null;
      state.currentTextContent = "";
      state.currentThinkingState = null;
      state.toolCallElements.clear();
      state.activeSubagents.clear();
      state.writeEditStates.clear();
      state.isStreaming = false;
      state.currentConversationId = null;
      state.clearMessages();
      state.usage = null;
      state.currentTodos = null;
      state.autoScrollEnabled = true;
      (_b = this.getAgentService()) == null ? void 0 : _b.setSessionId(
        null,
        plugin.settings.persistentExternalContextPaths || []
      );
      const messagesEl = this.deps.getMessagesEl();
      messagesEl.empty();
      const welcomeEl = messagesEl.createDiv({ cls: "claudian-welcome" });
      welcomeEl.createDiv({ cls: "claudian-welcome-greeting", text: this.getGreeting() });
      this.deps.setWelcomeEl(welcomeEl);
      (_c = this.deps.getTodoPanel()) == null ? void 0 : _c.remount();
      this.deps.getInputEl().value = "";
      const fileCtx = this.deps.getFileContextManager();
      fileCtx == null ? void 0 : fileCtx.resetForNewConversation();
      fileCtx == null ? void 0 : fileCtx.autoAttachActiveFile();
      (_d = this.deps.getImageContextManager()) == null ? void 0 : _d.clearImages();
      (_e = this.deps.getMcpServerSelector()) == null ? void 0 : _e.clearEnabled();
      (_f = this.deps.getExternalContextSelector()) == null ? void 0 : _f.clearExternalContexts(
        plugin.settings.persistentExternalContextPaths || []
      );
      this.deps.clearQueuedMessage();
      (_h = (_g = this.callbacks).onNewConversation) == null ? void 0 : _h.call(_g);
    } finally {
      state.isCreatingConversation = false;
    }
  }
  /**
   * Loads the current tab conversation, or starts at entry point if none.
   *
   * Entry point (no conversation) shows welcome screen without
   * creating a conversation. Conversation is created lazily on first message.
   */
  async loadActive() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    const { plugin, state, renderer } = this.deps;
    const conversationId = state.currentConversationId;
    const conversation = conversationId ? await plugin.getConversationById(conversationId) : null;
    if (!conversation) {
      state.currentConversationId = null;
      state.clearMessages();
      state.usage = null;
      state.currentTodos = null;
      state.autoScrollEnabled = true;
      (_a = this.getAgentService()) == null ? void 0 : _a.setSessionId(
        null,
        plugin.settings.persistentExternalContextPaths || []
      );
      const fileCtx2 = this.deps.getFileContextManager();
      fileCtx2 == null ? void 0 : fileCtx2.resetForNewConversation();
      fileCtx2 == null ? void 0 : fileCtx2.autoAttachActiveFile();
      (_b = this.deps.getExternalContextSelector()) == null ? void 0 : _b.clearExternalContexts(
        plugin.settings.persistentExternalContextPaths || []
      );
      (_c = this.deps.getMcpServerSelector()) == null ? void 0 : _c.clearEnabled();
      const welcomeEl2 = renderer.renderMessages(
        [],
        () => this.getGreeting()
      );
      this.deps.setWelcomeEl(welcomeEl2);
      this.updateWelcomeVisibility();
      (_e = (_d = this.callbacks).onConversationLoaded) == null ? void 0 : _e.call(_d);
      return;
    }
    state.currentConversationId = conversation.id;
    state.messages = [...conversation.messages];
    state.usage = (_f = conversation.usage) != null ? _f : null;
    state.autoScrollEnabled = true;
    const hasMessages = state.messages.length > 0;
    const externalContextPaths = hasMessages ? conversation.externalContextPaths || [] : plugin.settings.persistentExternalContextPaths || [];
    (_h = this.getAgentService()) == null ? void 0 : _h.setSessionId((_g = conversation.sessionId) != null ? _g : null, externalContextPaths);
    const fileCtx = this.deps.getFileContextManager();
    fileCtx == null ? void 0 : fileCtx.resetForLoadedConversation(hasMessages);
    if (conversation.currentNote) {
      fileCtx == null ? void 0 : fileCtx.setCurrentNote(conversation.currentNote);
    } else if (!hasMessages) {
      fileCtx == null ? void 0 : fileCtx.autoAttachActiveFile();
    }
    this.restoreExternalContextPaths(
      conversation.externalContextPaths,
      !hasMessages
    );
    const mcpServerSelector = this.deps.getMcpServerSelector();
    if (conversation.enabledMcpServers && conversation.enabledMcpServers.length > 0) {
      mcpServerSelector == null ? void 0 : mcpServerSelector.setEnabledServers(conversation.enabledMcpServers);
    } else {
      mcpServerSelector == null ? void 0 : mcpServerSelector.clearEnabled();
    }
    const welcomeEl = renderer.renderMessages(
      state.messages,
      () => this.getGreeting()
    );
    this.deps.setWelcomeEl(welcomeEl);
    this.updateWelcomeVisibility();
    state.currentTodos = extractLastTodosFromMessages(state.messages);
    (_j = (_i = this.callbacks).onConversationLoaded) == null ? void 0 : _j.call(_i);
  }
  /** Switches to a different conversation. */
  async switchTo(id) {
    var _a, _b, _c, _d, _e, _f;
    const { plugin, state, renderer, asyncSubagentManager } = this.deps;
    if (id === state.currentConversationId) return;
    if (state.isStreaming) return;
    if (state.isSwitchingConversation) return;
    if (state.isCreatingConversation) return;
    state.isSwitchingConversation = true;
    try {
      await this.save();
      asyncSubagentManager.orphanAllActive();
      state.asyncSubagentStates.clear();
      const conversation = await plugin.switchConversation(id);
      if (!conversation) {
        return;
      }
      state.currentConversationId = conversation.id;
      state.messages = [...conversation.messages];
      state.usage = (_a = conversation.usage) != null ? _a : null;
      state.autoScrollEnabled = true;
      const hasMessages = state.messages.length > 0;
      const externalContextPaths = hasMessages ? conversation.externalContextPaths || [] : plugin.settings.persistentExternalContextPaths || [];
      (_c = this.getAgentService()) == null ? void 0 : _c.setSessionId((_b = conversation.sessionId) != null ? _b : null, externalContextPaths);
      this.deps.getInputEl().value = "";
      this.deps.clearQueuedMessage();
      const fileCtx = this.deps.getFileContextManager();
      fileCtx == null ? void 0 : fileCtx.resetForLoadedConversation(hasMessages);
      if (conversation.currentNote) {
        fileCtx == null ? void 0 : fileCtx.setCurrentNote(conversation.currentNote);
      }
      this.restoreExternalContextPaths(
        conversation.externalContextPaths,
        !hasMessages
      );
      const mcpServerSelector = this.deps.getMcpServerSelector();
      if (conversation.enabledMcpServers && conversation.enabledMcpServers.length > 0) {
        mcpServerSelector == null ? void 0 : mcpServerSelector.setEnabledServers(conversation.enabledMcpServers);
      } else {
        mcpServerSelector == null ? void 0 : mcpServerSelector.clearEnabled();
      }
      const welcomeEl = renderer.renderMessages(
        state.messages,
        () => this.getGreeting()
      );
      this.deps.setWelcomeEl(welcomeEl);
      state.currentTodos = extractLastTodosFromMessages(state.messages);
      (_d = this.deps.getHistoryDropdown()) == null ? void 0 : _d.removeClass("visible");
      this.updateWelcomeVisibility();
      (_f = (_e = this.callbacks).onConversationSwitched) == null ? void 0 : _f.call(_e);
    } finally {
      state.isSwitchingConversation = false;
    }
  }
  /**
   * Saves the current conversation.
   *
   * If we're at an entry point (no conversation yet) and have messages,
   * creates a new conversation first (lazy creation).
   *
   * For native sessions (new conversations with sessionId from SDK),
   * only metadata is saved - the SDK handles message persistence.
   */
  async save(updateLastResponse = false) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const { plugin, state } = this.deps;
    if (!state.currentConversationId && state.messages.length === 0) {
      return;
    }
    const agentService = this.getAgentService();
    const sessionId = (_a = agentService == null ? void 0 : agentService.getSessionId()) != null ? _a : null;
    const sessionInvalidated = (_c = (_b = agentService == null ? void 0 : agentService.consumeSessionInvalidation) == null ? void 0 : _b.call(agentService)) != null ? _c : false;
    if (!state.currentConversationId && state.messages.length > 0) {
      const conversation2 = await plugin.createConversation(sessionId != null ? sessionId : void 0);
      state.currentConversationId = conversation2.id;
    }
    const fileCtx = this.deps.getFileContextManager();
    const currentNote = (fileCtx == null ? void 0 : fileCtx.getCurrentNotePath()) || void 0;
    const externalContextSelector = this.deps.getExternalContextSelector();
    const externalContextPaths = (_d = externalContextSelector == null ? void 0 : externalContextSelector.getExternalContexts()) != null ? _d : [];
    const mcpServerSelector = this.deps.getMcpServerSelector();
    const enabledMcpServers = mcpServerSelector ? Array.from(mcpServerSelector.getEnabledServers()) : [];
    const conversation = await plugin.getConversationById(state.currentConversationId);
    const wasNative = (_e = conversation == null ? void 0 : conversation.isNative) != null ? _e : false;
    const shouldPromote = !wasNative && !!sessionId;
    const isNative = wasNative || shouldPromote;
    const legacyMessages = (_f = conversation == null ? void 0 : conversation.messages) != null ? _f : [];
    const legacyCutoffAt = shouldPromote ? (_g = legacyMessages[legacyMessages.length - 1]) == null ? void 0 : _g.timestamp : conversation == null ? void 0 : conversation.legacyCutoffAt;
    const oldSdkSessionId = conversation == null ? void 0 : conversation.sdkSessionId;
    const sessionChanged = isNative && sessionId && oldSdkSessionId && sessionId !== oldSdkSessionId;
    const previousSdkSessionIds = sessionChanged ? [.../* @__PURE__ */ new Set([...(conversation == null ? void 0 : conversation.previousSdkSessionIds) || [], oldSdkSessionId])] : conversation == null ? void 0 : conversation.previousSdkSessionIds;
    const updates = {
      // For native sessions, don't persist messages (SDK handles that)
      // For legacy sessions, persist messages as before
      messages: isNative ? state.messages : state.getPersistedMessages(),
      // Preserve existing sessionId when SDK hasn't captured a new one yet
      sessionId: sessionInvalidated ? null : (_h = sessionId != null ? sessionId : conversation == null ? void 0 : conversation.sessionId) != null ? _h : null,
      sdkSessionId: isNative && sessionId ? sessionId : conversation == null ? void 0 : conversation.sdkSessionId,
      previousSdkSessionIds,
      isNative: isNative || void 0,
      legacyCutoffAt,
      sdkMessagesLoaded: isNative ? true : void 0,
      currentNote,
      externalContextPaths: externalContextPaths.length > 0 ? externalContextPaths : void 0,
      usage: (_i = state.usage) != null ? _i : void 0,
      enabledMcpServers: enabledMcpServers.length > 0 ? enabledMcpServers : void 0
    };
    if (updateLastResponse) {
      updates.lastResponseAt = Date.now();
    }
    await plugin.updateConversation(state.currentConversationId, updates);
  }
  /**
   * Restores external context paths based on session state.
   * New or empty sessions get current persistent paths from settings.
   * Sessions with messages restore exactly what was saved.
   */
  restoreExternalContextPaths(savedPaths, isEmptySession) {
    const { plugin } = this.deps;
    const externalContextSelector = this.deps.getExternalContextSelector();
    if (!externalContextSelector) {
      return;
    }
    if (isEmptySession) {
      externalContextSelector.clearExternalContexts(
        plugin.settings.persistentExternalContextPaths || []
      );
    } else {
      externalContextSelector.setExternalContexts(savedPaths || []);
    }
  }
  // ============================================
  // History Dropdown
  // ============================================
  /** Toggles the history dropdown visibility. */
  toggleHistoryDropdown() {
    const dropdown = this.deps.getHistoryDropdown();
    if (!dropdown) return;
    const isVisible = dropdown.hasClass("visible");
    if (isVisible) {
      dropdown.removeClass("visible");
    } else {
      this.updateHistoryDropdown();
      dropdown.addClass("visible");
    }
  }
  /** Updates the history dropdown content. */
  updateHistoryDropdown() {
    const dropdown = this.deps.getHistoryDropdown();
    if (!dropdown) return;
    this.renderHistoryItems(dropdown, {
      onSelectConversation: (id) => this.switchTo(id),
      onRerender: () => this.updateHistoryDropdown()
    });
  }
  /**
   * Renders history dropdown items to a container.
   * Shared implementation for updateHistoryDropdown() and renderHistoryDropdown().
   */
  renderHistoryItems(container, options) {
    var _a;
    const { plugin, state } = this.deps;
    container.empty();
    const dropdownHeader = container.createDiv({ cls: "claudian-history-header" });
    dropdownHeader.createSpan({ text: "Conversations" });
    const list = container.createDiv({ cls: "claudian-history-list" });
    const allConversations = plugin.getConversationList();
    if (allConversations.length === 0) {
      list.createDiv({ cls: "claudian-history-empty", text: "No conversations" });
      return;
    }
    const conversations = [...allConversations].sort((a, b) => {
      var _a2, _b;
      return ((_a2 = b.lastResponseAt) != null ? _a2 : b.createdAt) - ((_b = a.lastResponseAt) != null ? _b : a.createdAt);
    });
    for (const conv of conversations) {
      const isCurrent = conv.id === state.currentConversationId;
      const item = list.createDiv({
        cls: `claudian-history-item${isCurrent ? " active" : ""}`
      });
      const iconEl = item.createDiv({ cls: "claudian-history-item-icon" });
      (0, import_obsidian9.setIcon)(iconEl, isCurrent ? "message-square-dot" : "message-square");
      const content = item.createDiv({ cls: "claudian-history-item-content" });
      const titleEl = content.createDiv({ cls: "claudian-history-item-title", text: conv.title });
      titleEl.setAttribute("title", conv.title);
      content.createDiv({
        cls: "claudian-history-item-date",
        text: isCurrent ? "Current session" : this.formatDate((_a = conv.lastResponseAt) != null ? _a : conv.createdAt)
      });
      if (!isCurrent) {
        content.addEventListener("click", async (e) => {
          e.stopPropagation();
          try {
            await options.onSelectConversation(conv.id);
          } catch (e2) {
          }
        });
      }
      const actions = item.createDiv({ cls: "claudian-history-item-actions" });
      if (conv.titleGenerationStatus === "pending") {
        const loadingEl = actions.createEl("span", { cls: "claudian-action-btn claudian-action-loading" });
        (0, import_obsidian9.setIcon)(loadingEl, "loader-2");
        loadingEl.setAttribute("aria-label", "Generating title...");
      } else if (conv.titleGenerationStatus === "failed") {
        const regenerateBtn = actions.createEl("button", { cls: "claudian-action-btn" });
        (0, import_obsidian9.setIcon)(regenerateBtn, "refresh-cw");
        regenerateBtn.setAttribute("aria-label", "Regenerate title");
        regenerateBtn.addEventListener("click", async (e) => {
          e.stopPropagation();
          try {
            await this.regenerateTitle(conv.id);
          } catch (e2) {
          }
        });
      }
      const renameBtn = actions.createEl("button", { cls: "claudian-action-btn" });
      (0, import_obsidian9.setIcon)(renameBtn, "pencil");
      renameBtn.setAttribute("aria-label", "Rename");
      renameBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        this.showRenameInput(item, conv.id, conv.title);
      });
      const deleteBtn = actions.createEl("button", { cls: "claudian-action-btn claudian-delete-btn" });
      (0, import_obsidian9.setIcon)(deleteBtn, "trash-2");
      deleteBtn.setAttribute("aria-label", "Delete");
      deleteBtn.addEventListener("click", async (e) => {
        e.stopPropagation();
        if (state.isStreaming) return;
        try {
          await plugin.deleteConversation(conv.id);
          options.onRerender();
          if (conv.id === state.currentConversationId) {
            await this.loadActive();
          }
        } catch (e2) {
        }
      });
    }
  }
  /** Shows inline rename input for a conversation. */
  showRenameInput(item, convId, currentTitle) {
    const titleEl = item.querySelector(".claudian-history-item-title");
    if (!titleEl) return;
    const input = document.createElement("input");
    input.type = "text";
    input.className = "claudian-rename-input";
    input.value = currentTitle;
    titleEl.replaceWith(input);
    input.focus();
    input.select();
    const finishRename = async () => {
      try {
        const newTitle = input.value.trim() || currentTitle;
        await this.deps.plugin.renameConversation(convId, newTitle);
        this.updateHistoryDropdown();
      } catch (e) {
      }
    };
    input.addEventListener("blur", finishRename);
    input.addEventListener("keydown", async (e) => {
      if (e.key === "Enter" && !e.isComposing) {
        input.blur();
      } else if (e.key === "Escape" && !e.isComposing) {
        input.value = currentTitle;
        input.blur();
      }
    });
  }
  // ============================================
  // Welcome & Greeting
  // ============================================
  /** Generates a dynamic greeting based on time/day. */
  getGreeting() {
    var _a;
    const now = /* @__PURE__ */ new Date();
    const hour = now.getHours();
    const day = now.getDay();
    const name = (_a = this.deps.plugin.settings.userName) == null ? void 0 : _a.trim();
    const personalize = (base, noNameFallback) => name ? `${base}, ${name}` : noNameFallback != null ? noNameFallback : base;
    const dayGreetings = {
      0: [personalize("Happy Sunday"), "Sunday session?", "Welcome to the weekend"],
      1: [personalize("Happy Monday"), personalize("Back at it", "Back at it!")],
      2: [personalize("Happy Tuesday")],
      3: [personalize("Happy Wednesday")],
      4: [personalize("Happy Thursday")],
      5: [personalize("Happy Friday"), personalize("That Friday feeling")],
      6: [personalize("Happy Saturday", "Happy Saturday!"), personalize("Welcome to the weekend")]
    };
    const getTimeGreetings = () => {
      if (hour >= 5 && hour < 12) {
        return [personalize("Good morning"), "Coffee and Claudian time?"];
      } else if (hour >= 12 && hour < 18) {
        return [personalize("Good afternoon"), personalize("Hey there"), personalize("How's it going") + "?"];
      } else if (hour >= 18 && hour < 22) {
        return [personalize("Good evening"), personalize("Evening"), personalize("How was your day") + "?"];
      } else {
        return ["Hello, night owl", personalize("Evening")];
      }
    };
    const generalGreetings = [
      personalize("Hey there"),
      name ? `Hi ${name}, how are you?` : "Hi, how are you?",
      personalize("How's it going") + "?",
      personalize("Welcome back") + "!",
      personalize("What's new") + "?",
      ...name ? [`${name} returns!`] : [],
      "You are absolutely right!"
    ];
    const allGreetings = [
      ...dayGreetings[day] || [],
      ...getTimeGreetings(),
      ...generalGreetings
    ];
    return allGreetings[Math.floor(Math.random() * allGreetings.length)];
  }
  /** Updates welcome element visibility based on message count. */
  updateWelcomeVisibility() {
    const welcomeEl = this.deps.getWelcomeEl();
    if (!welcomeEl) return;
    if (this.deps.state.messages.length === 0) {
      welcomeEl.style.display = "";
    } else {
      welcomeEl.style.display = "none";
    }
  }
  /**
   * Initializes the welcome greeting for a new tab without a conversation.
   * Called when a new tab is activated and has no conversation loaded.
   */
  initializeWelcome() {
    const welcomeEl = this.deps.getWelcomeEl();
    if (!welcomeEl) return;
    const fileCtx = this.deps.getFileContextManager();
    fileCtx == null ? void 0 : fileCtx.resetForNewConversation();
    fileCtx == null ? void 0 : fileCtx.autoAttachActiveFile();
    if (!welcomeEl.querySelector(".claudian-welcome-greeting")) {
      welcomeEl.createDiv({ cls: "claudian-welcome-greeting", text: this.getGreeting() });
    }
    this.updateWelcomeVisibility();
  }
  // ============================================
  // Utilities
  // ============================================
  /** Generates a fallback title from the first message (used when AI fails). */
  generateFallbackTitle(firstMessage) {
    const firstSentence = firstMessage.split(/[.!?\n]/)[0].trim();
    const autoTitle = firstSentence.substring(0, 50);
    const suffix = firstSentence.length > 50 ? "..." : "";
    return `${autoTitle}${suffix}`;
  }
  /** Regenerates AI title for a conversation. */
  async regenerateTitle(conversationId) {
    var _a;
    const { plugin } = this.deps;
    if (!plugin.settings.enableAutoTitleGeneration) return;
    const titleService = this.deps.getTitleGenerationService();
    if (!titleService) return;
    const fullConv = await plugin.getConversationById(conversationId);
    if (!fullConv || fullConv.messages.length < 2) return;
    const firstUserMsg = fullConv.messages.find((m) => m.role === "user");
    const firstAssistantMsg = fullConv.messages.find((m) => m.role === "assistant");
    if (!firstUserMsg || !firstAssistantMsg) return;
    const userContent = firstUserMsg.displayContent || firstUserMsg.content;
    const assistantText = firstAssistantMsg.content || ((_a = firstAssistantMsg.contentBlocks) == null ? void 0 : _a.filter((b) => b.type === "text").map((b) => b.content).join("\n")) || "";
    if (!assistantText) return;
    const expectedTitle = fullConv.title;
    await plugin.updateConversation(conversationId, { titleGenerationStatus: "pending" });
    this.updateHistoryDropdown();
    await titleService.generateTitle(
      conversationId,
      userContent,
      assistantText,
      async (convId, result) => {
        const currentConv = await plugin.getConversationById(convId);
        if (!currentConv) return;
        const userManuallyRenamed = currentConv.title !== expectedTitle;
        if (result.success && result.title && !userManuallyRenamed) {
          await plugin.renameConversation(convId, result.title);
          await plugin.updateConversation(convId, { titleGenerationStatus: "success" });
        } else if (!userManuallyRenamed) {
          await plugin.updateConversation(convId, { titleGenerationStatus: "failed" });
        } else {
          await plugin.updateConversation(convId, { titleGenerationStatus: void 0 });
        }
        this.updateHistoryDropdown();
      }
    );
  }
  /** Formats a timestamp for display. */
  formatDate(timestamp) {
    const date3 = new Date(timestamp);
    const now = /* @__PURE__ */ new Date();
    if (date3.toDateString() === now.toDateString()) {
      return date3.toLocaleTimeString(void 0, { hour: "2-digit", minute: "2-digit", hour12: false });
    }
    return date3.toLocaleDateString(void 0, { month: "short", day: "numeric" });
  }
  // ============================================
  // History Dropdown Rendering (for ClaudianView)
  // ============================================
  /**
   * Renders the history dropdown content to a provided container.
   * Used by ClaudianView to render the dropdown with custom selection callback.
   */
  renderHistoryDropdown(container, options) {
    this.renderHistoryItems(container, {
      onSelectConversation: options.onSelectConversation,
      onRerender: () => this.renderHistoryDropdown(container, options)
    });
  }
};

// src/features/chat/controllers/InputController.ts
var import_obsidian12 = require("obsidian");

// src/shared/modals/ApprovalModal.ts
var import_obsidian10 = require("obsidian");
var ApprovalModal = class extends import_obsidian10.Modal {
  constructor(app, toolName, _input, description, resolve3, options = {}) {
    super(app);
    this.resolved = false;
    this.buttons = [];
    this.currentButtonIndex = 0;
    this.documentKeydownHandler = null;
    this.toolName = toolName;
    this.description = description;
    this.resolve = resolve3;
    this.options = options;
  }
  onOpen() {
    var _a, _b, _c;
    const { contentEl } = this;
    contentEl.addClass("claudian-approval-modal");
    this.setTitle((_a = this.options.title) != null ? _a : "Permission required");
    const infoEl = contentEl.createDiv({ cls: "claudian-approval-info" });
    const toolEl = infoEl.createDiv({ cls: "claudian-approval-tool" });
    const iconEl = toolEl.createSpan({ cls: "claudian-approval-icon" });
    iconEl.setAttribute("aria-hidden", "true");
    (0, import_obsidian10.setIcon)(iconEl, getToolIcon(this.toolName));
    toolEl.createSpan({ text: this.toolName, cls: "claudian-approval-tool-name" });
    const descEl = contentEl.createDiv({ cls: "claudian-approval-desc" });
    descEl.setText(this.description);
    const buttonsEl = contentEl.createDiv({ cls: "claudian-approval-buttons" });
    const denyBtn = buttonsEl.createEl("button", {
      text: "Deny",
      cls: "claudian-approval-btn claudian-deny-btn",
      attr: { "aria-label": `Deny ${this.toolName} action` }
    });
    denyBtn.addEventListener("click", () => this.handleDecision("deny"));
    let alwaysDenyBtn = null;
    if ((_b = this.options.showAlwaysDeny) != null ? _b : true) {
      alwaysDenyBtn = buttonsEl.createEl("button", {
        text: "Always deny",
        cls: "claudian-approval-btn claudian-always-deny-btn",
        attr: { "aria-label": `Always deny ${this.toolName} actions` }
      });
      alwaysDenyBtn.addEventListener("click", () => this.handleDecision("deny-always"));
    }
    const allowBtn = buttonsEl.createEl("button", {
      text: "Allow once",
      cls: "claudian-approval-btn claudian-allow-btn",
      attr: { "aria-label": `Allow ${this.toolName} action once` }
    });
    allowBtn.addEventListener("click", () => this.handleDecision("allow"));
    let alwaysAllowBtn = null;
    if ((_c = this.options.showAlwaysAllow) != null ? _c : true) {
      alwaysAllowBtn = buttonsEl.createEl("button", {
        text: "Always allow",
        cls: "claudian-approval-btn claudian-always-btn",
        attr: { "aria-label": `Always allow ${this.toolName} actions` }
      });
      alwaysAllowBtn.addEventListener("click", () => this.handleDecision("allow-always"));
    }
    this.buttons = [denyBtn];
    if (alwaysDenyBtn) {
      this.buttons.push(alwaysDenyBtn);
    }
    this.buttons.push(allowBtn);
    if (alwaysAllowBtn) {
      this.buttons.push(alwaysAllowBtn);
    }
    this.currentButtonIndex = 0;
    this.focusCurrentButton();
    this.attachDocumentHandler();
  }
  handleDecision(decision) {
    if (!this.resolved) {
      this.resolved = true;
      this.resolve(decision);
      this.close();
    }
  }
  attachDocumentHandler() {
    this.detachDocumentHandler();
    this.documentKeydownHandler = (e) => {
      if (!this.isNavigationKey(e)) {
        return;
      }
      e.preventDefault();
      e.stopPropagation();
      this.handleNavigationKey(e);
    };
    document.addEventListener("keydown", this.documentKeydownHandler, true);
  }
  detachDocumentHandler() {
    if (this.documentKeydownHandler) {
      document.removeEventListener("keydown", this.documentKeydownHandler, true);
      this.documentKeydownHandler = null;
    }
  }
  isNavigationKey(e) {
    return e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "ArrowLeft" || e.key === "ArrowRight" || e.key === "Tab";
  }
  handleNavigationKey(e) {
    if (!this.buttons.length) return;
    let direction = 0;
    switch (e.key) {
      case "ArrowUp":
      case "ArrowLeft":
        direction = -1;
        break;
      case "ArrowDown":
      case "ArrowRight":
        direction = 1;
        break;
      case "Tab":
        direction = e.shiftKey ? -1 : 1;
        break;
      default:
        return;
    }
    const total = this.buttons.length;
    this.currentButtonIndex = (this.currentButtonIndex + direction + total) % total;
    this.focusCurrentButton();
  }
  focusCurrentButton() {
    const button = this.buttons[this.currentButtonIndex];
    button == null ? void 0 : button.focus();
  }
  onClose() {
    this.detachDocumentHandler();
    if (!this.resolved) {
      this.resolved = true;
      this.resolve("cancel");
    }
    this.contentEl.empty();
  }
};

// src/shared/modals/InstructionConfirmModal.ts
var import_obsidian11 = require("obsidian");
var InstructionModal = class extends import_obsidian11.Modal {
  constructor(app, rawInstruction, callbacks) {
    super(app);
    this.state = "loading";
    this.resolved = false;
    // UI elements
    this.contentSectionEl = null;
    this.loadingEl = null;
    this.clarificationEl = null;
    this.confirmationEl = null;
    this.buttonsEl = null;
    // Clarification state
    this.clarificationTextEl = null;
    this.responseTextarea = null;
    this.isSubmitting = false;
    // Confirmation state
    this.refinedInstruction = "";
    this.editTextarea = null;
    this.isEditing = false;
    this.refinedDisplayEl = null;
    this.editContainerEl = null;
    this.editBtnEl = null;
    this.rawInstruction = rawInstruction;
    this.callbacks = callbacks;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("claudian-instruction-modal");
    this.setTitle("Add Custom Instruction");
    const inputSection = contentEl.createDiv({ cls: "claudian-instruction-section" });
    const inputLabel = inputSection.createDiv({ cls: "claudian-instruction-label" });
    inputLabel.setText("Your input:");
    const inputText = inputSection.createDiv({ cls: "claudian-instruction-original" });
    inputText.setText(this.rawInstruction);
    this.contentSectionEl = contentEl.createDiv({ cls: "claudian-instruction-content-section" });
    this.loadingEl = this.contentSectionEl.createDiv({ cls: "claudian-instruction-loading" });
    this.loadingEl.createDiv({ cls: "claudian-instruction-spinner" });
    this.loadingEl.createSpan({ text: "Processing your instruction..." });
    this.clarificationEl = this.contentSectionEl.createDiv({ cls: "claudian-instruction-clarification-section" });
    this.clarificationEl.style.display = "none";
    this.clarificationTextEl = this.clarificationEl.createDiv({ cls: "claudian-instruction-clarification" });
    const responseSection = this.clarificationEl.createDiv({ cls: "claudian-instruction-section" });
    const responseLabel = responseSection.createDiv({ cls: "claudian-instruction-label" });
    responseLabel.setText("Your response:");
    this.responseTextarea = new import_obsidian11.TextAreaComponent(responseSection);
    this.responseTextarea.inputEl.addClass("claudian-instruction-response-textarea");
    this.responseTextarea.inputEl.rows = 3;
    this.responseTextarea.inputEl.placeholder = "Provide more details...";
    this.responseTextarea.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey && !e.isComposing && !this.isSubmitting) {
        e.preventDefault();
        this.submitClarification();
      }
    });
    this.confirmationEl = this.contentSectionEl.createDiv({ cls: "claudian-instruction-confirmation-section" });
    this.confirmationEl.style.display = "none";
    const refinedSection = this.confirmationEl.createDiv({ cls: "claudian-instruction-section" });
    const refinedLabel = refinedSection.createDiv({ cls: "claudian-instruction-label" });
    refinedLabel.setText("Refined snippet:");
    this.refinedDisplayEl = refinedSection.createDiv({ cls: "claudian-instruction-refined" });
    this.editContainerEl = refinedSection.createDiv({ cls: "claudian-instruction-edit-container" });
    this.editContainerEl.style.display = "none";
    this.editTextarea = new import_obsidian11.TextAreaComponent(this.editContainerEl);
    this.editTextarea.inputEl.addClass("claudian-instruction-edit-textarea");
    this.editTextarea.inputEl.rows = 4;
    this.buttonsEl = contentEl.createDiv({ cls: "claudian-instruction-buttons" });
    this.updateButtons();
    this.showState("loading");
  }
  /** Shows clarification question from agent. */
  showClarification(clarification) {
    var _a;
    if (this.clarificationTextEl) {
      this.clarificationTextEl.setText(clarification);
    }
    if (this.responseTextarea) {
      this.responseTextarea.setValue("");
    }
    this.isSubmitting = false;
    this.showState("clarification");
    (_a = this.responseTextarea) == null ? void 0 : _a.inputEl.focus();
  }
  /** Shows confirmation with refined instruction. */
  showConfirmation(refinedInstruction) {
    this.refinedInstruction = refinedInstruction;
    if (this.refinedDisplayEl) {
      this.refinedDisplayEl.setText(refinedInstruction);
    }
    if (this.editTextarea) {
      this.editTextarea.setValue(refinedInstruction);
    }
    this.showState("confirmation");
  }
  /** Shows error and closes modal. */
  showError(error2) {
    this.resolved = true;
    this.close();
  }
  /** Updates the modal to show loading state during clarification submit. */
  showClarificationLoading() {
    this.isSubmitting = true;
    if (this.loadingEl) {
      this.loadingEl.querySelector(".claudian-instruction-spinner");
      const text = this.loadingEl.querySelector("span");
      if (text) text.textContent = "Processing...";
    }
    this.showState("loading");
  }
  showState(state) {
    this.state = state;
    if (this.loadingEl) {
      this.loadingEl.style.display = state === "loading" ? "flex" : "none";
    }
    if (this.clarificationEl) {
      this.clarificationEl.style.display = state === "clarification" ? "block" : "none";
    }
    if (this.confirmationEl) {
      this.confirmationEl.style.display = state === "confirmation" ? "block" : "none";
    }
    this.updateButtons();
  }
  updateButtons() {
    if (!this.buttonsEl) return;
    this.buttonsEl.empty();
    const cancelBtn = this.buttonsEl.createEl("button", {
      text: "Cancel",
      cls: "claudian-instruction-btn claudian-instruction-reject-btn",
      attr: { "aria-label": "Cancel" }
    });
    cancelBtn.addEventListener("click", () => this.handleReject());
    if (this.state === "clarification") {
      const submitBtn = this.buttonsEl.createEl("button", {
        text: "Submit",
        cls: "claudian-instruction-btn claudian-instruction-accept-btn",
        attr: { "aria-label": "Submit response" }
      });
      submitBtn.addEventListener("click", () => this.submitClarification());
    } else if (this.state === "confirmation") {
      this.editBtnEl = this.buttonsEl.createEl("button", {
        text: "Edit",
        cls: "claudian-instruction-btn claudian-instruction-edit-btn",
        attr: { "aria-label": "Edit instruction" }
      });
      this.editBtnEl.addEventListener("click", () => this.toggleEdit());
      const acceptBtn = this.buttonsEl.createEl("button", {
        text: "Accept",
        cls: "claudian-instruction-btn claudian-instruction-accept-btn",
        attr: { "aria-label": "Accept instruction" }
      });
      acceptBtn.addEventListener("click", () => this.handleAccept());
      acceptBtn.focus();
    }
  }
  async submitClarification() {
    var _a;
    const response = (_a = this.responseTextarea) == null ? void 0 : _a.getValue().trim();
    if (!response || this.isSubmitting) return;
    this.showClarificationLoading();
    try {
      await this.callbacks.onClarificationSubmit(response);
    } catch (e) {
      this.isSubmitting = false;
      this.showState("clarification");
    }
  }
  toggleEdit() {
    var _a, _b;
    this.isEditing = !this.isEditing;
    if (this.isEditing) {
      if (this.refinedDisplayEl) this.refinedDisplayEl.style.display = "none";
      if (this.editContainerEl) this.editContainerEl.style.display = "block";
      if (this.editBtnEl) this.editBtnEl.setText("Preview");
      (_a = this.editTextarea) == null ? void 0 : _a.inputEl.focus();
    } else {
      const edited = ((_b = this.editTextarea) == null ? void 0 : _b.getValue()) || this.refinedInstruction;
      this.refinedInstruction = edited;
      if (this.refinedDisplayEl) {
        this.refinedDisplayEl.setText(edited);
        this.refinedDisplayEl.style.display = "block";
      }
      if (this.editContainerEl) this.editContainerEl.style.display = "none";
      if (this.editBtnEl) this.editBtnEl.setText("Edit");
    }
  }
  handleAccept() {
    var _a;
    if (this.resolved) return;
    this.resolved = true;
    const finalInstruction = this.isEditing ? ((_a = this.editTextarea) == null ? void 0 : _a.getValue()) || this.refinedInstruction : this.refinedInstruction;
    this.callbacks.onAccept(finalInstruction);
    this.close();
  }
  handleReject() {
    if (this.resolved) return;
    this.resolved = true;
    this.callbacks.onReject();
    this.close();
  }
  onClose() {
    if (!this.resolved) {
      this.resolved = true;
      this.callbacks.onReject();
    }
    this.contentEl.empty();
  }
};

// src/utils/editor.ts
function getEditorView(editor) {
  return editor.cm;
}
function findNearestNonEmptyLine(getLine, lineCount, startLine, direction) {
  const step = direction === "before" ? -1 : 1;
  for (let i = startLine + step; i >= 0 && i < lineCount; i += step) {
    const content = getLine(i);
    if (content.trim().length > 0) {
      return content;
    }
  }
  return "";
}
function buildCursorContext(getLine, lineCount, line, column) {
  const lineContent = getLine(line);
  const beforeCursor = lineContent.substring(0, column);
  const afterCursor = lineContent.substring(column);
  const lineIsEmpty = lineContent.trim().length === 0;
  const nothingBefore = beforeCursor.trim().length === 0;
  const nothingAfter = afterCursor.trim().length === 0;
  const isInbetween = lineIsEmpty || nothingBefore && nothingAfter;
  let contextBefore = beforeCursor;
  let contextAfter = afterCursor;
  if (isInbetween) {
    contextBefore = findNearestNonEmptyLine(getLine, lineCount, line, "before");
    contextAfter = findNearestNonEmptyLine(getLine, lineCount, line, "after");
  }
  return { beforeCursor: contextBefore, afterCursor: contextAfter, isInbetween, line, column };
}
function formatEditorContext(context) {
  if (context.mode === "selection" && context.selectedText) {
    const lineAttr = context.startLine && context.lineCount ? ` lines="${context.startLine}-${context.startLine + context.lineCount - 1}"` : "";
    return `<editor_selection path="${context.notePath}"${lineAttr}>
${context.selectedText}
</editor_selection>`;
  } else if (context.mode === "cursor" && context.cursorContext) {
    const ctx = context.cursorContext;
    let content;
    if (ctx.isInbetween) {
      const parts = [];
      if (ctx.beforeCursor) parts.push(ctx.beforeCursor);
      parts.push("| #inbetween");
      if (ctx.afterCursor) parts.push(ctx.afterCursor);
      content = parts.join("\n");
    } else {
      content = `${ctx.beforeCursor}|${ctx.afterCursor} #inline`;
    }
    return `<editor_cursor path="${context.notePath}">
${content}
</editor_cursor>`;
  }
  return "";
}
function prependEditorContext(prompt, context) {
  const formatted = formatEditorContext(context);
  return formatted ? `${formatted}

${prompt}` : prompt;
}

// src/utils/markdown.ts
function appendMarkdownSnippet(existingPrompt, snippet) {
  const trimmedSnippet = snippet.trim();
  if (!trimmedSnippet) {
    return existingPrompt;
  }
  if (!existingPrompt.trim()) {
    return trimmedSnippet;
  }
  const separator = existingPrompt.endsWith("\n\n") ? "" : existingPrompt.endsWith("\n") ? "\n" : "\n\n";
  return existingPrompt + separator + trimmedSnippet;
}

// src/features/chat/controllers/InputController.ts
var InputController = class {
  constructor(deps) {
    this.deps = deps;
  }
  /** Gets the agent service from the tab. */
  getAgentService() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.deps).getAgentService) == null ? void 0 : _b.call(_a)) != null ? _c : null;
  }
  // ============================================
  // Message Sending
  // ============================================
  /** Sends a message with optional editor context override. */
  async sendMessage(options) {
    var _a, _b, _c;
    const { plugin, state, renderer, streamController, selectionController, conversationController } = this.deps;
    if (state.isCreatingConversation || state.isSwitchingConversation) return;
    const inputEl = this.deps.getInputEl();
    const imageContextManager = this.deps.getImageContextManager();
    const fileContextManager = this.deps.getFileContextManager();
    const slashCommandManager = this.deps.getSlashCommandManager();
    const mcpServerSelector = this.deps.getMcpServerSelector();
    const externalContextSelector = this.deps.getExternalContextSelector();
    const contentOverride = options == null ? void 0 : options.content;
    const shouldUseInput = contentOverride === void 0;
    let content = (contentOverride != null ? contentOverride : inputEl.value).trim();
    const hasImages = (_a = imageContextManager == null ? void 0 : imageContextManager.hasImages()) != null ? _a : false;
    if (!content && !hasImages) return;
    if (state.currentTodos && state.currentTodos.every((t2) => t2.status === "completed")) {
      state.currentTodos = null;
    }
    const builtInCmd = detectBuiltInCommand(content);
    if (builtInCmd) {
      if (shouldUseInput) {
        inputEl.value = "";
        this.deps.resetInputHeight();
      }
      await this.executeBuiltInCommand(builtInCmd.action);
      return;
    }
    if (state.isStreaming) {
      const images2 = hasImages ? [...(imageContextManager == null ? void 0 : imageContextManager.getAttachedImages()) || []] : void 0;
      const editorContext2 = selectionController.getContext();
      const promptPrefix = options == null ? void 0 : options.promptPrefix;
      if (state.queuedMessage) {
        state.queuedMessage.content += "\n\n" + content;
        if (images2 && images2.length > 0) {
          state.queuedMessage.images = [...state.queuedMessage.images || [], ...images2];
        }
        state.queuedMessage.editorContext = editorContext2;
        if (promptPrefix) {
          state.queuedMessage.promptPrefix = (_b = state.queuedMessage.promptPrefix) != null ? _b : promptPrefix;
        }
      } else {
        state.queuedMessage = {
          content,
          images: images2,
          editorContext: editorContext2,
          promptPrefix
        };
      }
      if (shouldUseInput) {
        inputEl.value = "";
        this.deps.resetInputHeight();
      }
      imageContextManager == null ? void 0 : imageContextManager.clearImages();
      this.updateQueueIndicator();
      return;
    }
    if (shouldUseInput) {
      inputEl.value = "";
      this.deps.resetInputHeight();
    }
    state.isStreaming = true;
    state.cancelRequested = false;
    state.ignoreUsageUpdates = false;
    state.subagentsSpawnedThisStream = 0;
    state.autoScrollEnabled = true;
    const streamGeneration = state.bumpStreamGeneration();
    const welcomeEl = this.deps.getWelcomeEl();
    if (welcomeEl) {
      welcomeEl.style.display = "none";
    }
    fileContextManager == null ? void 0 : fileContextManager.startSession();
    const displayContent = content;
    let queryOptions;
    if (content && slashCommandManager) {
      slashCommandManager.setCommands(plugin.settings.slashCommands);
      const detected = slashCommandManager.detectCommand(content);
      if (detected) {
        const cmd = plugin.settings.slashCommands.find(
          (c) => c.name.toLowerCase() === detected.commandName.toLowerCase()
        );
        if (cmd) {
          const result = await slashCommandManager.expandCommand(cmd, detected.args, {
            bash: {
              enabled: true,
              shouldBlockCommand: (bashCommand) => isCommandBlocked(
                bashCommand,
                getBashToolBlockedCommands(plugin.settings.blockedCommands),
                plugin.settings.enableBlocklist
              ),
              requestApproval: plugin.settings.permissionMode !== "yolo" ? (bashCommand) => this.requestInlineBashApproval(bashCommand) : void 0
            }
          });
          content = result.expandedPrompt;
          if (result.errors.length > 0) {
            new import_obsidian12.Notice(formatSlashCommandWarnings(result.errors));
          }
          if (result.allowedTools || result.model) {
            queryOptions = {
              allowedTools: result.allowedTools,
              model: result.model
            };
          }
        }
      }
    }
    const images = (imageContextManager == null ? void 0 : imageContextManager.getAttachedImages()) || [];
    const imagesForMessage = images.length > 0 ? [...images] : void 0;
    if (shouldUseInput) {
      imageContextManager == null ? void 0 : imageContextManager.clearImages();
    }
    const currentNotePath = (fileContextManager == null ? void 0 : fileContextManager.getCurrentNotePath()) || null;
    const shouldSendCurrentNote = (_c = fileContextManager == null ? void 0 : fileContextManager.shouldSendCurrentNote(currentNotePath)) != null ? _c : false;
    const editorContextOverride = options == null ? void 0 : options.editorContextOverride;
    const editorContext = editorContextOverride !== void 0 ? editorContextOverride : selectionController.getContext();
    const externalContextPaths = externalContextSelector == null ? void 0 : externalContextSelector.getExternalContexts();
    const hasExternalContexts = externalContextPaths && externalContextPaths.length > 0;
    const hasXmlContext = !!editorContext || shouldSendCurrentNote && !!currentNotePath || hasExternalContexts;
    let promptToSend = hasXmlContext ? `<query>
${content}
</query>` : content;
    let currentNoteForMessage;
    if (editorContext) {
      promptToSend = prependEditorContext(promptToSend, editorContext);
    }
    if (shouldSendCurrentNote && currentNotePath) {
      promptToSend = prependCurrentNote(promptToSend, currentNotePath);
      currentNoteForMessage = currentNotePath;
    }
    if (options == null ? void 0 : options.promptPrefix) {
      promptToSend = `${options.promptPrefix}

${promptToSend}`;
    }
    if (fileContextManager) {
      promptToSend = fileContextManager.transformContextMentions(promptToSend);
    }
    fileContextManager == null ? void 0 : fileContextManager.markCurrentNoteSent();
    const userMsg = {
      id: this.deps.generateId(),
      role: "user",
      content: promptToSend,
      // Full prompt with XML context (for history rebuild)
      displayContent,
      // Original user input (for UI display)
      timestamp: Date.now(),
      currentNote: currentNoteForMessage,
      images: imagesForMessage
    };
    state.addMessage(userMsg);
    renderer.addMessage(userMsg);
    const assistantMsg = {
      id: this.deps.generateId(),
      role: "assistant",
      content: "",
      timestamp: Date.now(),
      toolCalls: [],
      contentBlocks: []
    };
    state.addMessage(assistantMsg);
    const msgEl = renderer.addMessage(assistantMsg);
    const contentEl = msgEl.querySelector(".claudian-message-content");
    state.toolCallElements.clear();
    state.currentContentEl = contentEl;
    state.currentTextEl = null;
    state.currentTextContent = "";
    streamController.showThinkingIndicator();
    const mcpMentions = plugin.mcpService.extractMentions(promptToSend);
    promptToSend = plugin.mcpService.transformMentions(promptToSend);
    const enabledMcpServers = mcpServerSelector == null ? void 0 : mcpServerSelector.getEnabledServers();
    if (mcpMentions.size > 0 || enabledMcpServers && enabledMcpServers.size > 0) {
      queryOptions = {
        ...queryOptions,
        mcpMentions,
        enabledMcpServers
      };
    }
    if (externalContextPaths && externalContextPaths.length > 0) {
      queryOptions = {
        ...queryOptions,
        externalContextPaths
      };
    }
    let wasInterrupted = false;
    let wasInvalidated = false;
    if (this.deps.ensureServiceInitialized) {
      const ready = await this.deps.ensureServiceInitialized();
      if (!ready) {
        new import_obsidian12.Notice("Failed to initialize agent service. Please try again.");
        streamController.hideThinkingIndicator();
        state.isStreaming = false;
        return;
      }
    }
    const agentService = this.getAgentService();
    if (!agentService) {
      new import_obsidian12.Notice("Agent service not available. Please reload the plugin.");
      return;
    }
    try {
      const previousMessages = state.messages.slice(0, -2);
      for await (const chunk of agentService.query(promptToSend, imagesForMessage, previousMessages, queryOptions)) {
        if (state.streamGeneration !== streamGeneration) {
          wasInvalidated = true;
          break;
        }
        if (state.cancelRequested) {
          wasInterrupted = true;
          break;
        }
        await streamController.handleStreamChunk(chunk, assistantMsg);
      }
    } catch (error2) {
      const errorMsg = error2 instanceof Error ? error2.message : "Unknown error";
      await streamController.appendText(`

**Error:** ${errorMsg}`);
    } finally {
      if (!wasInvalidated && state.streamGeneration === streamGeneration) {
        if (wasInterrupted) {
          await streamController.appendText('\n\n<span class="claudian-interrupted">Interrupted</span> <span class="claudian-interrupted-hint">\xB7 What should Claudian do instead?</span>');
        }
        streamController.hideThinkingIndicator();
        state.isStreaming = false;
        state.cancelRequested = false;
        state.currentContentEl = null;
        streamController.finalizeCurrentThinkingBlock(assistantMsg);
        streamController.finalizeCurrentTextBlock(assistantMsg);
        state.activeSubagents.clear();
        await conversationController.save(true);
        await this.triggerTitleGeneration();
        this.processQueuedMessage();
      }
    }
  }
  // ============================================
  // Queue Management
  // ============================================
  /** Updates the queue indicator UI. */
  updateQueueIndicator() {
    var _a, _b;
    const { state } = this.deps;
    if (!state.queueIndicatorEl) return;
    if (state.queuedMessage) {
      const rawContent = state.queuedMessage.content.trim();
      const preview = rawContent.length > 40 ? rawContent.slice(0, 40) + "..." : rawContent;
      const hasImages = ((_b = (_a = state.queuedMessage.images) == null ? void 0 : _a.length) != null ? _b : 0) > 0;
      let display = preview;
      if (hasImages) {
        display = display ? `${display} [images]` : "[images]";
      }
      state.queueIndicatorEl.setText(`\u2319 Queued: ${display}`);
      state.queueIndicatorEl.style.display = "block";
    } else {
      state.queueIndicatorEl.style.display = "none";
    }
  }
  /** Clears the queued message. */
  clearQueuedMessage() {
    const { state } = this.deps;
    state.queuedMessage = null;
    this.updateQueueIndicator();
  }
  /** Restores the queued message to the input field without sending. */
  restoreQueuedMessageToInput() {
    var _a;
    const { state } = this.deps;
    if (!state.queuedMessage) return;
    const { content, images } = state.queuedMessage;
    state.queuedMessage = null;
    this.updateQueueIndicator();
    const inputEl = this.deps.getInputEl();
    inputEl.value = content;
    if (images && images.length > 0) {
      (_a = this.deps.getImageContextManager()) == null ? void 0 : _a.setImages(images);
    }
  }
  /** Processes the queued message. */
  processQueuedMessage() {
    var _a;
    const { state } = this.deps;
    if (!state.queuedMessage) return;
    const { content, images, editorContext, promptPrefix } = state.queuedMessage;
    state.queuedMessage = null;
    this.updateQueueIndicator();
    const inputEl = this.deps.getInputEl();
    inputEl.value = content;
    if (images && images.length > 0) {
      (_a = this.deps.getImageContextManager()) == null ? void 0 : _a.setImages(images);
    }
    setTimeout(() => this.sendMessage({ editorContextOverride: editorContext, promptPrefix }), 0);
  }
  // ============================================
  // Title Generation
  // ============================================
  /**
   * Triggers AI title generation after first exchange.
   * Handles setting fallback title, firing async generation, and updating UI.
   */
  async triggerTitleGeneration() {
    var _a;
    const { plugin, state, conversationController } = this.deps;
    if (state.messages.length !== 2 || !state.currentConversationId) {
      return;
    }
    const firstUserMsg = state.messages.find((m) => m.role === "user");
    const firstAssistantMsg = state.messages.find((m) => m.role === "assistant");
    if (!firstUserMsg || !firstAssistantMsg) {
      return;
    }
    const userContent = firstUserMsg.displayContent || firstUserMsg.content;
    const assistantText = firstAssistantMsg.content || ((_a = firstAssistantMsg.contentBlocks) == null ? void 0 : _a.filter((b) => b.type === "text").map((b) => b.content).join("\n")) || "";
    const fallbackTitle = conversationController.generateFallbackTitle(userContent);
    await plugin.renameConversation(state.currentConversationId, fallbackTitle);
    if (!plugin.settings.enableAutoTitleGeneration) {
      return;
    }
    const titleService = this.deps.getTitleGenerationService();
    if (!titleService || !assistantText) {
      return;
    }
    await plugin.updateConversation(state.currentConversationId, { titleGenerationStatus: "pending" });
    conversationController.updateHistoryDropdown();
    const convId = state.currentConversationId;
    const expectedTitle = fallbackTitle;
    titleService.generateTitle(
      convId,
      userContent,
      assistantText,
      async (conversationId, result) => {
        const currentConv = await plugin.getConversationById(conversationId);
        if (!currentConv) return;
        const userManuallyRenamed = currentConv.title !== expectedTitle;
        if (result.success && !userManuallyRenamed) {
          await plugin.renameConversation(conversationId, result.title);
          await plugin.updateConversation(conversationId, { titleGenerationStatus: "success" });
        } else if (!userManuallyRenamed) {
          await plugin.updateConversation(conversationId, { titleGenerationStatus: "failed" });
        } else {
          await plugin.updateConversation(conversationId, { titleGenerationStatus: void 0 });
        }
        conversationController.updateHistoryDropdown();
      }
    ).catch(() => {
    });
  }
  // ============================================
  // Streaming Control
  // ============================================
  /** Cancels the current streaming operation. */
  cancelStreaming() {
    var _a;
    const { state, streamController } = this.deps;
    if (!state.isStreaming) return;
    state.cancelRequested = true;
    this.restoreQueuedMessageToInput();
    (_a = this.getAgentService()) == null ? void 0 : _a.cancel();
    streamController.hideThinkingIndicator();
  }
  // ============================================
  // Instruction Mode
  // ============================================
  /** Handles instruction mode submission. */
  async handleInstructionSubmit(rawInstruction) {
    const { plugin } = this.deps;
    const instructionRefineService = this.deps.getInstructionRefineService();
    const instructionModeManager = this.deps.getInstructionModeManager();
    if (!instructionRefineService) return;
    const existingPrompt = plugin.settings.systemPrompt;
    let modal = null;
    let wasCancelled = false;
    try {
      modal = new InstructionModal(
        plugin.app,
        rawInstruction,
        {
          onAccept: async (finalInstruction) => {
            const currentPrompt = plugin.settings.systemPrompt;
            plugin.settings.systemPrompt = appendMarkdownSnippet(currentPrompt, finalInstruction);
            await plugin.saveSettings();
            new import_obsidian12.Notice("Instruction added to custom system prompt");
            instructionModeManager == null ? void 0 : instructionModeManager.clear();
          },
          onReject: () => {
            wasCancelled = true;
            instructionRefineService.cancel();
            instructionModeManager == null ? void 0 : instructionModeManager.clear();
          },
          onClarificationSubmit: async (response) => {
            const result2 = await instructionRefineService.continueConversation(response);
            if (wasCancelled) {
              return;
            }
            if (!result2.success) {
              if (result2.error === "Cancelled") {
                return;
              }
              new import_obsidian12.Notice(result2.error || "Failed to process response");
              modal == null ? void 0 : modal.showError(result2.error || "Failed to process response");
              return;
            }
            if (result2.clarification) {
              modal == null ? void 0 : modal.showClarification(result2.clarification);
            } else if (result2.refinedInstruction) {
              modal == null ? void 0 : modal.showConfirmation(result2.refinedInstruction);
            }
          }
        }
      );
      modal.open();
      instructionRefineService.resetConversation();
      const result = await instructionRefineService.refineInstruction(
        rawInstruction,
        existingPrompt
      );
      if (wasCancelled) {
        return;
      }
      if (!result.success) {
        if (result.error === "Cancelled") {
          instructionModeManager == null ? void 0 : instructionModeManager.clear();
          return;
        }
        new import_obsidian12.Notice(result.error || "Failed to refine instruction");
        modal.showError(result.error || "Failed to refine instruction");
        instructionModeManager == null ? void 0 : instructionModeManager.clear();
        return;
      }
      if (result.clarification) {
        modal.showClarification(result.clarification);
      } else if (result.refinedInstruction) {
        modal.showConfirmation(result.refinedInstruction);
      } else {
        new import_obsidian12.Notice("No instruction received");
        modal.showError("No instruction received");
        instructionModeManager == null ? void 0 : instructionModeManager.clear();
      }
    } catch (error2) {
      const errorMsg = error2 instanceof Error ? error2.message : "Unknown error";
      new import_obsidian12.Notice(`Error: ${errorMsg}`);
      modal == null ? void 0 : modal.showError(errorMsg);
      instructionModeManager == null ? void 0 : instructionModeManager.clear();
    }
  }
  // ============================================
  // Approval Dialogs
  // ============================================
  /** Handles tool approval requests. */
  async handleApprovalRequest(toolName, input, description) {
    const { plugin } = this.deps;
    return new Promise((resolve3) => {
      const modal = new ApprovalModal(plugin.app, toolName, input, description, resolve3);
      modal.open();
    });
  }
  /** Requests approval for inline bash commands. */
  async requestInlineBashApproval(command) {
    const { plugin } = this.deps;
    const description = `Execute inline bash command:
${command}`;
    return new Promise((resolve3) => {
      const modal = new ApprovalModal(
        plugin.app,
        TOOL_BASH,
        { command },
        description,
        (decision) => resolve3(decision === "allow" || decision === "allow-always"),
        { showAlwaysAllow: false, showAlwaysDeny: false, title: "Inline bash execution" }
      );
      modal.open();
    });
  }
  // ============================================
  // Built-in Commands
  // ============================================
  /** Executes a built-in command action. */
  async executeBuiltInCommand(action) {
    const { conversationController } = this.deps;
    switch (action) {
      case "clear":
        await conversationController.createNew();
        break;
      default:
    }
  }
};

// src/features/chat/controllers/NavigationController.ts
var SCROLL_SPEED = 8;
var NavigationController = class {
  constructor(deps) {
    this.scrollDirection = null;
    this.animationFrameId = null;
    this.initialized = false;
    this.disposed = false;
    this.scrollLoop = () => {
      if (this.scrollDirection === null || this.disposed) return;
      const messagesEl = this.deps.getMessagesEl();
      if (!messagesEl) {
        this.stopScrolling();
        return;
      }
      const scrollAmount = this.scrollDirection === "up" ? -SCROLL_SPEED : SCROLL_SPEED;
      messagesEl.scrollTop += scrollAmount;
      this.animationFrameId = requestAnimationFrame(this.scrollLoop);
    };
    this.deps = deps;
    this.boundMessagesKeydown = this.handleMessagesKeydown.bind(this);
    this.boundKeyup = this.handleKeyup.bind(this);
    this.boundInputKeydown = this.handleInputKeydown.bind(this);
  }
  // ============================================
  // Lifecycle
  // ============================================
  /** Initializes navigation by making messagesEl focusable and attaching listeners. */
  initialize() {
    if (this.initialized || this.disposed) return;
    const messagesEl = this.deps.getMessagesEl();
    const inputEl = this.deps.getInputEl();
    if (!messagesEl || !inputEl) return;
    messagesEl.setAttribute("tabindex", "0");
    messagesEl.addClass("claudian-messages-focusable");
    messagesEl.addEventListener("keydown", this.boundMessagesKeydown);
    document.addEventListener("keyup", this.boundKeyup);
    inputEl.addEventListener("keydown", this.boundInputKeydown, { capture: true });
    this.initialized = true;
  }
  /** Cleans up event listeners and animation frames. */
  dispose() {
    if (this.disposed) return;
    this.disposed = true;
    this.stopScrolling();
    document.removeEventListener("keyup", this.boundKeyup);
    const messagesEl = this.deps.getMessagesEl();
    messagesEl == null ? void 0 : messagesEl.removeEventListener("keydown", this.boundMessagesKeydown);
    messagesEl == null ? void 0 : messagesEl.removeClass("claudian-messages-focusable");
    const inputEl = this.deps.getInputEl();
    inputEl == null ? void 0 : inputEl.removeEventListener("keydown", this.boundInputKeydown, { capture: true });
  }
  // ============================================
  // Messages Panel Keyboard Handling
  // ============================================
  handleMessagesKeydown(e) {
    if (e.ctrlKey || e.metaKey || e.altKey || e.shiftKey) return;
    const settings11 = this.deps.getSettings();
    const key = e.key.toLowerCase();
    if (key === settings11.scrollUpKey.toLowerCase()) {
      e.preventDefault();
      this.startScrolling("up");
      return;
    }
    if (key === settings11.scrollDownKey.toLowerCase()) {
      e.preventDefault();
      this.startScrolling("down");
      return;
    }
    if (key === settings11.focusInputKey.toLowerCase()) {
      e.preventDefault();
      this.deps.getInputEl().focus();
      return;
    }
  }
  handleKeyup(e) {
    const settings11 = this.deps.getSettings();
    const key = e.key.toLowerCase();
    if (key === settings11.scrollUpKey.toLowerCase() || key === settings11.scrollDownKey.toLowerCase()) {
      this.stopScrolling();
    }
  }
  // ============================================
  // Input Keyboard Handling (Escape)
  // ============================================
  handleInputKeydown(e) {
    var _a, _b;
    if (e.key !== "Escape") return;
    if (e.isComposing) return;
    if (this.deps.isStreaming()) {
      return;
    }
    try {
      if ((_b = (_a = this.deps).shouldSkipEscapeHandling) == null ? void 0 : _b.call(_a)) {
        return;
      }
    } catch (e2) {
    }
    e.preventDefault();
    e.stopPropagation();
    this.deps.getInputEl().blur();
    this.deps.getMessagesEl().focus();
  }
  // ============================================
  // Continuous Scrolling with requestAnimationFrame
  // ============================================
  startScrolling(direction) {
    if (this.scrollDirection === direction) {
      return;
    }
    this.scrollDirection = direction;
    this.scrollLoop();
  }
  stopScrolling() {
    this.scrollDirection = null;
    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = null;
    }
  }
  // ============================================
  // Public API
  // ============================================
  /** Focuses the messages panel. */
  focusMessages() {
    this.deps.getMessagesEl().focus();
  }
  /** Focuses the input. */
  focusInput() {
    this.deps.getInputEl().focus();
  }
};

// src/features/chat/controllers/SelectionController.ts
var import_obsidian13 = require("obsidian");

// src/shared/components/SelectionHighlight.ts
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
function createSelectionHighlighter() {
  const showHighlight = import_state.StateEffect.define();
  const hideHighlight = import_state.StateEffect.define();
  const selectionHighlightField = import_state.StateField.define({
    create: () => import_view.Decoration.none,
    update: (deco, tr) => {
      for (const e of tr.effects) {
        if (e.is(showHighlight)) {
          const builder = new import_state.RangeSetBuilder();
          builder.add(e.value.from, e.value.to, import_view.Decoration.mark({
            class: "claudian-selection-highlight"
          }));
          return builder.finish();
        } else if (e.is(hideHighlight)) {
          return import_view.Decoration.none;
        }
      }
      return deco.map(tr.changes);
    },
    provide: (f) => import_view.EditorView.decorations.from(f)
  });
  const installedEditors2 = /* @__PURE__ */ new WeakSet();
  function ensureHighlightField(editorView) {
    if (!installedEditors2.has(editorView)) {
      editorView.dispatch({
        effects: import_state.StateEffect.appendConfig.of(selectionHighlightField)
      });
      installedEditors2.add(editorView);
    }
  }
  function show(editorView, from, to) {
    ensureHighlightField(editorView);
    editorView.dispatch({
      effects: showHighlight.of({ from, to })
    });
  }
  function hide(editorView) {
    if (installedEditors2.has(editorView)) {
      editorView.dispatch({
        effects: hideHighlight.of(null)
      });
    }
  }
  return { show, hide };
}
var defaultHighlighter = createSelectionHighlighter();
function showSelectionHighlight(editorView, from, to) {
  defaultHighlighter.show(editorView, from, to);
}
function hideSelectionHighlight(editorView) {
  defaultHighlighter.hide(editorView);
}

// src/features/chat/controllers/SelectionController.ts
var SELECTION_POLL_INTERVAL = 250;
var SelectionController = class {
  constructor(app, indicatorEl, inputEl, contextRowEl, onVisibilityChange) {
    this.storedSelection = null;
    this.pollInterval = null;
    this.app = app;
    this.indicatorEl = indicatorEl;
    this.inputEl = inputEl;
    this.contextRowEl = contextRowEl;
    this.onVisibilityChange = onVisibilityChange != null ? onVisibilityChange : null;
  }
  // ============================================
  // Lifecycle
  // ============================================
  /** Starts polling for editor selection changes. */
  start() {
    if (this.pollInterval) return;
    this.pollInterval = setInterval(() => this.poll(), SELECTION_POLL_INTERVAL);
  }
  /** Stops polling and clears state. */
  stop() {
    if (this.pollInterval) {
      clearInterval(this.pollInterval);
      this.pollInterval = null;
    }
    this.clear();
  }
  /** Cleans up resources. Same as stop(). */
  dispose() {
    this.stop();
  }
  // ============================================
  // Selection Polling
  // ============================================
  /** Polls editor selection and updates stored selection. */
  poll() {
    var _a, _b, _c, _d;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian13.MarkdownView);
    if (!view) return;
    const editor = view.editor;
    const editorView = getEditorView(editor);
    if (!editorView) return;
    const selectedText = editor.getSelection();
    if (selectedText.trim()) {
      const fromPos = editor.getCursor("from");
      const toPos = editor.getCursor("to");
      const from = editor.posToOffset(fromPos);
      const to = editor.posToOffset(toPos);
      const startLine = fromPos.line + 1;
      const notePath = ((_a = view.file) == null ? void 0 : _a.path) || "unknown";
      const lineCount = selectedText.split(/\r?\n/).length;
      const sameRange = this.storedSelection && this.storedSelection.editorView === editorView && this.storedSelection.from === from && this.storedSelection.to === to && this.storedSelection.notePath === notePath;
      const sameText = sameRange && ((_b = this.storedSelection) == null ? void 0 : _b.selectedText) === selectedText;
      const sameLineCount = sameRange && ((_c = this.storedSelection) == null ? void 0 : _c.lineCount) === lineCount;
      const sameStartLine = sameRange && ((_d = this.storedSelection) == null ? void 0 : _d.startLine) === startLine;
      if (!sameRange || !sameText || !sameLineCount || !sameStartLine) {
        if (this.storedSelection && !sameRange) {
          this.clearHighlight();
        }
        this.storedSelection = { notePath, selectedText, lineCount, startLine, from, to, editorView };
        this.updateIndicator();
      }
    } else if (document.activeElement !== this.inputEl) {
      this.clearHighlight();
      this.storedSelection = null;
      this.updateIndicator();
    }
  }
  // ============================================
  // Highlight Management
  // ============================================
  /** Shows the selection highlight in the editor. */
  showHighlight() {
    if (!this.storedSelection) return;
    const { from, to, editorView } = this.storedSelection;
    showSelectionHighlight(editorView, from, to);
  }
  /** Clears the selection highlight from the editor. */
  clearHighlight() {
    if (!this.storedSelection) return;
    hideSelectionHighlight(this.storedSelection.editorView);
  }
  // ============================================
  // Indicator
  // ============================================
  /** Updates selection indicator based on stored selection. */
  updateIndicator() {
    if (!this.indicatorEl) return;
    if (this.storedSelection) {
      const lineText = this.storedSelection.lineCount === 1 ? "line" : "lines";
      this.indicatorEl.textContent = `${this.storedSelection.lineCount} ${lineText} selected`;
      this.indicatorEl.style.display = "block";
    } else {
      this.indicatorEl.style.display = "none";
    }
    this.updateContextRowVisibility();
  }
  /** Updates context row visibility based on whether any content is visible. */
  updateContextRowVisibility() {
    var _a;
    if (!this.contextRowEl) return;
    const hasSelection = this.storedSelection !== null;
    const fileIndicator = this.contextRowEl.querySelector(".claudian-file-indicator");
    const imagePreview = this.contextRowEl.querySelector(".claudian-image-preview");
    const hasFileChips = (fileIndicator == null ? void 0 : fileIndicator.style.display) === "flex";
    const hasImageChips = (imagePreview == null ? void 0 : imagePreview.style.display) === "flex";
    this.contextRowEl.classList.toggle("has-content", hasSelection || hasFileChips || hasImageChips);
    (_a = this.onVisibilityChange) == null ? void 0 : _a.call(this);
  }
  // ============================================
  // Context Access
  // ============================================
  /** Returns stored selection as EditorSelectionContext, or null if none. */
  getContext() {
    if (!this.storedSelection) return null;
    return {
      notePath: this.storedSelection.notePath,
      mode: "selection",
      selectedText: this.storedSelection.selectedText,
      lineCount: this.storedSelection.lineCount,
      startLine: this.storedSelection.startLine
    };
  }
  /** Checks if there is a stored selection. */
  hasSelection() {
    return this.storedSelection !== null;
  }
  // ============================================
  // Clear
  // ============================================
  /** Clears the stored selection and highlight. */
  clear() {
    this.clearHighlight();
    this.storedSelection = null;
    this.updateIndicator();
  }
};

// src/features/chat/controllers/StreamController.ts
var _StreamController = class _StreamController {
  constructor(deps) {
    this.deps = deps;
  }
  // ============================================
  // Stream Chunk Handling
  // ============================================
  /** Processes a stream chunk and updates the message. */
  async handleStreamChunk(chunk, msg) {
    var _a, _b, _c, _d, _e;
    const { state } = this.deps;
    if ("parentToolUseId" in chunk && chunk.parentToolUseId) {
      await this.handleSubagentChunk(chunk, msg);
      this.scrollToBottom();
      return;
    }
    switch (chunk.type) {
      case "thinking":
        this.flushPendingTools();
        if (state.currentTextEl) {
          this.finalizeCurrentTextBlock(msg);
        }
        await this.appendThinking(chunk.content, msg);
        break;
      case "text":
        this.flushPendingTools();
        if (state.currentThinkingState) {
          this.finalizeCurrentThinkingBlock(msg);
        }
        msg.content += chunk.content;
        await this.appendText(chunk.content);
        break;
      case "tool_use": {
        if (state.currentThinkingState) {
          this.finalizeCurrentThinkingBlock(msg);
        }
        this.finalizeCurrentTextBlock(msg);
        if (chunk.name === TOOL_TASK) {
          this.flushPendingTools();
          state.subagentsSpawnedThisStream++;
          const isAsync2 = this.deps.asyncSubagentManager.isAsyncTask(chunk.input);
          if (isAsync2) {
            await this.handleAsyncTaskToolUse(chunk, msg);
          } else {
            await this.handleTaskToolUse(chunk, msg);
          }
          break;
        }
        if (chunk.name === TOOL_AGENT_OUTPUT) {
          this.handleAgentOutputToolUse(chunk, msg);
          break;
        }
        this.handleRegularToolUse(chunk, msg);
        break;
      }
      case "tool_result": {
        this.handleToolResult(chunk, msg);
        break;
      }
      case "blocked":
        this.flushPendingTools();
        await this.appendText(`

\u26A0\uFE0F **Blocked:** ${chunk.content}`);
        break;
      case "error":
        this.flushPendingTools();
        await this.appendText(`

\u274C **Error:** ${chunk.content}`);
        break;
      case "done":
        this.flushPendingTools();
        break;
      case "usage": {
        const currentSessionId = (_d = (_c = (_b = (_a = this.deps).getAgentService) == null ? void 0 : _b.call(_a)) == null ? void 0 : _c.getSessionId()) != null ? _d : null;
        const chunkSessionId = (_e = chunk.sessionId) != null ? _e : null;
        if (chunkSessionId && currentSessionId && chunkSessionId !== currentSessionId || chunkSessionId && !currentSessionId) {
          break;
        }
        if (state.subagentsSpawnedThisStream > 0) {
          break;
        }
        if (!state.ignoreUsageUpdates) {
          state.usage = chunk.usage;
        }
        break;
      }
    }
    this.scrollToBottom();
  }
  // ============================================
  // Tool Use Handling
  // ============================================
  /**
   * Handles regular tool_use chunks by buffering them.
   * Tools are rendered when flushPendingTools is called (on next content type or tool_result).
   */
  handleRegularToolUse(chunk, msg) {
    var _a, _b;
    const { state } = this.deps;
    const existingToolCall = (_a = msg.toolCalls) == null ? void 0 : _a.find((tc) => tc.id === chunk.id);
    if (existingToolCall) {
      const newInput = chunk.input || {};
      if (Object.keys(newInput).length > 0) {
        existingToolCall.input = { ...existingToolCall.input, ...newInput };
        if (existingToolCall.name === TOOL_TODO_WRITE) {
          const todos = parseTodoInput(existingToolCall.input);
          if (todos) {
            this.deps.state.currentTodos = todos;
          }
        }
        const toolEl = state.toolCallElements.get(chunk.id);
        if (toolEl) {
          const labelEl = (_b = toolEl.querySelector(".claudian-tool-label")) != null ? _b : toolEl.querySelector(".claudian-write-edit-label");
          if (labelEl) {
            labelEl.setText(getToolLabel(existingToolCall.name, existingToolCall.input));
          }
        }
      }
      return;
    }
    const toolCall = {
      id: chunk.id,
      name: chunk.name,
      input: chunk.input,
      status: "running",
      isExpanded: false
    };
    msg.toolCalls = msg.toolCalls || [];
    msg.toolCalls.push(toolCall);
    msg.contentBlocks = msg.contentBlocks || [];
    msg.contentBlocks.push({ type: "tool_use", toolId: chunk.id });
    if (chunk.name === TOOL_TODO_WRITE) {
      const todos = parseTodoInput(chunk.input);
      if (todos) {
        this.deps.state.currentTodos = todos;
      }
    }
    if (state.currentContentEl) {
      state.pendingTools.set(chunk.id, {
        toolCall,
        parentEl: state.currentContentEl
      });
      this.showThinkingIndicator();
    }
  }
  /**
   * Flushes all pending tool calls by rendering them.
   * Called when a different content type arrives or stream ends.
   */
  flushPendingTools() {
    const { state } = this.deps;
    if (state.pendingTools.size === 0) {
      return;
    }
    for (const toolId of state.pendingTools.keys()) {
      this.renderPendingTool(toolId);
    }
    state.pendingTools.clear();
  }
  /**
   * Renders a single pending tool call and moves it from pending to rendered state.
   */
  renderPendingTool(toolId) {
    const { state } = this.deps;
    const pending = state.pendingTools.get(toolId);
    if (!pending) return;
    const { toolCall, parentEl } = pending;
    if (isWriteEditTool(toolCall.name)) {
      const writeEditState = createWriteEditBlock(parentEl, toolCall);
      state.writeEditStates.set(toolId, writeEditState);
      state.toolCallElements.set(toolId, writeEditState.wrapperEl);
    } else {
      renderToolCall(parentEl, toolCall, state.toolCallElements);
    }
    state.pendingTools.delete(toolId);
  }
  /** Handles tool_result chunks. */
  handleToolResult(chunk, msg) {
    var _a;
    const { state } = this.deps;
    const subagentState = state.activeSubagents.get(chunk.id);
    if (subagentState) {
      this.finalizeSubagent(chunk, msg, subagentState);
      return;
    }
    if (this.handleAsyncTaskToolResult(chunk, msg)) {
      this.showThinkingIndicator();
      return;
    }
    if (this.handleAgentOutputToolResult(chunk, msg)) {
      this.showThinkingIndicator();
      return;
    }
    if (state.pendingTools.has(chunk.id)) {
      this.renderPendingTool(chunk.id);
    }
    const existingToolCall = (_a = msg.toolCalls) == null ? void 0 : _a.find((tc) => tc.id === chunk.id);
    const isBlocked = isBlockedToolResult(chunk.content, chunk.isError);
    if (existingToolCall) {
      existingToolCall.status = isBlocked ? "blocked" : chunk.isError ? "error" : "completed";
      existingToolCall.result = chunk.content;
      const writeEditState = state.writeEditStates.get(chunk.id);
      if (writeEditState && isWriteEditTool(existingToolCall.name)) {
        if (!chunk.isError && !isBlocked) {
          const diffData = getDiffData(chunk.id);
          if (diffData) {
            existingToolCall.diffData = diffData;
            updateWriteEditWithDiff(writeEditState, diffData);
          }
        }
        finalizeWriteEditBlock(writeEditState, chunk.isError || isBlocked);
      } else {
        updateToolCallResult(chunk.id, existingToolCall, state.toolCallElements);
      }
    }
    this.showThinkingIndicator();
  }
  // ============================================
  // Text Block Management
  // ============================================
  /** Appends text to the current text block. */
  async appendText(text) {
    const { state, renderer } = this.deps;
    if (!state.currentContentEl) return;
    this.hideThinkingIndicator();
    if (!state.currentTextEl) {
      state.currentTextEl = state.currentContentEl.createDiv({ cls: "claudian-text-block" });
      state.currentTextContent = "";
    }
    state.currentTextContent += text;
    await renderer.renderContent(state.currentTextEl, state.currentTextContent);
  }
  /** Finalizes the current text block. */
  finalizeCurrentTextBlock(msg) {
    const { state } = this.deps;
    if (msg && state.currentTextContent) {
      msg.contentBlocks = msg.contentBlocks || [];
      msg.contentBlocks.push({ type: "text", content: state.currentTextContent });
    }
    state.currentTextEl = null;
    state.currentTextContent = "";
  }
  // ============================================
  // Thinking Block Management
  // ============================================
  /** Appends thinking content. */
  async appendThinking(content, msg) {
    const { state, renderer } = this.deps;
    if (!state.currentContentEl) return;
    this.hideThinkingIndicator();
    if (!state.currentThinkingState) {
      state.currentThinkingState = createThinkingBlock(
        state.currentContentEl,
        (el, md) => renderer.renderContent(el, md)
      );
    }
    await appendThinkingContent(state.currentThinkingState, content, (el, md) => renderer.renderContent(el, md));
  }
  /** Finalizes the current thinking block. */
  finalizeCurrentThinkingBlock(msg) {
    const { state } = this.deps;
    if (!state.currentThinkingState) return;
    const durationSeconds = finalizeThinkingBlock(state.currentThinkingState);
    if (msg && state.currentThinkingState.content) {
      msg.contentBlocks = msg.contentBlocks || [];
      msg.contentBlocks.push({
        type: "thinking",
        content: state.currentThinkingState.content,
        durationSeconds
      });
    }
    state.currentThinkingState = null;
  }
  // ============================================
  // Sync Subagent Handling
  // ============================================
  /** Handles Task tool_use by creating a sync subagent block. */
  async handleTaskToolUse(chunk, msg) {
    const { state } = this.deps;
    if (!state.currentContentEl) return;
    const existingState = state.activeSubagents.get(chunk.id);
    if (existingState) {
      const newInput = chunk.input || {};
      if (Object.keys(newInput).length > 0) {
        const description = newInput.description || "";
        if (description) {
          existingState.info.description = description;
          const labelEl = existingState.wrapperEl.querySelector(".claudian-subagent-label");
          if (labelEl) {
            const truncated = description.length > 40 ? description.substring(0, 40) + "..." : description;
            labelEl.setText(truncated);
          }
        }
      }
      return;
    }
    const subagentState = createSubagentBlock(state.currentContentEl, chunk.id, chunk.input);
    state.activeSubagents.set(chunk.id, subagentState);
    msg.subagents = msg.subagents || [];
    msg.subagents.push(subagentState.info);
    msg.contentBlocks = msg.contentBlocks || [];
    msg.contentBlocks.push({ type: "subagent", subagentId: chunk.id });
    this.showThinkingIndicator();
  }
  /** Routes chunks from subagents. */
  async handleSubagentChunk(chunk, msg) {
    if (!("parentToolUseId" in chunk) || !chunk.parentToolUseId) {
      return;
    }
    const parentToolUseId = chunk.parentToolUseId;
    const { state } = this.deps;
    const subagentState = state.activeSubagents.get(parentToolUseId);
    if (!subagentState) {
      return;
    }
    switch (chunk.type) {
      case "tool_use": {
        const toolCall = {
          id: chunk.id,
          name: chunk.name,
          input: chunk.input,
          status: "running",
          isExpanded: false
        };
        addSubagentToolCall(subagentState, toolCall);
        this.showThinkingIndicator();
        break;
      }
      case "tool_result": {
        const toolCall = subagentState.info.toolCalls.find((tc) => tc.id === chunk.id);
        if (toolCall) {
          const isBlocked = isBlockedToolResult(chunk.content, chunk.isError);
          toolCall.status = isBlocked ? "blocked" : chunk.isError ? "error" : "completed";
          toolCall.result = chunk.content;
          updateSubagentToolResult(subagentState, chunk.id, toolCall);
          getDiffData(chunk.id);
        }
        break;
      }
      case "text":
      case "thinking":
        break;
    }
  }
  /** Finalizes a sync subagent when its Task tool_result is received. */
  finalizeSubagent(chunk, msg, subagentState) {
    var _a;
    const { state } = this.deps;
    const isError = chunk.isError || false;
    finalizeSubagentBlock(subagentState, chunk.content, isError);
    const subagentInfo = (_a = msg.subagents) == null ? void 0 : _a.find((s) => s.id === chunk.id);
    if (subagentInfo) {
      subagentInfo.status = isError ? "error" : "completed";
      subagentInfo.result = chunk.content;
    }
    state.activeSubagents.delete(chunk.id);
    this.showThinkingIndicator();
  }
  // ============================================
  // Async Subagent Handling
  // ============================================
  /** Handles async Task tool_use (run_in_background=true). */
  async handleAsyncTaskToolUse(chunk, msg) {
    var _a;
    const { state, asyncSubagentManager } = this.deps;
    if (!state.currentContentEl) return;
    const existingState = state.asyncSubagentStates.get(chunk.id);
    if (existingState) {
      const newInput = chunk.input || {};
      if (Object.keys(newInput).length > 0) {
        const description = newInput.description || "";
        if (description) {
          const existingInfo = (_a = msg.subagents) == null ? void 0 : _a.find((s) => s.id === chunk.id);
          if (existingInfo) {
            existingInfo.description = description;
          }
          const labelEl = existingState.wrapperEl.querySelector(".claudian-subagent-label");
          if (labelEl) {
            const truncated = description.length > 40 ? description.substring(0, 40) + "..." : description;
            labelEl.setText(truncated);
          }
        }
      }
      return;
    }
    const subagentInfo = asyncSubagentManager.createAsyncSubagent(chunk.id, chunk.input);
    const asyncState = createAsyncSubagentBlock(state.currentContentEl, chunk.id, chunk.input);
    state.asyncSubagentStates.set(chunk.id, asyncState);
    msg.subagents = msg.subagents || [];
    msg.subagents.push(subagentInfo);
    msg.contentBlocks = msg.contentBlocks || [];
    msg.contentBlocks.push({ type: "subagent", subagentId: chunk.id, mode: "async" });
    this.showThinkingIndicator();
  }
  /** Handles AgentOutputTool tool_use (invisible, links to async subagent). */
  handleAgentOutputToolUse(chunk, _msg) {
    const toolCall = {
      id: chunk.id,
      name: chunk.name,
      input: chunk.input,
      status: "running",
      isExpanded: false
    };
    this.deps.asyncSubagentManager.handleAgentOutputToolUse(toolCall);
  }
  /** Handles async Task tool_result to extract agent_id. */
  handleAsyncTaskToolResult(chunk, _msg) {
    const { asyncSubagentManager } = this.deps;
    if (!asyncSubagentManager.isPendingAsyncTask(chunk.id)) {
      return false;
    }
    asyncSubagentManager.handleTaskToolResult(chunk.id, chunk.content, chunk.isError);
    return true;
  }
  /** Handles AgentOutputTool result to finalize async subagent. */
  handleAgentOutputToolResult(chunk, _msg) {
    const { asyncSubagentManager } = this.deps;
    const isLinked = asyncSubagentManager.isLinkedAgentOutputTool(chunk.id);
    const handled = asyncSubagentManager.handleAgentOutputToolResult(
      chunk.id,
      chunk.content,
      chunk.isError || false
    );
    return isLinked || handled !== void 0;
  }
  /** Callback from AsyncSubagentManager when state changes. */
  onAsyncSubagentStateChange(subagent) {
    const { state } = this.deps;
    let asyncState = state.asyncSubagentStates.get(subagent.id);
    if (!asyncState) {
      for (const s of state.asyncSubagentStates.values()) {
        if (s.info.agentId === subagent.agentId) {
          asyncState = s;
          break;
        }
      }
      if (!asyncState) return;
    }
    this.updateAsyncSubagentUI(asyncState, subagent);
  }
  /** Updates async subagent UI based on state. */
  updateAsyncSubagentUI(asyncState, subagent) {
    asyncState.info = subagent;
    switch (subagent.asyncStatus) {
      case "running":
        updateAsyncSubagentRunning(asyncState, subagent.agentId || "");
        break;
      case "completed":
      case "error":
        finalizeAsyncSubagent(asyncState, subagent.result || "", subagent.asyncStatus === "error");
        break;
      case "orphaned":
        markAsyncSubagentOrphaned(asyncState);
        break;
    }
    this.updateSubagentInMessages(subagent);
    this.scrollToBottom();
  }
  /** Updates subagent info in messages array. */
  updateSubagentInMessages(subagent) {
    const { state } = this.deps;
    for (let i = state.messages.length - 1; i >= 0; i--) {
      const msg = state.messages[i];
      if (msg.role === "assistant" && msg.subagents) {
        const idx = msg.subagents.findIndex((s) => s.id === subagent.id);
        if (idx !== -1) {
          msg.subagents[idx] = subagent;
          return;
        }
      }
    }
  }
  /**
   * Schedules showing the thinking indicator after a delay.
   * If content arrives before the delay, the indicator won't show.
   * This prevents the indicator from appearing during active streaming.
   * Note: Flavor text is hidden when model thinking block is active (thinking takes priority).
   */
  showThinkingIndicator() {
    const { state } = this.deps;
    if (!state.currentContentEl) return;
    if (state.thinkingIndicatorTimeout) {
      clearTimeout(state.thinkingIndicatorTimeout);
      state.thinkingIndicatorTimeout = null;
    }
    if (state.currentThinkingState) {
      return;
    }
    if (state.thinkingEl) {
      state.currentContentEl.appendChild(state.thinkingEl);
      this.deps.updateQueueIndicator();
      return;
    }
    state.thinkingIndicatorTimeout = setTimeout(() => {
      state.thinkingIndicatorTimeout = null;
      if (!state.currentContentEl || state.thinkingEl || state.currentThinkingState) return;
      state.thinkingEl = state.currentContentEl.createDiv({ cls: "claudian-thinking" });
      const randomText = FLAVOR_TEXTS[Math.floor(Math.random() * FLAVOR_TEXTS.length)];
      state.thinkingEl.createSpan({ text: randomText });
      state.thinkingEl.createSpan({ text: " (esc to interrupt)", cls: "claudian-thinking-hint" });
      state.queueIndicatorEl = state.thinkingEl.createDiv({ cls: "claudian-queue-indicator" });
      this.deps.updateQueueIndicator();
    }, _StreamController.THINKING_INDICATOR_DELAY);
  }
  /** Hides the thinking indicator and cancels any pending show timeout. */
  hideThinkingIndicator() {
    const { state } = this.deps;
    if (state.thinkingIndicatorTimeout) {
      clearTimeout(state.thinkingIndicatorTimeout);
      state.thinkingIndicatorTimeout = null;
    }
    if (state.thinkingEl) {
      state.thinkingEl.remove();
      state.thinkingEl = null;
    }
    state.queueIndicatorEl = null;
  }
  // ============================================
  // Utilities
  // ============================================
  /** Scrolls messages to bottom if auto-scroll is enabled. */
  scrollToBottom() {
    const { state } = this.deps;
    if (!state.autoScrollEnabled) return;
    const messagesEl = this.deps.getMessagesEl();
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }
  /** Resets streaming state after completion. */
  resetStreamingState() {
    const { state } = this.deps;
    this.hideThinkingIndicator();
    state.currentContentEl = null;
    state.currentTextEl = null;
    state.currentTextContent = "";
    state.currentThinkingState = null;
    state.activeSubagents.clear();
    state.pendingTools.clear();
  }
};
// ============================================
// Thinking Indicator
// ============================================
/** Debounce delay before showing thinking indicator (ms). */
_StreamController.THINKING_INDICATOR_DELAY = 400;
var StreamController = _StreamController;

// src/features/chat/services/AsyncSubagentManager.ts
var AsyncSubagentManager = class {
  constructor(onStateChange) {
    this.activeAsyncSubagents = /* @__PURE__ */ new Map();
    this.pendingAsyncSubagents = /* @__PURE__ */ new Map();
    this.taskIdToAgentId = /* @__PURE__ */ new Map();
    this.outputToolIdToAgentId = /* @__PURE__ */ new Map();
    this.onStateChange = onStateChange;
  }
  /** Updates the state change callback. Used for deferred wiring after construction. */
  setCallback(callback) {
    this.onStateChange = callback;
  }
  /** Checks if a Task tool input indicates async mode (run_in_background=true). */
  isAsyncTask(taskInput) {
    return taskInput.run_in_background === true;
  }
  /** Creates an async subagent in pending state. */
  createAsyncSubagent(taskToolId, taskInput) {
    const description = taskInput.description || "Background task";
    const subagent = {
      id: taskToolId,
      description,
      mode: "async",
      isExpanded: false,
      status: "running",
      toolCalls: [],
      asyncStatus: "pending"
    };
    this.pendingAsyncSubagents.set(taskToolId, subagent);
    return subagent;
  }
  /** Handles Task tool_result to extract agent_id. Transitions: pending  running/error. */
  handleTaskToolResult(taskToolId, result, isError) {
    const subagent = this.pendingAsyncSubagents.get(taskToolId);
    if (!subagent) {
      return;
    }
    if (isError) {
      subagent.asyncStatus = "error";
      subagent.status = "error";
      subagent.result = result || "Task failed to start";
      subagent.completedAt = Date.now();
      this.pendingAsyncSubagents.delete(taskToolId);
      this.onStateChange(subagent);
      return;
    }
    const agentId = this.parseAgentId(result);
    if (!agentId) {
      subagent.asyncStatus = "error";
      subagent.status = "error";
      const truncatedResult = result.length > 100 ? result.substring(0, 100) + "..." : result;
      subagent.result = `Failed to parse agent_id. Result: ${truncatedResult}`;
      subagent.completedAt = Date.now();
      this.pendingAsyncSubagents.delete(taskToolId);
      this.onStateChange(subagent);
      return;
    }
    subagent.asyncStatus = "running";
    subagent.agentId = agentId;
    subagent.startedAt = Date.now();
    this.pendingAsyncSubagents.delete(taskToolId);
    this.activeAsyncSubagents.set(agentId, subagent);
    this.taskIdToAgentId.set(taskToolId, agentId);
    this.onStateChange(subagent);
  }
  /** Links AgentOutputTool to its async subagent for result routing. */
  handleAgentOutputToolUse(toolCall) {
    const agentId = this.extractAgentIdFromInput(toolCall.input);
    if (!agentId) {
      return;
    }
    const subagent = this.activeAsyncSubagents.get(agentId);
    if (!subagent) {
      return;
    }
    subagent.outputToolId = toolCall.id;
    this.outputToolIdToAgentId.set(toolCall.id, agentId);
  }
  /** Handles AgentOutputTool result. Transitions: running  completed/error (if done). */
  handleAgentOutputToolResult(toolId, result, isError) {
    let agentId = this.outputToolIdToAgentId.get(toolId);
    let subagent = agentId ? this.activeAsyncSubagents.get(agentId) : void 0;
    if (!subagent) {
      const inferredAgentId = this.inferAgentIdFromResult(result);
      if (inferredAgentId) {
        agentId = inferredAgentId;
        subagent = this.activeAsyncSubagents.get(inferredAgentId);
      }
    }
    if (!subagent) {
      return void 0;
    }
    if (agentId) {
      subagent.agentId = subagent.agentId || agentId;
      this.outputToolIdToAgentId.set(toolId, agentId);
    }
    const validStates = ["running"];
    if (!validStates.includes(subagent.asyncStatus)) {
      return void 0;
    }
    const stillRunning = this.isStillRunningResult(result, isError);
    if (stillRunning) {
      this.outputToolIdToAgentId.delete(toolId);
      return subagent;
    }
    const extractedResult = this.extractAgentResult(result, agentId != null ? agentId : "");
    subagent.asyncStatus = isError ? "error" : "completed";
    subagent.status = isError ? "error" : "completed";
    subagent.result = extractedResult;
    subagent.completedAt = Date.now();
    if (agentId) this.activeAsyncSubagents.delete(agentId);
    this.outputToolIdToAgentId.delete(toolId);
    this.onStateChange(subagent);
    return subagent;
  }
  /** Checks if AgentOutputTool result indicates the task is still running. */
  isStillRunningResult(result, isError) {
    const trimmed = (result == null ? void 0 : result.trim()) || "";
    const unwrapTextPayload = (raw) => {
      try {
        const parsed = JSON.parse(raw);
        if (Array.isArray(parsed)) {
          const textBlock = parsed.find((b) => b && typeof b.text === "string");
          if (textBlock == null ? void 0 : textBlock.text) return textBlock.text;
        } else if (parsed && typeof parsed === "object" && typeof parsed.text === "string") {
          return parsed.text;
        }
      } catch (e) {
      }
      return raw;
    };
    const payload = unwrapTextPayload(trimmed);
    if (isError) {
      return false;
    }
    if (!trimmed) {
      return false;
    }
    try {
      const parsed = JSON.parse(payload);
      const status = parsed.retrieval_status || parsed.status;
      const hasAgents = parsed.agents && Object.keys(parsed.agents).length > 0;
      if (status === "not_ready" || status === "running" || status === "pending") {
        return true;
      }
      if (hasAgents) {
        const agentStatuses = Object.values(parsed.agents).map((a) => a && typeof a.status === "string" ? a.status.toLowerCase() : "");
        const anyRunning = agentStatuses.some(
          (s) => s === "running" || s === "pending" || s === "not_ready"
        );
        if (anyRunning) return true;
        return false;
      }
      if (status === "success" || status === "completed") {
        return false;
      }
      return false;
    } catch (e) {
    }
    const lowerResult = payload.toLowerCase();
    if (lowerResult.includes("not_ready") || lowerResult.includes("not ready")) {
      return true;
    }
    return false;
  }
  /** Extracts the actual result content from AgentOutputTool response. */
  extractAgentResult(result, agentId) {
    const unwrap = (raw) => {
      try {
        const parsed = JSON.parse(raw);
        if (Array.isArray(parsed)) {
          const textBlock = parsed.find((b) => b && typeof b.text === "string");
          if (textBlock == null ? void 0 : textBlock.text) return textBlock.text;
        } else if (parsed && typeof parsed === "object" && typeof parsed.text === "string") {
          return parsed.text;
        }
      } catch (e) {
      }
      return raw;
    };
    const payload = unwrap(result);
    try {
      const parsed = JSON.parse(payload);
      if (parsed.agents && agentId && parsed.agents[agentId]) {
        const agentData = parsed.agents[agentId];
        if (agentData.result) {
          return agentData.result;
        }
        return JSON.stringify(agentData, null, 2);
      }
      if (parsed.agents) {
        const agentIds = Object.keys(parsed.agents);
        if (agentIds.length > 0) {
          const firstAgent = parsed.agents[agentIds[0]];
          if (firstAgent.result) {
            return firstAgent.result;
          }
          return JSON.stringify(firstAgent, null, 2);
        }
      }
    } catch (e) {
    }
    return payload;
  }
  /** Orphans all active async subagents when conversation ends. */
  orphanAllActive() {
    const orphaned = [];
    for (const subagent of this.pendingAsyncSubagents.values()) {
      subagent.asyncStatus = "orphaned";
      subagent.status = "error";
      subagent.result = "Conversation ended before task completed";
      subagent.completedAt = Date.now();
      orphaned.push(subagent);
      this.onStateChange(subagent);
    }
    for (const subagent of this.activeAsyncSubagents.values()) {
      if (subagent.asyncStatus === "running") {
        subagent.asyncStatus = "orphaned";
        subagent.status = "error";
        subagent.result = "Conversation ended before task completed";
        subagent.completedAt = Date.now();
        orphaned.push(subagent);
        this.onStateChange(subagent);
      }
    }
    this.pendingAsyncSubagents.clear();
    this.activeAsyncSubagents.clear();
    this.outputToolIdToAgentId.clear();
    return orphaned;
  }
  /** Clears all state for a new conversation. */
  clear() {
    this.pendingAsyncSubagents.clear();
    this.activeAsyncSubagents.clear();
    this.taskIdToAgentId.clear();
    this.outputToolIdToAgentId.clear();
  }
  /** Gets async subagent by agent_id. */
  getByAgentId(agentId) {
    return this.activeAsyncSubagents.get(agentId);
  }
  /** Gets async subagent by task tool_use_id. */
  getByTaskId(taskToolId) {
    const pending = this.pendingAsyncSubagents.get(taskToolId);
    if (pending) return pending;
    const agentId = this.taskIdToAgentId.get(taskToolId);
    if (agentId) {
      return this.activeAsyncSubagents.get(agentId);
    }
    return void 0;
  }
  /** Checks if a task tool_id is a pending async subagent. */
  isPendingAsyncTask(taskToolId) {
    return this.pendingAsyncSubagents.has(taskToolId);
  }
  /** Checks if a tool_id is an AgentOutputTool linked to an async subagent. */
  isLinkedAgentOutputTool(toolId) {
    return this.outputToolIdToAgentId.has(toolId);
  }
  /** Gets all active async subagents (pending + running). */
  getAllActive() {
    return [
      ...this.pendingAsyncSubagents.values(),
      ...this.activeAsyncSubagents.values()
    ];
  }
  /** Checks if there are any active async subagents. */
  hasActiveAsync() {
    return this.pendingAsyncSubagents.size > 0 || this.activeAsyncSubagents.size > 0;
  }
  /** Parses agent_id from Task tool_result. */
  parseAgentId(result) {
    var _a;
    const regexPatterns = [
      /"agent_id"\s*:\s*"([^"]+)"/,
      // JSON style: "agent_id": "value"
      /"agentId"\s*:\s*"([^"]+)"/,
      // camelCase JSON
      /agent_id[=:]\s*"?([a-zA-Z0-9_-]+)"?/i,
      // Flexible format
      /agentId[=:]\s*"?([a-zA-Z0-9_-]+)"?/i,
      // camelCase flexible
      /\b([a-f0-9]{8})\b/
      // Short hex ID (8 chars)
    ];
    for (const pattern of regexPatterns) {
      const match = result.match(pattern);
      if (match && match[1]) {
        return match[1];
      }
    }
    try {
      const parsed = JSON.parse(result);
      const agentId = parsed.agent_id || parsed.agentId;
      if (typeof agentId === "string" && agentId.length > 0) {
        return agentId;
      }
      if ((_a = parsed.data) == null ? void 0 : _a.agent_id) {
        return parsed.data.agent_id;
      }
      if (parsed.id && typeof parsed.id === "string") {
        return parsed.id;
      }
    } catch (e) {
    }
    return null;
  }
  /** Infers agent_id from AgentOutputTool result payload. */
  inferAgentIdFromResult(result) {
    try {
      const parsed = JSON.parse(result);
      if (parsed.agents && typeof parsed.agents === "object") {
        const keys = Object.keys(parsed.agents);
        if (keys.length > 0) {
          return keys[0];
        }
      }
    } catch (e) {
    }
    return null;
  }
  /** Extracts agentId from AgentOutputTool input. */
  extractAgentIdFromInput(input) {
    const agentId = input.agentId || input.agent_id;
    return agentId || null;
  }
};

// src/core/prompts/instructionRefine.ts
function buildRefineSystemPrompt(existingInstructions) {
  const existingSection = existingInstructions.trim() ? `

EXISTING INSTRUCTIONS (already in the user's system prompt):
\`\`\`
${existingInstructions.trim()}
\`\`\`

When refining the new instruction:
- Consider how it fits with existing instructions
- Avoid duplicating existing instructions
- If the new instruction conflicts with an existing one, refine it to be complementary or note the conflict
- Match the format of existing instructions (section, heading, bullet points, style, etc.)` : "";
  return `You are an expert Prompt Engineer. You help users craft precise, effective system instructions for their AI assistant.

**Your Goal**: Transform vague or simple user requests into **high-quality, actionable, and non-conflicting** system prompt instructions.

**Process**:
1.  **Analyze Intent**: What behavior does the user want to enforce or change?
2.  **Check Context**: Does this conflict with existing instructions?
    - *No Conflict*: Add as new.
    - *Conflict*: Propose a **merged instruction** that resolves the contradiction (or ask if unsure).
3.  **Refine**: Draft a clear, positive instruction (e.g., "Do X" instead of "Don't do Y").
4.  **Format**: Return *only* the Markdown snippet wrapped in \`<instruction>\` tags.

**Guidelines**:
- **Clarity**: Use precise language. Avoid ambiguity.
- **Scope**: Keep it focused. Don't add unrelated rules.
- **Format**: Valid Markdown (bullets \`-\` or sections \`##\`).
- **No Header**: Do NOT include a top-level header like \`# Custom Instructions\`.
- **Conflict Handling**: If the new rule directly contradicts an existing one, rewrite the *new* one to override specific cases or ask for clarification.

**Output Format**:
- **Success**: \`<instruction>...markdown content...</instruction>\`
- **Ambiguity**: Plain text question.

${existingSection}

**Examples**:

Input: "typescript for code"
Output: <instruction>- **Code Language**: Always use TypeScript for code examples. Include proper type annotations and interfaces.</instruction>

Input: "be concise"
Output: <instruction>- **Conciseness**: Provide brief, direct responses. Omit conversational filler and unnecessary explanations.</instruction>

Input: "organize coding style rules"
Output: <instruction>## Coding Standards

- **Language**: Use TypeScript.
- **Style**: Prefer functional patterns.
- **Review**: Keep diffs small.</instruction>

Input: "use that thing from before"
Output: I'm not sure what you're referring to. Could you please clarify?`;
}

// src/features/chat/services/InstructionRefineService.ts
var InstructionRefineService = class {
  constructor(plugin) {
    this.abortController = null;
    this.sessionId = null;
    this.existingInstructions = "";
    this.plugin = plugin;
  }
  /** Resets conversation state for a new refinement session. */
  resetConversation() {
    this.sessionId = null;
  }
  /** Refines a raw instruction from user input. */
  async refineInstruction(rawInstruction, existingInstructions, onProgress) {
    this.sessionId = null;
    this.existingInstructions = existingInstructions;
    const prompt = `Please refine this instruction: "${rawInstruction}"`;
    return this.sendMessage(prompt, onProgress);
  }
  /** Continues conversation with a follow-up message (for clarifications). */
  async continueConversation(message, onProgress) {
    if (!this.sessionId) {
      return { success: false, error: "No active conversation to continue" };
    }
    return this.sendMessage(message, onProgress);
  }
  /** Cancels any ongoing query. */
  cancel() {
    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
    }
  }
  async sendMessage(prompt, onProgress) {
    var _a;
    const vaultPath = getVaultPath(this.plugin.app);
    if (!vaultPath) {
      return { success: false, error: "Could not determine vault path" };
    }
    const resolvedClaudePath = this.plugin.getResolvedClaudeCliPath();
    if (!resolvedClaudePath) {
      return { success: false, error: "Claude CLI not found. Please install Claude Code CLI." };
    }
    this.abortController = new AbortController();
    const customEnv = parseEnvironmentVariables(this.plugin.getActiveEnvironmentVariables());
    const options = {
      cwd: vaultPath,
      systemPrompt: buildRefineSystemPrompt(this.existingInstructions),
      model: this.plugin.settings.model,
      abortController: this.abortController,
      pathToClaudeCodeExecutable: resolvedClaudePath,
      env: {
        ...process.env,
        ...customEnv,
        PATH: getEnhancedPath(customEnv.PATH, resolvedClaudePath)
      },
      tools: [],
      // No tools needed for instruction refinement
      permissionMode: "bypassPermissions",
      allowDangerouslySkipPermissions: true,
      settingSources: this.plugin.settings.loadUserClaudeSettings ? ["user", "project"] : ["project"]
    };
    if (this.sessionId) {
      options.resume = this.sessionId;
    }
    const budgetSetting = this.plugin.settings.thinkingBudget;
    const budgetConfig = THINKING_BUDGETS.find((b) => b.value === budgetSetting);
    if (budgetConfig && budgetConfig.tokens > 0) {
      options.maxThinkingTokens = budgetConfig.tokens;
    }
    try {
      const response = query({ prompt, options });
      let responseText = "";
      for await (const message of response) {
        if ((_a = this.abortController) == null ? void 0 : _a.signal.aborted) {
          await response.interrupt();
          return { success: false, error: "Cancelled" };
        }
        if (message.type === "system" && message.subtype === "init" && message.session_id) {
          this.sessionId = message.session_id;
        }
        const text = this.extractTextFromMessage(message);
        if (text) {
          responseText += text;
          if (onProgress) {
            const partialResult = this.parseResponse(responseText);
            onProgress(partialResult);
          }
        }
      }
      return this.parseResponse(responseText);
    } catch (error2) {
      const msg = error2 instanceof Error ? error2.message : "Unknown error";
      return { success: false, error: msg };
    } finally {
      this.abortController = null;
    }
  }
  /** Parses response text for <instruction> tag. */
  parseResponse(responseText) {
    const instructionMatch = responseText.match(/<instruction>([\s\S]*?)<\/instruction>/);
    if (instructionMatch) {
      return { success: true, refinedInstruction: instructionMatch[1].trim() };
    }
    const trimmed = responseText.trim();
    if (trimmed) {
      return { success: true, clarification: trimmed };
    }
    return { success: false, error: "Empty response" };
  }
  /** Extracts text content from SDK message. */
  extractTextFromMessage(message) {
    var _a;
    if (message.type !== "assistant" || !((_a = message.message) == null ? void 0 : _a.content)) {
      return "";
    }
    return message.message.content.filter((block) => block.type === "text" && !!block.text).map((block) => block.text).join("");
  }
};

// src/core/prompts/titleGeneration.ts
var TITLE_GENERATION_SYSTEM_PROMPT = `You are a specialist in summarizing intent.

**Task**: Generate a **concise, descriptive title** (max 50 chars) for this conversation based on the first interaction.

**Rules**:
1.  **Format**: Sentence case. No periods/quotes.
2.  **Structure**: Start with a **strong verb** (e.g., Create, Fix, Debug, Explain, Analyze).
3.  **Forbidden**: "Conversation with...", "Help me...", "Question about...", "I need...".
4.  **Tech Context**: Detect and include the primary language/framework if code is present (e.g., "Debug Python script", "Refactor React hook").

**Output**: Return ONLY the raw title text.`;

// src/features/chat/services/TitleGenerationService.ts
var TitleGenerationService = class {
  constructor(plugin) {
    /** Map of conversationId to AbortController for concurrent generation support. */
    this.activeGenerations = /* @__PURE__ */ new Map();
    this.plugin = plugin;
  }
  /**
   * Generates a title for a conversation based on first messages.
   * Non-blocking: calls callback when complete.
   */
  async generateTitle(conversationId, userMessage, assistantResponse, callback) {
    const vaultPath = getVaultPath(this.plugin.app);
    if (!vaultPath) {
      await this.safeCallback(callback, conversationId, {
        success: false,
        error: "Could not determine vault path"
      });
      return;
    }
    const envVars = parseEnvironmentVariables(
      this.plugin.getActiveEnvironmentVariables()
    );
    const resolvedClaudePath = this.plugin.getResolvedClaudeCliPath();
    if (!resolvedClaudePath) {
      await this.safeCallback(callback, conversationId, {
        success: false,
        error: "Claude CLI not found"
      });
      return;
    }
    const titleModel = this.plugin.settings.titleGenerationModel || envVars.ANTHROPIC_DEFAULT_HAIKU_MODEL || "claude-haiku-4-5";
    const existingController = this.activeGenerations.get(conversationId);
    if (existingController) {
      existingController.abort();
    }
    const abortController = new AbortController();
    this.activeGenerations.set(conversationId, abortController);
    const truncatedUser = this.truncateText(userMessage, 500);
    const truncatedAssistant = this.truncateText(assistantResponse, 500);
    const prompt = `User's first message:
"""
${truncatedUser}
"""

AI's response:
"""
${truncatedAssistant}
"""

Generate a title for this conversation:`;
    const options = {
      cwd: vaultPath,
      systemPrompt: TITLE_GENERATION_SYSTEM_PROMPT,
      model: titleModel,
      abortController,
      pathToClaudeCodeExecutable: resolvedClaudePath,
      env: {
        ...process.env,
        ...envVars,
        PATH: getEnhancedPath(envVars.PATH, resolvedClaudePath)
      },
      tools: [],
      // No tools needed for title generation
      permissionMode: "bypassPermissions",
      allowDangerouslySkipPermissions: true,
      settingSources: this.plugin.settings.loadUserClaudeSettings ? ["user", "project"] : ["project"],
      persistSession: false
      // Don't save title generation queries to session history
    };
    try {
      const response = query({ prompt, options });
      let responseText = "";
      for await (const message of response) {
        if (abortController.signal.aborted) {
          await this.safeCallback(callback, conversationId, {
            success: false,
            error: "Cancelled"
          });
          return;
        }
        const text = this.extractTextFromMessage(message);
        if (text) {
          responseText += text;
        }
      }
      const title = this.parseTitle(responseText);
      if (title) {
        await this.safeCallback(callback, conversationId, { success: true, title });
      } else {
        await this.safeCallback(callback, conversationId, {
          success: false,
          error: "Failed to parse title from response"
        });
      }
    } catch (error2) {
      const msg = error2 instanceof Error ? error2.message : "Unknown error";
      await this.safeCallback(callback, conversationId, { success: false, error: msg });
    } finally {
      this.activeGenerations.delete(conversationId);
    }
  }
  /** Cancels all ongoing title generations. */
  cancel() {
    for (const controller of this.activeGenerations.values()) {
      controller.abort();
    }
    this.activeGenerations.clear();
  }
  /** Truncates text to a maximum length with ellipsis. */
  truncateText(text, maxLength) {
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength) + "...";
  }
  /** Extracts text content from SDK message. */
  extractTextFromMessage(message) {
    var _a;
    if (message.type !== "assistant" || !((_a = message.message) == null ? void 0 : _a.content)) {
      return "";
    }
    return message.message.content.filter(
      (block) => block.type === "text" && !!block.text
    ).map((block) => block.text).join("");
  }
  /** Parses and cleans the title from response. */
  parseTitle(responseText) {
    const trimmed = responseText.trim();
    if (!trimmed) return null;
    let title = trimmed;
    if (title.startsWith('"') && title.endsWith('"') || title.startsWith("'") && title.endsWith("'")) {
      title = title.slice(1, -1);
    }
    title = title.replace(/[.!?:;,]+$/, "");
    if (title.length > 50) {
      title = title.substring(0, 47) + "...";
    }
    return title || null;
  }
  /** Safely invokes callback with try-catch to prevent unhandled errors. */
  async safeCallback(callback, conversationId, result) {
    try {
      await callback(conversationId, result);
    } catch (e) {
    }
  }
};

// src/features/chat/state/ChatState.ts
function createInitialState() {
  return {
    messages: [],
    isStreaming: false,
    cancelRequested: false,
    streamGeneration: 0,
    isCreatingConversation: false,
    isSwitchingConversation: false,
    currentConversationId: null,
    queuedMessage: null,
    currentContentEl: null,
    currentTextEl: null,
    currentTextContent: "",
    currentThinkingState: null,
    thinkingEl: null,
    queueIndicatorEl: null,
    thinkingIndicatorTimeout: null,
    toolCallElements: /* @__PURE__ */ new Map(),
    activeSubagents: /* @__PURE__ */ new Map(),
    asyncSubagentStates: /* @__PURE__ */ new Map(),
    writeEditStates: /* @__PURE__ */ new Map(),
    pendingTools: /* @__PURE__ */ new Map(),
    usage: null,
    ignoreUsageUpdates: false,
    subagentsSpawnedThisStream: 0,
    currentTodos: null,
    needsAttention: false,
    autoScrollEnabled: true
  };
}
var ChatState = class {
  constructor(callbacks = {}) {
    this.state = createInitialState();
    this._callbacks = callbacks;
  }
  /** Gets the callbacks. */
  get callbacks() {
    return this._callbacks;
  }
  /** Sets the callbacks (for updating after construction). */
  set callbacks(value) {
    this._callbacks = value;
  }
  // ============================================
  // Messages
  // ============================================
  get messages() {
    return [...this.state.messages];
  }
  set messages(value) {
    var _a, _b;
    this.state.messages = value;
    (_b = (_a = this._callbacks).onMessagesChanged) == null ? void 0 : _b.call(_a);
  }
  addMessage(msg) {
    var _a, _b;
    this.state.messages.push(msg);
    (_b = (_a = this._callbacks).onMessagesChanged) == null ? void 0 : _b.call(_a);
  }
  clearMessages() {
    var _a, _b;
    this.state.messages = [];
    (_b = (_a = this._callbacks).onMessagesChanged) == null ? void 0 : _b.call(_a);
  }
  // ============================================
  // Streaming Control
  // ============================================
  get isStreaming() {
    return this.state.isStreaming;
  }
  set isStreaming(value) {
    var _a, _b;
    this.state.isStreaming = value;
    (_b = (_a = this._callbacks).onStreamingStateChanged) == null ? void 0 : _b.call(_a, value);
  }
  get cancelRequested() {
    return this.state.cancelRequested;
  }
  set cancelRequested(value) {
    this.state.cancelRequested = value;
  }
  get streamGeneration() {
    return this.state.streamGeneration;
  }
  bumpStreamGeneration() {
    this.state.streamGeneration += 1;
    return this.state.streamGeneration;
  }
  get isCreatingConversation() {
    return this.state.isCreatingConversation;
  }
  set isCreatingConversation(value) {
    this.state.isCreatingConversation = value;
  }
  get isSwitchingConversation() {
    return this.state.isSwitchingConversation;
  }
  set isSwitchingConversation(value) {
    this.state.isSwitchingConversation = value;
  }
  // ============================================
  // Conversation
  // ============================================
  get currentConversationId() {
    return this.state.currentConversationId;
  }
  set currentConversationId(value) {
    var _a, _b;
    this.state.currentConversationId = value;
    (_b = (_a = this._callbacks).onConversationChanged) == null ? void 0 : _b.call(_a, value);
  }
  // ============================================
  // Queued Message
  // ============================================
  get queuedMessage() {
    return this.state.queuedMessage;
  }
  set queuedMessage(value) {
    this.state.queuedMessage = value;
  }
  // ============================================
  // Streaming DOM State
  // ============================================
  get currentContentEl() {
    return this.state.currentContentEl;
  }
  set currentContentEl(value) {
    this.state.currentContentEl = value;
  }
  get currentTextEl() {
    return this.state.currentTextEl;
  }
  set currentTextEl(value) {
    this.state.currentTextEl = value;
  }
  get currentTextContent() {
    return this.state.currentTextContent;
  }
  set currentTextContent(value) {
    this.state.currentTextContent = value;
  }
  get currentThinkingState() {
    return this.state.currentThinkingState;
  }
  set currentThinkingState(value) {
    this.state.currentThinkingState = value;
  }
  get thinkingEl() {
    return this.state.thinkingEl;
  }
  set thinkingEl(value) {
    this.state.thinkingEl = value;
  }
  get queueIndicatorEl() {
    return this.state.queueIndicatorEl;
  }
  set queueIndicatorEl(value) {
    this.state.queueIndicatorEl = value;
  }
  get thinkingIndicatorTimeout() {
    return this.state.thinkingIndicatorTimeout;
  }
  set thinkingIndicatorTimeout(value) {
    this.state.thinkingIndicatorTimeout = value;
  }
  // ============================================
  // Tool and Subagent Tracking Maps (mutable references)
  // ============================================
  get toolCallElements() {
    return this.state.toolCallElements;
  }
  get activeSubagents() {
    return this.state.activeSubagents;
  }
  get asyncSubagentStates() {
    return this.state.asyncSubagentStates;
  }
  get writeEditStates() {
    return this.state.writeEditStates;
  }
  get pendingTools() {
    return this.state.pendingTools;
  }
  // ============================================
  // Usage State
  // ============================================
  get usage() {
    return this.state.usage;
  }
  set usage(value) {
    var _a, _b;
    this.state.usage = value;
    (_b = (_a = this._callbacks).onUsageChanged) == null ? void 0 : _b.call(_a, value);
  }
  get ignoreUsageUpdates() {
    return this.state.ignoreUsageUpdates;
  }
  set ignoreUsageUpdates(value) {
    this.state.ignoreUsageUpdates = value;
  }
  get subagentsSpawnedThisStream() {
    return this.state.subagentsSpawnedThisStream;
  }
  set subagentsSpawnedThisStream(value) {
    this.state.subagentsSpawnedThisStream = value;
  }
  // ============================================
  // Current Todos (for persistent bottom panel)
  // ============================================
  get currentTodos() {
    return this.state.currentTodos ? [...this.state.currentTodos] : null;
  }
  set currentTodos(value) {
    var _a, _b;
    const normalizedValue = value && value.length > 0 ? value : null;
    this.state.currentTodos = normalizedValue;
    (_b = (_a = this._callbacks).onTodosChanged) == null ? void 0 : _b.call(_a, normalizedValue);
  }
  // ============================================
  // Attention State (approval pending, error, etc.)
  // ============================================
  get needsAttention() {
    return this.state.needsAttention;
  }
  set needsAttention(value) {
    var _a, _b;
    this.state.needsAttention = value;
    (_b = (_a = this._callbacks).onAttentionChanged) == null ? void 0 : _b.call(_a, value);
  }
  // ============================================
  // Auto-Scroll Control
  // ============================================
  get autoScrollEnabled() {
    return this.state.autoScrollEnabled;
  }
  set autoScrollEnabled(value) {
    var _a, _b;
    const changed = this.state.autoScrollEnabled !== value;
    this.state.autoScrollEnabled = value;
    if (changed) {
      (_b = (_a = this._callbacks).onAutoScrollChanged) == null ? void 0 : _b.call(_a, value);
    }
  }
  // ============================================
  // Reset Methods
  // ============================================
  /** Resets streaming-related state. */
  resetStreamingState() {
    this.state.currentContentEl = null;
    this.state.currentTextEl = null;
    this.state.currentTextContent = "";
    this.state.currentThinkingState = null;
    this.state.isStreaming = false;
    this.state.cancelRequested = false;
    if (this.state.thinkingIndicatorTimeout) {
      clearTimeout(this.state.thinkingIndicatorTimeout);
      this.state.thinkingIndicatorTimeout = null;
    }
  }
  /** Clears all maps for a new conversation. */
  clearMaps() {
    this.state.toolCallElements.clear();
    this.state.activeSubagents.clear();
    this.state.asyncSubagentStates.clear();
    this.state.writeEditStates.clear();
    this.state.pendingTools.clear();
  }
  /** Resets all state for a new conversation. */
  resetForNewConversation() {
    this.clearMessages();
    this.resetStreamingState();
    this.clearMaps();
    this.state.queuedMessage = null;
    this.usage = null;
    this.currentTodos = null;
    this.autoScrollEnabled = true;
  }
  /** Gets messages for persistence. */
  getPersistedMessages() {
    return this.state.messages;
  }
};

// src/features/chat/ui/FileContext.ts
var import_obsidian16 = require("obsidian");

// src/shared/mention/MentionDropdownController.ts
var import_obsidian14 = require("obsidian");

// src/utils/externalContext.ts
var fs6 = __toESM(require("fs"));
function normalizePathForComparison2(p) {
  return normalizePathForComparison(p);
}
function normalizePathForDisplay(p) {
  if (!p) return "";
  return p.replace(/\\/g, "/").replace(/\/+$/, "");
}
function findConflictingPath(newPath, existingPaths) {
  const normalizedNew = normalizePathForComparison2(newPath);
  for (const existing of existingPaths) {
    const normalizedExisting = normalizePathForComparison2(existing);
    if (normalizedNew.startsWith(normalizedExisting + "/")) {
      return { path: existing, type: "parent" };
    }
    if (normalizedExisting.startsWith(normalizedNew + "/")) {
      return { path: existing, type: "child" };
    }
  }
  return null;
}
function getFolderName(p) {
  const normalized = normalizePathForDisplay(p);
  const segments = normalized.split("/");
  return segments[segments.length - 1] || normalized;
}
function isValidDirectoryPath(p) {
  try {
    const stats = fs6.statSync(p);
    return stats.isDirectory();
  } catch (e) {
    return false;
  }
}
function filterValidPaths(paths) {
  return paths.filter(isValidDirectoryPath);
}
function isDuplicatePath(newPath, existingPaths) {
  const normalizedNew = normalizePathForComparison2(newPath);
  return existingPaths.some((existing) => normalizePathForComparison2(existing) === normalizedNew);
}

// src/utils/externalContextScanner.ts
var fs7 = __toESM(require("fs"));
var path6 = __toESM(require("path"));
var CACHE_TTL_MS = 3e4;
var MAX_FILES_PER_PATH = 1e3;
var MAX_DEPTH = 10;
var SKIP_DIRECTORIES = /* @__PURE__ */ new Set([
  "node_modules",
  "__pycache__",
  "venv",
  ".venv",
  ".git",
  ".svn",
  ".hg",
  "dist",
  "build",
  "out",
  ".next",
  ".nuxt",
  "target",
  "vendor",
  "Pods"
]);
var ExternalContextScanner = class {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
  }
  /**
   * Scans all external context paths and returns matching files.
   * Uses cached results when available.
   */
  scanPaths(externalContextPaths) {
    const allFiles = [];
    const now = Date.now();
    for (const contextPath of externalContextPaths) {
      const expandedPath = normalizePathForFilesystem(contextPath);
      const cached2 = this.cache.get(expandedPath);
      if (cached2 && now - cached2.timestamp < CACHE_TTL_MS) {
        allFiles.push(...cached2.files);
        continue;
      }
      const files = this.scanDirectory(expandedPath, expandedPath, 0);
      this.cache.set(expandedPath, { files, timestamp: now });
      allFiles.push(...files);
    }
    return allFiles;
  }
  /**
   * Recursively scans a directory for files.
   */
  scanDirectory(dir, contextRoot, depth) {
    if (depth > MAX_DEPTH) return [];
    const files = [];
    try {
      if (!fs7.existsSync(dir)) return [];
      const stat = fs7.statSync(dir);
      if (!stat.isDirectory()) return [];
      const entries = fs7.readdirSync(dir, { withFileTypes: true });
      for (const entry of entries) {
        if (entry.name.startsWith(".")) continue;
        if (SKIP_DIRECTORIES.has(entry.name)) continue;
        if (entry.isSymbolicLink()) continue;
        const fullPath = path6.join(dir, entry.name);
        if (entry.isDirectory()) {
          const subFiles = this.scanDirectory(fullPath, contextRoot, depth + 1);
          files.push(...subFiles);
        } else if (entry.isFile()) {
          try {
            const fileStat = fs7.statSync(fullPath);
            files.push({
              path: fullPath,
              name: entry.name,
              relativePath: path6.relative(contextRoot, fullPath),
              contextRoot,
              mtime: fileStat.mtimeMs
            });
          } catch (e) {
          }
        }
        if (files.length >= MAX_FILES_PER_PATH) break;
      }
    } catch (e) {
    }
    return files;
  }
  /** Clears all cached results. */
  invalidateCache() {
    this.cache.clear();
  }
  /** Clears cached results for a specific external context path. */
  invalidatePath(contextPath) {
    const expandedPath = normalizePathForFilesystem(contextPath);
    this.cache.delete(expandedPath);
  }
};
var externalContextScanner = new ExternalContextScanner();

// src/shared/components/SelectableDropdown.ts
var SelectableDropdown = class {
  constructor(containerEl, options) {
    this.dropdownEl = null;
    this.items = [];
    this.itemEls = [];
    this.selectedIndex = 0;
    this.containerEl = containerEl;
    this.options = options;
  }
  isVisible() {
    var _a, _b;
    return (_b = (_a = this.dropdownEl) == null ? void 0 : _a.hasClass("visible")) != null ? _b : false;
  }
  getElement() {
    return this.dropdownEl;
  }
  getSelectedIndex() {
    return this.selectedIndex;
  }
  getSelectedItem() {
    var _a;
    return (_a = this.items[this.selectedIndex]) != null ? _a : null;
  }
  getItems() {
    return this.items;
  }
  hide() {
    if (this.dropdownEl) {
      this.dropdownEl.removeClass("visible");
    }
  }
  destroy() {
    if (this.dropdownEl) {
      this.dropdownEl.remove();
      this.dropdownEl = null;
    }
  }
  render(options) {
    var _a;
    this.items = options.items;
    this.selectedIndex = options.selectedIndex;
    if (!this.dropdownEl) {
      this.dropdownEl = this.createDropdownElement();
    }
    this.dropdownEl.empty();
    this.itemEls = [];
    if (options.items.length === 0) {
      const emptyEl = this.dropdownEl.createDiv({ cls: this.options.emptyClassName });
      emptyEl.setText(options.emptyText);
    } else {
      for (let i = 0; i < options.items.length; i++) {
        const item = options.items[i];
        const itemEl = this.dropdownEl.createDiv({ cls: this.options.itemClassName });
        const extraClass = (_a = options.getItemClass) == null ? void 0 : _a.call(options, item);
        if (Array.isArray(extraClass)) {
          extraClass.forEach((cls) => itemEl.addClass(cls));
        } else if (extraClass) {
          itemEl.addClass(extraClass);
        }
        if (i === this.selectedIndex) {
          itemEl.addClass("selected");
        }
        options.renderItem(item, itemEl);
        itemEl.addEventListener("click", () => {
          var _a2;
          this.selectedIndex = i;
          this.updateSelection();
          (_a2 = options.onItemClick) == null ? void 0 : _a2.call(options, item, i);
        });
        itemEl.addEventListener("mouseenter", () => {
          var _a2;
          this.selectedIndex = i;
          this.updateSelection();
          (_a2 = options.onItemHover) == null ? void 0 : _a2.call(options, item, i);
        });
        this.itemEls.push(itemEl);
      }
    }
    this.dropdownEl.addClass("visible");
  }
  updateSelection() {
    this.itemEls.forEach((itemEl, index) => {
      if (index === this.selectedIndex) {
        itemEl.addClass("selected");
        itemEl.scrollIntoView({ block: "nearest" });
      } else {
        itemEl.removeClass("selected");
      }
    });
  }
  moveSelection(delta) {
    const maxIndex = this.items.length - 1;
    this.selectedIndex = Math.max(0, Math.min(maxIndex, this.selectedIndex + delta));
    this.updateSelection();
  }
  createDropdownElement() {
    const className = this.options.fixed && this.options.fixedClassName ? `${this.options.listClassName} ${this.options.fixedClassName}` : this.options.listClassName;
    return this.containerEl.createDiv({ cls: className });
  }
};

// src/shared/mention/types.ts
function createExternalContextEntry(contextRoot, folderName, displayName) {
  return {
    contextRoot,
    folderName,
    displayName,
    displayNameLower: displayName.toLowerCase()
  };
}

// src/shared/mention/MentionDropdownController.ts
var MentionDropdownController = class {
  constructor(containerEl, inputEl, callbacks, options = {}) {
    this.mentionStartIndex = -1;
    this.selectedMentionIndex = 0;
    this.filteredMentionItems = [];
    this.filteredContextFiles = [];
    this.activeContextFilter = null;
    this.mcpService = null;
    var _a;
    this.containerEl = containerEl;
    this.inputEl = inputEl;
    this.callbacks = callbacks;
    this.fixed = (_a = options.fixed) != null ? _a : false;
    this.dropdown = new SelectableDropdown(this.containerEl, {
      listClassName: "claudian-mention-dropdown",
      itemClassName: "claudian-mention-item",
      emptyClassName: "claudian-mention-empty",
      fixed: this.fixed,
      fixedClassName: "claudian-mention-dropdown-fixed"
    });
  }
  setMcpService(service) {
    this.mcpService = service;
  }
  preScanExternalContexts() {
    const externalContexts = this.callbacks.getExternalContexts() || [];
    if (externalContexts.length === 0) return;
    setTimeout(() => {
      try {
        externalContextScanner.scanPaths(externalContexts);
      } catch (e) {
      }
    }, 0);
  }
  isVisible() {
    return this.dropdown.isVisible();
  }
  hide() {
    this.dropdown.hide();
    this.mentionStartIndex = -1;
  }
  containsElement(el) {
    var _a, _b;
    return (_b = (_a = this.dropdown.getElement()) == null ? void 0 : _a.contains(el)) != null ? _b : false;
  }
  destroy() {
    this.dropdown.destroy();
  }
  updateMcpMentionsFromText(text) {
    var _a, _b;
    if (!this.mcpService) return;
    const validNames = new Set(
      this.mcpService.getContextSavingServers().map((s) => s.name)
    );
    const newMentions = extractMcpMentions(text, validNames);
    const changed = this.callbacks.setMentionedMcpServers(newMentions);
    if (changed) {
      (_b = (_a = this.callbacks).onMcpMentionChange) == null ? void 0 : _b.call(_a, newMentions);
    }
  }
  handleInputChange() {
    const text = this.inputEl.value;
    this.updateMcpMentionsFromText(text);
    const cursorPos = this.inputEl.selectionStart || 0;
    const textBeforeCursor = text.substring(0, cursorPos);
    const lastAtIndex = textBeforeCursor.lastIndexOf("@");
    if (lastAtIndex === -1) {
      this.hide();
      return;
    }
    const charBeforeAt = lastAtIndex > 0 ? textBeforeCursor[lastAtIndex - 1] : " ";
    if (!/\s/.test(charBeforeAt) && lastAtIndex !== 0) {
      this.hide();
      return;
    }
    const searchText = textBeforeCursor.substring(lastAtIndex + 1);
    if (/\s/.test(searchText)) {
      this.hide();
      return;
    }
    this.mentionStartIndex = lastAtIndex;
    this.showMentionDropdown(searchText);
  }
  handleKeydown(e) {
    if (!this.dropdown.isVisible()) return false;
    if (e.key === "ArrowDown") {
      e.preventDefault();
      this.dropdown.moveSelection(1);
      this.selectedMentionIndex = this.dropdown.getSelectedIndex();
      return true;
    }
    if (e.key === "ArrowUp") {
      e.preventDefault();
      this.dropdown.moveSelection(-1);
      this.selectedMentionIndex = this.dropdown.getSelectedIndex();
      return true;
    }
    if ((e.key === "Enter" || e.key === "Tab") && !e.isComposing) {
      e.preventDefault();
      this.selectMentionItem();
      return true;
    }
    if (e.key === "Escape" && !e.isComposing) {
      e.preventDefault();
      this.hide();
      return true;
    }
    return false;
  }
  buildExternalContextEntries(externalContexts) {
    var _a;
    const counts = /* @__PURE__ */ new Map();
    const normalizedPaths = /* @__PURE__ */ new Map();
    for (const contextPath of externalContexts) {
      const normalized = normalizePathForComparison2(contextPath);
      normalizedPaths.set(contextPath, normalized);
      const folderName = getFolderName(normalized);
      counts.set(folderName, ((_a = counts.get(folderName)) != null ? _a : 0) + 1);
    }
    return externalContexts.map((contextRoot) => {
      var _a2, _b;
      const normalized = (_a2 = normalizedPaths.get(contextRoot)) != null ? _a2 : normalizePathForComparison2(contextRoot);
      const folderName = getFolderName(contextRoot);
      const needsDisambiguation = ((_b = counts.get(folderName)) != null ? _b : 0) > 1;
      const displayName = this.getContextDisplayName(normalized, folderName, needsDisambiguation);
      return createExternalContextEntry(contextRoot, folderName, displayName);
    });
  }
  getContextDisplayName(normalizedPath, folderName, needsDisambiguation) {
    if (!needsDisambiguation) return folderName;
    const segments = normalizedPath.split("/").filter(Boolean);
    if (segments.length < 2) return folderName;
    const parent = segments[segments.length - 2];
    if (!parent) return folderName;
    return `${parent}/${folderName}`;
  }
  showMentionDropdown(searchText) {
    const searchLower = searchText.toLowerCase();
    this.filteredMentionItems = [];
    this.filteredContextFiles = [];
    const externalContexts = this.callbacks.getExternalContexts() || [];
    const contextEntries = this.buildExternalContextEntries(externalContexts);
    const isFilterSearch = searchText.includes("/");
    let fileSearchText = searchLower;
    if (isFilterSearch) {
      const matchingContext = contextEntries.filter((entry) => searchLower.startsWith(`${entry.displayNameLower}/`)).sort((a, b) => b.displayNameLower.length - a.displayNameLower.length)[0];
      if (matchingContext) {
        const prefixLength = matchingContext.displayName.length + 1;
        fileSearchText = searchText.substring(prefixLength).toLowerCase();
        this.activeContextFilter = {
          folderName: matchingContext.displayName,
          contextRoot: matchingContext.contextRoot
        };
      } else {
        this.activeContextFilter = null;
      }
    }
    if (this.activeContextFilter && isFilterSearch) {
      const contextFiles = externalContextScanner.scanPaths([this.activeContextFilter.contextRoot]);
      this.filteredContextFiles = contextFiles.filter((file) => {
        const relativePath = file.relativePath.replace(/\\/g, "/");
        const pathLower = relativePath.toLowerCase();
        const nameLower = file.name.toLowerCase();
        return pathLower.includes(fileSearchText) || nameLower.includes(fileSearchText);
      }).sort((a, b) => {
        const aNameMatch = a.name.toLowerCase().startsWith(fileSearchText);
        const bNameMatch = b.name.toLowerCase().startsWith(fileSearchText);
        if (aNameMatch && !bNameMatch) return -1;
        if (!aNameMatch && bNameMatch) return 1;
        return b.mtime - a.mtime;
      }).slice(0, 10);
      for (const file of this.filteredContextFiles) {
        const relativePath = file.relativePath.replace(/\\/g, "/");
        this.filteredMentionItems.push({
          type: "context-file",
          name: relativePath,
          absolutePath: file.path,
          contextRoot: file.contextRoot,
          folderName: this.activeContextFilter.folderName
        });
      }
      this.selectedMentionIndex = 0;
      this.renderMentionDropdown();
      return;
    }
    this.activeContextFilter = null;
    if (this.mcpService) {
      const mcpServers = this.mcpService.getContextSavingServers();
      for (const server of mcpServers) {
        if (server.name.toLowerCase().includes(searchLower)) {
          this.filteredMentionItems.push({
            type: "mcp-server",
            name: server.name
          });
        }
      }
    }
    if (contextEntries.length > 0) {
      const matchingFolders = /* @__PURE__ */ new Set();
      for (const entry of contextEntries) {
        if (entry.displayNameLower.includes(searchLower) && !matchingFolders.has(entry.displayName)) {
          matchingFolders.add(entry.displayName);
          this.filteredMentionItems.push({
            type: "context-folder",
            name: entry.displayName,
            contextRoot: entry.contextRoot,
            folderName: entry.displayName
          });
        }
      }
    }
    const firstVaultFileIndex = this.filteredMentionItems.length;
    const remainingSlots = 10 - this.filteredMentionItems.length;
    let vaultFiles = [];
    if (remainingSlots > 0) {
      const allFiles = this.callbacks.getCachedMarkdownFiles();
      vaultFiles = allFiles.filter((file) => {
        const pathLower = file.path.toLowerCase();
        const nameLower = file.name.toLowerCase();
        return pathLower.includes(searchLower) || nameLower.includes(searchLower);
      }).sort((a, b) => {
        const aNameMatch = a.name.toLowerCase().startsWith(searchLower);
        const bNameMatch = b.name.toLowerCase().startsWith(searchLower);
        if (aNameMatch && !bNameMatch) return -1;
        if (!aNameMatch && bNameMatch) return 1;
        return b.stat.mtime - a.stat.mtime;
      }).slice(0, remainingSlots);
      for (const file of vaultFiles) {
        this.filteredMentionItems.push({
          type: "file",
          name: file.name,
          path: file.path,
          file
        });
      }
    }
    if (vaultFiles.length > 0) {
      this.selectedMentionIndex = firstVaultFileIndex;
    } else {
      this.selectedMentionIndex = 0;
    }
    this.renderMentionDropdown();
  }
  renderMentionDropdown() {
    this.dropdown.render({
      items: this.filteredMentionItems,
      selectedIndex: this.selectedMentionIndex,
      emptyText: "No matches",
      getItemClass: (item) => {
        if (item.type === "mcp-server") return "mcp-server";
        if (item.type === "context-file") return "context-file";
        if (item.type === "context-folder") return "context-folder";
        return void 0;
      },
      renderItem: (item, itemEl) => {
        const iconEl = itemEl.createSpan({ cls: "claudian-mention-icon" });
        if (item.type === "mcp-server") {
          iconEl.innerHTML = MCP_ICON_SVG;
        } else if (item.type === "context-file") {
          (0, import_obsidian14.setIcon)(iconEl, "folder-open");
        } else if (item.type === "context-folder") {
          (0, import_obsidian14.setIcon)(iconEl, "folder");
        } else {
          (0, import_obsidian14.setIcon)(iconEl, "file-text");
        }
        const textEl = itemEl.createSpan({ cls: "claudian-mention-text" });
        if (item.type === "mcp-server") {
          const nameEl = textEl.createSpan({ cls: "claudian-mention-name" });
          nameEl.setText(`@${item.name}`);
        } else if (item.type === "context-folder") {
          const nameEl = textEl.createSpan({
            cls: "claudian-mention-name claudian-mention-name-folder"
          });
          nameEl.setText(`@${item.name}/`);
        } else if (item.type === "context-file") {
          const nameEl = textEl.createSpan({
            cls: "claudian-mention-name claudian-mention-name-context"
          });
          nameEl.setText(item.name);
        } else {
          const pathEl = textEl.createSpan({ cls: "claudian-mention-path" });
          pathEl.setText(item.path || item.name);
        }
      },
      onItemClick: (_item, index) => {
        this.selectedMentionIndex = index;
        this.selectMentionItem();
      },
      onItemHover: (_item, index) => {
        this.selectedMentionIndex = index;
      }
    });
    if (this.fixed) {
      this.positionFixed();
    }
  }
  positionFixed() {
    const dropdownEl = this.dropdown.getElement();
    if (!dropdownEl) return;
    const inputRect = this.inputEl.getBoundingClientRect();
    dropdownEl.style.position = "fixed";
    dropdownEl.style.bottom = `${window.innerHeight - inputRect.top + 4}px`;
    dropdownEl.style.left = `${inputRect.left}px`;
    dropdownEl.style.right = "auto";
    dropdownEl.style.width = `${Math.max(inputRect.width, 280)}px`;
    dropdownEl.style.zIndex = "10001";
  }
  selectMentionItem() {
    var _a, _b, _c;
    if (this.filteredMentionItems.length === 0) return;
    const selectedIndex = this.dropdown.getSelectedIndex();
    this.selectedMentionIndex = selectedIndex;
    const selectedItem = this.filteredMentionItems[selectedIndex];
    if (!selectedItem) return;
    const text = this.inputEl.value;
    const beforeAt = text.substring(0, this.mentionStartIndex);
    const cursorPos = this.inputEl.selectionStart || 0;
    const afterCursor = text.substring(cursorPos);
    if (selectedItem.type === "mcp-server") {
      const replacement = `@${selectedItem.name} `;
      this.inputEl.value = beforeAt + replacement + afterCursor;
      this.inputEl.selectionStart = this.inputEl.selectionEnd = beforeAt.length + replacement.length;
      this.callbacks.addMentionedMcpServer(selectedItem.name);
      (_b = (_a = this.callbacks).onMcpMentionChange) == null ? void 0 : _b.call(_a, this.callbacks.getMentionedMcpServers());
    } else if (selectedItem.type === "context-folder") {
      const replacement = `@${selectedItem.name}/`;
      this.inputEl.value = beforeAt + replacement + afterCursor;
      this.inputEl.selectionStart = this.inputEl.selectionEnd = beforeAt.length + replacement.length;
      this.inputEl.focus();
      this.handleInputChange();
      return;
    } else if (selectedItem.type === "context-file") {
      const displayName = selectedItem.folderName ? `@${selectedItem.folderName}/${selectedItem.name}` : `@${selectedItem.name}`;
      if (selectedItem.absolutePath) {
        if (this.callbacks.onAttachContextFile) {
          this.callbacks.onAttachContextFile(displayName, selectedItem.absolutePath);
        } else {
          this.callbacks.onAttachFile(selectedItem.absolutePath);
        }
      }
      const replacement = `${displayName} `;
      this.inputEl.value = beforeAt + replacement + afterCursor;
      this.inputEl.selectionStart = this.inputEl.selectionEnd = beforeAt.length + replacement.length;
    } else {
      const file = selectedItem.file;
      const rawPath = (_c = file == null ? void 0 : file.path) != null ? _c : selectedItem.path;
      const normalizedPath = this.callbacks.normalizePathForVault(rawPath);
      if (normalizedPath) {
        this.callbacks.onAttachFile(normalizedPath);
      }
      const replacement = `@${normalizedPath != null ? normalizedPath : selectedItem.name} `;
      this.inputEl.value = beforeAt + replacement + afterCursor;
      this.inputEl.selectionStart = this.inputEl.selectionEnd = beforeAt.length + replacement.length;
    }
    this.hide();
    this.inputEl.focus();
  }
};

// src/features/chat/ui/file-context/state/FileContextState.ts
function escapeRegExp2(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
var FileContextState = class {
  constructor() {
    this.attachedFiles = /* @__PURE__ */ new Set();
    this.sessionStarted = false;
    this.mentionedMcpServers = /* @__PURE__ */ new Set();
    this.currentNoteSent = false;
    /** Maps display name to absolute path for external context files only. */
    this.contextFileMap = /* @__PURE__ */ new Map();
  }
  getAttachedFiles() {
    return new Set(this.attachedFiles);
  }
  hasSentCurrentNote() {
    return this.currentNoteSent;
  }
  markCurrentNoteSent() {
    this.currentNoteSent = true;
  }
  isSessionStarted() {
    return this.sessionStarted;
  }
  startSession() {
    this.sessionStarted = true;
  }
  resetForNewConversation() {
    this.sessionStarted = false;
    this.currentNoteSent = false;
    this.attachedFiles.clear();
    this.contextFileMap.clear();
    this.clearMcpMentions();
  }
  resetForLoadedConversation(hasMessages) {
    this.currentNoteSent = hasMessages;
    this.attachedFiles.clear();
    this.contextFileMap.clear();
    this.sessionStarted = hasMessages;
    this.clearMcpMentions();
  }
  setAttachedFiles(files) {
    this.attachedFiles.clear();
    for (const file of files) {
      this.attachedFiles.add(file);
    }
  }
  attachFile(path9) {
    this.attachedFiles.add(path9);
  }
  /** Attach an external context file with display name to absolute path mapping. */
  attachContextFile(displayName, absolutePath) {
    this.attachedFiles.add(absolutePath);
    this.contextFileMap.set(displayName, absolutePath);
  }
  detachFile(path9) {
    this.attachedFiles.delete(path9);
  }
  clearAttachments() {
    this.attachedFiles.clear();
    this.contextFileMap.clear();
  }
  /** Transform text by replacing external context file display names with absolute paths. */
  transformContextMentions(text) {
    let result = text;
    for (const [displayName, absolutePath] of this.contextFileMap) {
      result = result.replace(new RegExp(escapeRegExp2(displayName), "g"), absolutePath);
    }
    return result;
  }
  getMentionedMcpServers() {
    return new Set(this.mentionedMcpServers);
  }
  clearMcpMentions() {
    this.mentionedMcpServers.clear();
  }
  setMentionedMcpServers(mentions) {
    const changed = mentions.size !== this.mentionedMcpServers.size || [...mentions].some((name) => !this.mentionedMcpServers.has(name));
    if (changed) {
      this.mentionedMcpServers = new Set(mentions);
    }
    return changed;
  }
  addMentionedMcpServer(name) {
    this.mentionedMcpServers.add(name);
  }
};

// src/features/chat/ui/file-context/state/MarkdownFileCache.ts
var MarkdownFileCache = class {
  constructor(app) {
    this.cachedFiles = [];
    this.dirty = true;
    this.app = app;
  }
  markDirty() {
    this.dirty = true;
  }
  getFiles() {
    if (this.dirty || this.cachedFiles.length === 0) {
      this.cachedFiles = this.app.vault.getMarkdownFiles();
      this.dirty = false;
    }
    return [...this.cachedFiles];
  }
};

// src/features/chat/ui/file-context/view/FileChipsView.ts
var import_obsidian15 = require("obsidian");
var FileChipsView = class {
  constructor(containerEl, callbacks) {
    this.containerEl = containerEl;
    this.callbacks = callbacks;
    const firstChild = this.containerEl.firstChild;
    this.fileIndicatorEl = this.containerEl.createDiv({ cls: "claudian-file-indicator" });
    if (firstChild) {
      this.containerEl.insertBefore(this.fileIndicatorEl, firstChild);
    }
  }
  destroy() {
    this.fileIndicatorEl.remove();
  }
  /** Renders chip for the current/focus note only. */
  renderCurrentNote(filePath) {
    this.fileIndicatorEl.empty();
    if (!filePath) {
      this.fileIndicatorEl.style.display = "none";
      return;
    }
    this.fileIndicatorEl.style.display = "flex";
    this.renderFileChip(filePath, () => {
      this.callbacks.onRemoveAttachment(filePath);
    });
  }
  renderFileChip(filePath, onRemove) {
    const chipEl = this.fileIndicatorEl.createDiv({ cls: "claudian-file-chip" });
    const iconEl = chipEl.createSpan({ cls: "claudian-file-chip-icon" });
    (0, import_obsidian15.setIcon)(iconEl, "file-text");
    const normalizedPath = filePath.replace(/\\/g, "/");
    const filename = normalizedPath.split("/").pop() || filePath;
    const nameEl = chipEl.createSpan({ cls: "claudian-file-chip-name" });
    nameEl.setText(filename);
    nameEl.setAttribute("title", filePath);
    const removeEl = chipEl.createSpan({ cls: "claudian-file-chip-remove" });
    removeEl.setText("\xD7");
    removeEl.setAttribute("aria-label", "Remove");
    chipEl.addEventListener("click", (e) => {
      if (!e.target.closest(".claudian-file-chip-remove")) {
        this.callbacks.onOpenFile(filePath);
      }
    });
    removeEl.addEventListener("click", () => {
      onRemove();
    });
  }
};

// src/features/chat/ui/FileContext.ts
var FileContextManager = class {
  constructor(app, chipsContainerEl, inputEl, callbacks, dropdownContainerEl) {
    this.deleteEventRef = null;
    this.renameEventRef = null;
    // Current note (shown as chip)
    this.currentNotePath = null;
    // MCP server support
    this.mcpService = null;
    this.onMcpMentionChange = null;
    this.app = app;
    this.chipsContainerEl = chipsContainerEl;
    this.dropdownContainerEl = dropdownContainerEl != null ? dropdownContainerEl : chipsContainerEl;
    this.inputEl = inputEl;
    this.callbacks = callbacks;
    this.state = new FileContextState();
    this.fileCache = new MarkdownFileCache(this.app);
    this.chipsView = new FileChipsView(this.chipsContainerEl, {
      onRemoveAttachment: (filePath) => {
        if (filePath === this.currentNotePath) {
          this.currentNotePath = null;
          this.state.detachFile(filePath);
          this.refreshCurrentNoteChip();
        }
      },
      onOpenFile: async (filePath) => {
        const file = this.app.vault.getAbstractFileByPath(filePath);
        if (!(file instanceof import_obsidian16.TFile)) {
          new import_obsidian16.Notice(`Could not open file: ${filePath}`);
          return;
        }
        try {
          await this.app.workspace.getLeaf().openFile(file);
        } catch (error2) {
          new import_obsidian16.Notice(`Failed to open file: ${error2 instanceof Error ? error2.message : String(error2)}`);
        }
      }
    });
    this.mentionDropdown = new MentionDropdownController(
      this.dropdownContainerEl,
      this.inputEl,
      {
        onAttachFile: (filePath) => this.state.attachFile(filePath),
        onAttachContextFile: (displayName, absolutePath) => this.state.attachContextFile(displayName, absolutePath),
        onMcpMentionChange: (servers) => {
          var _a;
          return (_a = this.onMcpMentionChange) == null ? void 0 : _a.call(this, servers);
        },
        getMentionedMcpServers: () => this.state.getMentionedMcpServers(),
        setMentionedMcpServers: (mentions) => this.state.setMentionedMcpServers(mentions),
        addMentionedMcpServer: (name) => this.state.addMentionedMcpServer(name),
        getExternalContexts: () => {
          var _a, _b;
          return ((_b = (_a = this.callbacks).getExternalContexts) == null ? void 0 : _b.call(_a)) || [];
        },
        getCachedMarkdownFiles: () => this.fileCache.getFiles(),
        normalizePathForVault: (rawPath) => this.normalizePathForVault(rawPath)
      }
    );
    this.deleteEventRef = this.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian16.TFile) this.handleFileDeleted(file.path);
    });
    this.renameEventRef = this.app.vault.on("rename", (file, oldPath) => {
      if (file instanceof import_obsidian16.TFile) this.handleFileRenamed(oldPath, file.path);
    });
  }
  /** Returns the current note path (shown as chip). */
  getCurrentNotePath() {
    return this.currentNotePath;
  }
  /** Checks whether current note should be sent for this session. */
  shouldSendCurrentNote(notePath) {
    const resolvedPath = notePath != null ? notePath : this.currentNotePath;
    return !!resolvedPath && !this.state.hasSentCurrentNote();
  }
  /** Marks current note as sent (call after sending a message). */
  markCurrentNoteSent() {
    this.state.markCurrentNoteSent();
  }
  isSessionStarted() {
    return this.state.isSessionStarted();
  }
  startSession() {
    this.state.startSession();
  }
  /** Resets state for a new conversation. */
  resetForNewConversation() {
    this.currentNotePath = null;
    this.state.resetForNewConversation();
    this.refreshCurrentNoteChip();
  }
  /** Resets state for loading an existing conversation. */
  resetForLoadedConversation(hasMessages) {
    this.currentNotePath = null;
    this.state.resetForLoadedConversation(hasMessages);
    this.refreshCurrentNoteChip();
  }
  /** Sets current note (for restoring persisted state). */
  setCurrentNote(notePath) {
    this.currentNotePath = notePath;
    if (notePath) {
      this.state.attachFile(notePath);
    }
    this.refreshCurrentNoteChip();
  }
  /** Auto-attaches the currently focused file (for new sessions). */
  autoAttachActiveFile() {
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile && !this.hasExcludedTag(activeFile)) {
      const normalizedPath = this.normalizePathForVault(activeFile.path);
      if (normalizedPath) {
        this.currentNotePath = normalizedPath;
        this.state.attachFile(normalizedPath);
        this.refreshCurrentNoteChip();
      }
    }
  }
  /** Handles file open event. */
  handleFileOpen(file) {
    const normalizedPath = this.normalizePathForVault(file.path);
    if (!normalizedPath) return;
    if (!this.state.isSessionStarted()) {
      this.state.clearAttachments();
      if (!this.hasExcludedTag(file)) {
        this.currentNotePath = normalizedPath;
        this.state.attachFile(normalizedPath);
      } else {
        this.currentNotePath = null;
      }
      this.refreshCurrentNoteChip();
    }
  }
  markFilesCacheDirty() {
    this.fileCache.markDirty();
  }
  /** Handles input changes to detect @ mentions. */
  handleInputChange() {
    this.mentionDropdown.handleInputChange();
  }
  /** Handles keyboard navigation in mention dropdown. Returns true if handled. */
  handleMentionKeydown(e) {
    return this.mentionDropdown.handleKeydown(e);
  }
  isMentionDropdownVisible() {
    return this.mentionDropdown.isVisible();
  }
  hideMentionDropdown() {
    this.mentionDropdown.hide();
  }
  containsElement(el) {
    return this.mentionDropdown.containsElement(el);
  }
  /** Transform context file mentions (e.g., @folder/file.ts) to absolute paths. */
  transformContextMentions(text) {
    return this.state.transformContextMentions(text);
  }
  /** Cleans up event listeners (call on view close). */
  destroy() {
    if (this.deleteEventRef) this.app.vault.offref(this.deleteEventRef);
    if (this.renameEventRef) this.app.vault.offref(this.renameEventRef);
    this.mentionDropdown.destroy();
    this.chipsView.destroy();
  }
  /** Normalizes a file path to be vault-relative with forward slashes. */
  normalizePathForVault(rawPath) {
    const vaultPath = getVaultPath(this.app);
    return normalizePathForVault(rawPath, vaultPath);
  }
  refreshCurrentNoteChip() {
    var _a, _b;
    this.chipsView.renderCurrentNote(this.currentNotePath);
    (_b = (_a = this.callbacks).onChipsChanged) == null ? void 0 : _b.call(_a);
  }
  handleFileRenamed(oldPath, newPath) {
    const normalizedOld = this.normalizePathForVault(oldPath);
    const normalizedNew = this.normalizePathForVault(newPath);
    if (!normalizedOld) return;
    let needsUpdate = false;
    if (this.currentNotePath === normalizedOld) {
      this.currentNotePath = normalizedNew;
      needsUpdate = true;
    }
    if (this.state.getAttachedFiles().has(normalizedOld)) {
      this.state.detachFile(normalizedOld);
      if (normalizedNew) {
        this.state.attachFile(normalizedNew);
      }
      needsUpdate = true;
    }
    if (needsUpdate) {
      this.refreshCurrentNoteChip();
    }
  }
  handleFileDeleted(deletedPath) {
    const normalized = this.normalizePathForVault(deletedPath);
    if (!normalized) return;
    let needsUpdate = false;
    if (this.currentNotePath === normalized) {
      this.currentNotePath = null;
      needsUpdate = true;
    }
    if (this.state.getAttachedFiles().has(normalized)) {
      this.state.detachFile(normalized);
      needsUpdate = true;
    }
    if (needsUpdate) {
      this.refreshCurrentNoteChip();
    }
  }
  // ========================================
  // MCP Server Support
  // ========================================
  /** Set the MCP service for @-mention autocomplete. */
  setMcpService(service) {
    this.mcpService = service;
    this.mentionDropdown.setMcpService(service);
  }
  /** Set callback for when MCP mentions change (for McpServerSelector integration). */
  setOnMcpMentionChange(callback) {
    this.onMcpMentionChange = callback;
  }
  /**
   * Pre-scans external context paths in the background to warm the cache.
   * Should be called when external context paths are added/changed.
   */
  preScanExternalContexts() {
    this.mentionDropdown.preScanExternalContexts();
  }
  /** Get currently @-mentioned MCP servers. */
  getMentionedMcpServers() {
    return this.state.getMentionedMcpServers();
  }
  /** Clear MCP mentions (call on new conversation). */
  clearMcpMentions() {
    this.state.clearMcpMentions();
  }
  /** Update MCP mentions from input text. */
  updateMcpMentionsFromText(text) {
    this.mentionDropdown.updateMcpMentionsFromText(text);
  }
  hasExcludedTag(file) {
    var _a;
    const excludedTags = this.callbacks.getExcludedTags();
    if (excludedTags.length === 0) return false;
    const cache = this.app.metadataCache.getFileCache(file);
    if (!cache) return false;
    const fileTags = [];
    if ((_a = cache.frontmatter) == null ? void 0 : _a.tags) {
      const fmTags = cache.frontmatter.tags;
      if (Array.isArray(fmTags)) {
        fileTags.push(...fmTags.map((t2) => t2.replace(/^#/, "")));
      } else if (typeof fmTags === "string") {
        fileTags.push(fmTags.replace(/^#/, ""));
      }
    }
    if (cache.tags) {
      fileTags.push(...cache.tags.map((t2) => t2.tag.replace(/^#/, "")));
    }
    return fileTags.some((tag) => excludedTags.includes(tag));
  }
};

// src/features/chat/ui/ImageContext.ts
var import_obsidian17 = require("obsidian");
var path7 = __toESM(require("path"));
var MAX_IMAGE_SIZE = 5 * 1024 * 1024;
var IMAGE_EXTENSIONS2 = {
  ".jpg": "image/jpeg",
  ".jpeg": "image/jpeg",
  ".png": "image/png",
  ".gif": "image/gif",
  ".webp": "image/webp"
};
var ImageContextManager = class {
  constructor(containerEl, inputEl, callbacks, previewContainerEl) {
    this.dropOverlay = null;
    this.attachedImages = /* @__PURE__ */ new Map();
    this.containerEl = containerEl;
    this.previewContainerEl = previewContainerEl != null ? previewContainerEl : containerEl;
    this.inputEl = inputEl;
    this.callbacks = callbacks;
    const fileIndicator = this.previewContainerEl.querySelector(".claudian-file-indicator");
    this.imagePreviewEl = this.previewContainerEl.createDiv({ cls: "claudian-image-preview" });
    if (fileIndicator && fileIndicator.parentElement === this.previewContainerEl) {
      this.previewContainerEl.insertBefore(this.imagePreviewEl, fileIndicator);
    }
    this.setupDragAndDrop();
    this.setupPasteHandler();
  }
  getAttachedImages() {
    return Array.from(this.attachedImages.values());
  }
  hasImages() {
    return this.attachedImages.size > 0;
  }
  clearImages() {
    this.attachedImages.clear();
    this.updateImagePreview();
    this.callbacks.onImagesChanged();
  }
  /** Sets images directly (used for queued messages). */
  setImages(images) {
    this.attachedImages.clear();
    for (const image of images) {
      this.attachedImages.set(image.id, image);
    }
    this.updateImagePreview();
    this.callbacks.onImagesChanged();
  }
  setupDragAndDrop() {
    const inputWrapper = this.containerEl.querySelector(".claudian-input-wrapper");
    if (!inputWrapper) return;
    this.dropOverlay = inputWrapper.createDiv({ cls: "claudian-drop-overlay" });
    const dropContent = this.dropOverlay.createDiv({ cls: "claudian-drop-content" });
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("viewBox", "0 0 24 24");
    svg.setAttribute("width", "32");
    svg.setAttribute("height", "32");
    svg.setAttribute("fill", "none");
    svg.setAttribute("stroke", "currentColor");
    svg.setAttribute("stroke-width", "2");
    const pathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");
    pathEl.setAttribute("d", "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4");
    const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
    polyline.setAttribute("points", "17 8 12 3 7 8");
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", "12");
    line.setAttribute("y1", "3");
    line.setAttribute("x2", "12");
    line.setAttribute("y2", "15");
    svg.appendChild(pathEl);
    svg.appendChild(polyline);
    svg.appendChild(line);
    dropContent.appendChild(svg);
    dropContent.createSpan({ text: "Drop image here" });
    const dropZone = inputWrapper;
    dropZone.addEventListener("dragenter", (e) => this.handleDragEnter(e));
    dropZone.addEventListener("dragover", (e) => this.handleDragOver(e));
    dropZone.addEventListener("dragleave", (e) => this.handleDragLeave(e));
    dropZone.addEventListener("drop", (e) => this.handleDrop(e));
  }
  handleDragEnter(e) {
    var _a, _b;
    e.preventDefault();
    e.stopPropagation();
    if ((_a = e.dataTransfer) == null ? void 0 : _a.types.includes("Files")) {
      (_b = this.dropOverlay) == null ? void 0 : _b.addClass("visible");
    }
  }
  handleDragOver(e) {
    e.preventDefault();
    e.stopPropagation();
  }
  handleDragLeave(e) {
    var _a, _b;
    e.preventDefault();
    e.stopPropagation();
    const inputWrapper = this.containerEl.querySelector(".claudian-input-wrapper");
    if (!inputWrapper) {
      (_a = this.dropOverlay) == null ? void 0 : _a.removeClass("visible");
      return;
    }
    const rect = inputWrapper.getBoundingClientRect();
    if (e.clientX <= rect.left || e.clientX >= rect.right || e.clientY <= rect.top || e.clientY >= rect.bottom) {
      (_b = this.dropOverlay) == null ? void 0 : _b.removeClass("visible");
    }
  }
  async handleDrop(e) {
    var _a, _b;
    e.preventDefault();
    e.stopPropagation();
    (_a = this.dropOverlay) == null ? void 0 : _a.removeClass("visible");
    const files = (_b = e.dataTransfer) == null ? void 0 : _b.files;
    if (!files) return;
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      if (this.isImageFile(file)) {
        await this.addImageFromFile(file, "drop");
      }
    }
  }
  setupPasteHandler() {
    this.inputEl.addEventListener("paste", async (e) => {
      var _a;
      const items = (_a = e.clipboardData) == null ? void 0 : _a.items;
      if (!items) return;
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        if (item.type.startsWith("image/")) {
          e.preventDefault();
          const file = item.getAsFile();
          if (file) {
            await this.addImageFromFile(file, "paste");
          }
          return;
        }
      }
    });
  }
  isImageFile(file) {
    return file.type.startsWith("image/") && this.getMediaType(file.name) !== null;
  }
  getMediaType(filename) {
    const ext = path7.extname(filename).toLowerCase();
    return IMAGE_EXTENSIONS2[ext] || null;
  }
  async addImageFromFile(file, source) {
    if (file.size > MAX_IMAGE_SIZE) {
      this.notifyImageError(`Image exceeds ${this.formatSize(MAX_IMAGE_SIZE)} limit.`);
      return false;
    }
    const mediaType = this.getMediaType(file.name) || file.type;
    if (!mediaType) {
      this.notifyImageError("Unsupported image type.");
      return false;
    }
    try {
      const base642 = await this.fileToBase64(file);
      const attachment = {
        id: this.generateId(),
        name: file.name || `image-${Date.now()}.${mediaType.split("/")[1]}`,
        mediaType,
        data: base642,
        size: file.size,
        source
      };
      this.attachedImages.set(attachment.id, attachment);
      this.updateImagePreview();
      this.callbacks.onImagesChanged();
      return true;
    } catch (error2) {
      this.notifyImageError("Failed to attach image.", error2);
      return false;
    }
  }
  async fileToBase64(file) {
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);
    return buffer.toString("base64");
  }
  // ============================================
  // Private: Image Preview
  // ============================================
  updateImagePreview() {
    this.imagePreviewEl.empty();
    if (this.attachedImages.size === 0) {
      this.imagePreviewEl.style.display = "none";
      return;
    }
    this.imagePreviewEl.style.display = "flex";
    for (const [id, image] of this.attachedImages) {
      this.renderImagePreview(id, image);
    }
  }
  renderImagePreview(id, image) {
    const previewEl = this.imagePreviewEl.createDiv({ cls: "claudian-image-chip" });
    const thumbEl = previewEl.createDiv({ cls: "claudian-image-thumb" });
    thumbEl.createEl("img", {
      attr: {
        src: `data:${image.mediaType};base64,${image.data}`,
        alt: image.name
      }
    });
    const infoEl = previewEl.createDiv({ cls: "claudian-image-info" });
    const nameEl = infoEl.createSpan({ cls: "claudian-image-name" });
    nameEl.setText(this.truncateName(image.name, 20));
    nameEl.setAttribute("title", image.name);
    const sizeEl = infoEl.createSpan({ cls: "claudian-image-size" });
    sizeEl.setText(this.formatSize(image.size));
    const removeEl = previewEl.createSpan({ cls: "claudian-image-remove" });
    removeEl.setText("\xD7");
    removeEl.setAttribute("aria-label", "Remove image");
    removeEl.addEventListener("click", (e) => {
      e.stopPropagation();
      this.attachedImages.delete(id);
      this.updateImagePreview();
      this.callbacks.onImagesChanged();
    });
    thumbEl.addEventListener("click", () => {
      this.showFullImage(image);
    });
  }
  showFullImage(image) {
    const overlay = document.body.createDiv({ cls: "claudian-image-modal-overlay" });
    const modal = overlay.createDiv({ cls: "claudian-image-modal" });
    modal.createEl("img", {
      attr: {
        src: `data:${image.mediaType};base64,${image.data}`,
        alt: image.name
      }
    });
    const closeBtn = modal.createDiv({ cls: "claudian-image-modal-close" });
    closeBtn.setText("\xD7");
    const handleEsc = (e) => {
      if (e.key === "Escape") {
        close();
      }
    };
    const close = () => {
      document.removeEventListener("keydown", handleEsc);
      overlay.remove();
    };
    closeBtn.addEventListener("click", close);
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) close();
    });
    document.addEventListener("keydown", handleEsc);
  }
  generateId() {
    return `img-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
  }
  truncateName(name, maxLen) {
    if (name.length <= maxLen) return name;
    const ext = path7.extname(name);
    const base = name.slice(0, name.length - ext.length);
    const truncatedBase = base.slice(0, maxLen - ext.length - 3);
    return `${truncatedBase}...${ext}`;
  }
  formatSize(bytes) {
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
  }
  notifyImageError(message, error2) {
    let userMessage = message;
    if (error2 instanceof Error) {
      if (error2.message.includes("ENOENT") || error2.message.includes("no such file")) {
        userMessage = `${message} (File not found)`;
      } else if (error2.message.includes("EACCES") || error2.message.includes("permission denied")) {
        userMessage = `${message} (Permission denied)`;
      }
    }
    new import_obsidian17.Notice(userMessage);
  }
};

// src/features/chat/ui/InputToolbar.ts
var import_obsidian18 = require("obsidian");
var ModelSelector = class {
  constructor(parentEl, callbacks) {
    this.buttonEl = null;
    this.dropdownEl = null;
    this.callbacks = callbacks;
    this.container = parentEl.createDiv({ cls: "claudian-model-selector" });
    this.render();
  }
  /** Returns available models (custom from env vars, or defaults). */
  getAvailableModels() {
    let models = [];
    if (this.callbacks.getEnvironmentVariables) {
      const envVarsStr = this.callbacks.getEnvironmentVariables();
      const envVars = parseEnvironmentVariables(envVarsStr);
      const customModels = getModelsFromEnvironment(envVars);
      if (customModels.length > 0) {
        models = customModels;
      } else {
        models = [...DEFAULT_CLAUDE_MODELS];
      }
    } else {
      models = [...DEFAULT_CLAUDE_MODELS];
    }
    const settings11 = this.callbacks.getSettings();
    if (settings11.show1MModel) {
      models = models.map(
        (m) => m.value === "sonnet" ? { ...m, label: "Sonnet (1M)" } : m
      );
    }
    return models;
  }
  render() {
    this.container.empty();
    this.buttonEl = this.container.createDiv({ cls: "claudian-model-btn" });
    this.updateDisplay();
    this.dropdownEl = this.container.createDiv({ cls: "claudian-model-dropdown" });
    this.renderOptions();
  }
  updateDisplay() {
    if (!this.buttonEl) return;
    const currentModel = this.callbacks.getSettings().model;
    const models = this.getAvailableModels();
    const modelInfo = models.find((m) => m.value === currentModel);
    const displayModel = modelInfo || models[0];
    this.buttonEl.empty();
    const labelEl = this.buttonEl.createSpan({ cls: "claudian-model-label" });
    labelEl.setText((displayModel == null ? void 0 : displayModel.label) || "Unknown");
  }
  renderOptions() {
    if (!this.dropdownEl) return;
    this.dropdownEl.empty();
    const currentModel = this.callbacks.getSettings().model;
    const models = this.getAvailableModels();
    for (const model of [...models].reverse()) {
      const option = this.dropdownEl.createDiv({ cls: "claudian-model-option" });
      if (model.value === currentModel) {
        option.addClass("selected");
      }
      option.createSpan({ text: model.label });
      if (model.description) {
        option.setAttribute("title", model.description);
      }
      option.addEventListener("click", async (e) => {
        e.stopPropagation();
        await this.callbacks.onModelChange(model.value);
        this.updateDisplay();
        this.renderOptions();
      });
    }
  }
};
var ThinkingBudgetSelector = class {
  constructor(parentEl, callbacks) {
    this.gearsEl = null;
    this.callbacks = callbacks;
    this.container = parentEl.createDiv({ cls: "claudian-thinking-selector" });
    this.render();
  }
  render() {
    this.container.empty();
    const labelEl = this.container.createSpan({ cls: "claudian-thinking-label-text" });
    labelEl.setText("Thinking:");
    this.gearsEl = this.container.createDiv({ cls: "claudian-thinking-gears" });
    this.renderGears();
  }
  renderGears() {
    if (!this.gearsEl) return;
    this.gearsEl.empty();
    const currentBudget = this.callbacks.getSettings().thinkingBudget;
    const currentBudgetInfo = THINKING_BUDGETS.find((b) => b.value === currentBudget);
    const currentEl = this.gearsEl.createDiv({ cls: "claudian-thinking-current" });
    currentEl.setText((currentBudgetInfo == null ? void 0 : currentBudgetInfo.label) || "Off");
    const optionsEl = this.gearsEl.createDiv({ cls: "claudian-thinking-options" });
    for (const budget of [...THINKING_BUDGETS].reverse()) {
      const gearEl = optionsEl.createDiv({ cls: "claudian-thinking-gear" });
      gearEl.setText(budget.label);
      gearEl.setAttribute("title", budget.tokens > 0 ? `${budget.tokens.toLocaleString()} tokens` : "Disabled");
      if (budget.value === currentBudget) {
        gearEl.addClass("selected");
      }
      gearEl.addEventListener("click", async (e) => {
        e.stopPropagation();
        await this.callbacks.onThinkingBudgetChange(budget.value);
        this.updateDisplay();
      });
    }
  }
  updateDisplay() {
    this.renderGears();
  }
};
var PermissionToggle = class {
  constructor(parentEl, callbacks) {
    this.toggleEl = null;
    this.labelEl = null;
    this.callbacks = callbacks;
    this.container = parentEl.createDiv({ cls: "claudian-permission-toggle" });
    this.render();
  }
  render() {
    this.container.empty();
    this.labelEl = this.container.createSpan({ cls: "claudian-permission-label" });
    this.toggleEl = this.container.createDiv({ cls: "claudian-toggle-switch" });
    this.updateDisplay();
    this.toggleEl.addEventListener("click", () => this.toggle());
  }
  updateDisplay() {
    if (!this.toggleEl || !this.labelEl) return;
    const isYolo = this.callbacks.getSettings().permissionMode === "yolo";
    if (isYolo) {
      this.toggleEl.addClass("active");
    } else {
      this.toggleEl.removeClass("active");
    }
    this.labelEl.setText(isYolo ? "YOLO" : "Safe");
  }
  async toggle() {
    const current = this.callbacks.getSettings().permissionMode;
    const newMode = current === "yolo" ? "normal" : "yolo";
    await this.callbacks.onPermissionModeChange(newMode);
    this.updateDisplay();
  }
};
var ExternalContextSelector = class {
  constructor(parentEl, callbacks) {
    this.iconEl = null;
    this.badgeEl = null;
    this.dropdownEl = null;
    /**
     * Current external context paths. May contain:
     * - Persistent paths only (new sessions via clearExternalContexts)
     * - Restored session paths (loaded sessions via setExternalContexts)
     * - Mixed paths during active sessions
     */
    this.externalContextPaths = [];
    /** Paths that persist across all sessions (stored in settings). */
    this.persistentPaths = /* @__PURE__ */ new Set();
    this.onChangeCallback = null;
    this.onPersistenceChangeCallback = null;
    this.callbacks = callbacks;
    this.container = parentEl.createDiv({ cls: "claudian-external-context-selector" });
    this.render();
  }
  /** Set callback for when external context paths change. */
  setOnChange(callback) {
    this.onChangeCallback = callback;
  }
  /** Set callback for when persistent paths change (to save to settings). */
  setOnPersistenceChange(callback) {
    this.onPersistenceChangeCallback = callback;
  }
  /** Get current external context paths. */
  getExternalContexts() {
    return [...this.externalContextPaths];
  }
  /** Get current persistent paths. */
  getPersistentPaths() {
    return [...this.persistentPaths];
  }
  /** Set persistent paths (call on initialization from settings). */
  setPersistentPaths(paths) {
    var _a;
    const validPaths = filterValidPaths(paths);
    const invalidPaths = paths.filter((p) => !validPaths.includes(p));
    this.persistentPaths = new Set(validPaths);
    this.mergePersistentPaths();
    this.updateDisplay();
    this.renderDropdown();
    if (invalidPaths.length > 0) {
      const pathNames = invalidPaths.map((p) => this.shortenPath(p)).join(", ");
      new import_obsidian18.Notice(`Removed ${invalidPaths.length} invalid external context path(s): ${pathNames}`, 5e3);
      (_a = this.onPersistenceChangeCallback) == null ? void 0 : _a.call(this, [...this.persistentPaths]);
    }
  }
  /** Toggle persistence for a path. */
  togglePersistence(path9) {
    var _a;
    if (this.persistentPaths.has(path9)) {
      this.persistentPaths.delete(path9);
    } else {
      if (!isValidDirectoryPath(path9)) {
        new import_obsidian18.Notice(`Cannot persist "${this.shortenPath(path9)}" - directory no longer exists`, 4e3);
        return;
      }
      this.persistentPaths.add(path9);
    }
    (_a = this.onPersistenceChangeCallback) == null ? void 0 : _a.call(this, [...this.persistentPaths]);
    this.renderDropdown();
  }
  /** Merge persistent paths into externalContextPaths without duplicates. */
  mergePersistentPaths() {
    const pathSet = new Set(this.externalContextPaths);
    for (const path9 of this.persistentPaths) {
      pathSet.add(path9);
    }
    this.externalContextPaths = [...pathSet];
  }
  /**
   * Restore exact external context paths from a saved conversation.
   * Does NOT merge with persistent paths - preserves the session's historical state.
   * Use clearExternalContexts() for new sessions to start with current persistent paths.
   */
  setExternalContexts(paths) {
    this.externalContextPaths = [...paths];
    this.updateDisplay();
    this.renderDropdown();
  }
  /**
   * Remove a path from external contexts (and persistent paths if applicable).
   * Exposed for testing the remove button behavior.
   */
  removePath(pathStr) {
    var _a, _b;
    this.externalContextPaths = this.externalContextPaths.filter((p) => p !== pathStr);
    if (this.persistentPaths.has(pathStr)) {
      this.persistentPaths.delete(pathStr);
      (_a = this.onPersistenceChangeCallback) == null ? void 0 : _a.call(this, [...this.persistentPaths]);
    }
    (_b = this.onChangeCallback) == null ? void 0 : _b.call(this, this.externalContextPaths);
    this.updateDisplay();
    this.renderDropdown();
  }
  /**
   * Clear session-only external context paths (call on new conversation).
   * Uses persistent paths from settings if provided, otherwise falls back to local cache.
   * Validates paths before using them (silently filters invalid during session init).
   */
  clearExternalContexts(persistentPathsFromSettings) {
    if (persistentPathsFromSettings) {
      const validPaths = filterValidPaths(persistentPathsFromSettings);
      this.persistentPaths = new Set(validPaths);
    }
    this.externalContextPaths = [...this.persistentPaths];
    this.updateDisplay();
    this.renderDropdown();
  }
  render() {
    this.container.empty();
    const iconWrapper = this.container.createDiv({ cls: "claudian-external-context-icon-wrapper" });
    this.iconEl = iconWrapper.createDiv({ cls: "claudian-external-context-icon" });
    (0, import_obsidian18.setIcon)(this.iconEl, "folder");
    this.badgeEl = iconWrapper.createDiv({ cls: "claudian-external-context-badge" });
    this.updateDisplay();
    iconWrapper.addEventListener("click", (e) => {
      e.stopPropagation();
      this.openFolderPicker();
    });
    this.dropdownEl = this.container.createDiv({ cls: "claudian-external-context-dropdown" });
    this.renderDropdown();
  }
  async openFolderPicker() {
    var _a;
    try {
      const { remote } = require("electron");
      const result = await remote.dialog.showOpenDialog({
        properties: ["openDirectory"],
        title: "Select External Context"
      });
      if (!result.canceled && result.filePaths.length > 0) {
        const selectedPath = result.filePaths[0];
        if (isDuplicatePath(selectedPath, this.externalContextPaths)) {
          new import_obsidian18.Notice("This folder is already added as an external context.", 3e3);
          return;
        }
        const conflict = findConflictingPath(selectedPath, this.externalContextPaths);
        if (conflict) {
          this.showConflictNotice(selectedPath, conflict);
          return;
        }
        this.externalContextPaths = [...this.externalContextPaths, selectedPath];
        (_a = this.onChangeCallback) == null ? void 0 : _a.call(this, this.externalContextPaths);
        this.updateDisplay();
        this.renderDropdown();
      }
    } catch (e) {
      new import_obsidian18.Notice("Unable to open folder picker.", 5e3);
    }
  }
  /** Shows a notice when a conflicting path is detected. */
  showConflictNotice(newPath, conflict) {
    const shortNew = this.shortenPath(newPath);
    const shortExisting = this.shortenPath(conflict.path);
    let message;
    if (conflict.type === "parent") {
      message = `Cannot add "${shortNew}" - it's inside existing path "${shortExisting}"`;
    } else {
      message = `Cannot add "${shortNew}" - it contains existing path "${shortExisting}"`;
    }
    new import_obsidian18.Notice(message, 5e3);
  }
  renderDropdown() {
    if (!this.dropdownEl) return;
    this.dropdownEl.empty();
    const headerEl = this.dropdownEl.createDiv({ cls: "claudian-external-context-header" });
    headerEl.setText("External Contexts");
    const listEl = this.dropdownEl.createDiv({ cls: "claudian-external-context-list" });
    if (this.externalContextPaths.length === 0) {
      const emptyEl = listEl.createDiv({ cls: "claudian-external-context-empty" });
      emptyEl.setText("Click folder icon to add");
    } else {
      for (const pathStr of this.externalContextPaths) {
        const itemEl = listEl.createDiv({ cls: "claudian-external-context-item" });
        const pathTextEl = itemEl.createSpan({ cls: "claudian-external-context-text" });
        const displayPath = this.shortenPath(pathStr);
        pathTextEl.setText(displayPath);
        pathTextEl.setAttribute("title", pathStr);
        const isPersistent = this.persistentPaths.has(pathStr);
        const lockBtn = itemEl.createSpan({ cls: "claudian-external-context-lock" });
        if (isPersistent) {
          lockBtn.addClass("locked");
        }
        (0, import_obsidian18.setIcon)(lockBtn, isPersistent ? "lock" : "unlock");
        lockBtn.setAttribute("title", isPersistent ? "Persistent (click to make session-only)" : "Session-only (click to persist)");
        lockBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          this.togglePersistence(pathStr);
        });
        const removeBtn = itemEl.createSpan({ cls: "claudian-external-context-remove" });
        (0, import_obsidian18.setIcon)(removeBtn, "x");
        removeBtn.setAttribute("title", "Remove path");
        removeBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          this.removePath(pathStr);
        });
      }
    }
  }
  /** Shorten path for display (replace home dir with ~) */
  shortenPath(fullPath) {
    try {
      const os5 = require("os");
      const homeDir = os5.homedir();
      const normalize2 = (value) => value.replace(/\\/g, "/");
      const normalizedFull = normalize2(fullPath);
      const normalizedHome = normalize2(homeDir);
      const compareFull = process.platform === "win32" ? normalizedFull.toLowerCase() : normalizedHome;
      const compareHome = process.platform === "win32" ? normalizedHome.toLowerCase() : normalizedHome;
      if (compareFull.startsWith(compareHome)) {
        const remainder = normalizedFull.slice(normalizedHome.length);
        return "~" + remainder;
      }
    } catch (e) {
    }
    return fullPath;
  }
  updateDisplay() {
    if (!this.iconEl || !this.badgeEl) return;
    const count = this.externalContextPaths.length;
    if (count > 0) {
      this.iconEl.addClass("active");
      this.iconEl.setAttribute("title", `${count} external context${count > 1 ? "s" : ""} (click to add more)`);
      if (count > 1) {
        this.badgeEl.setText(String(count));
        this.badgeEl.addClass("visible");
      } else {
        this.badgeEl.removeClass("visible");
      }
    } else {
      this.iconEl.removeClass("active");
      this.iconEl.setAttribute("title", "Add external contexts (click)");
      this.badgeEl.removeClass("visible");
    }
  }
};
var McpServerSelector = class {
  constructor(parentEl) {
    this.iconEl = null;
    this.badgeEl = null;
    this.dropdownEl = null;
    this.mcpService = null;
    this.enabledServers = /* @__PURE__ */ new Set();
    this.onChangeCallback = null;
    this.container = parentEl.createDiv({ cls: "claudian-mcp-selector" });
    this.render();
  }
  /** Set the MCP service for fetching server list. */
  setMcpService(service) {
    this.mcpService = service;
    this.pruneEnabledServers();
    this.updateDisplay();
    this.renderDropdown();
  }
  /** Set callback for when enabled servers change. */
  setOnChange(callback) {
    this.onChangeCallback = callback;
  }
  /** Get currently enabled servers (via click or @-mention). */
  getEnabledServers() {
    return new Set(this.enabledServers);
  }
  /** Add servers from @-mentions. */
  addMentionedServers(names) {
    let changed = false;
    for (const name of names) {
      if (!this.enabledServers.has(name)) {
        this.enabledServers.add(name);
        changed = true;
      }
    }
    if (changed) {
      this.updateDisplay();
      this.renderDropdown();
    }
  }
  /** Clear enabled servers (call on new conversation). */
  clearEnabled() {
    this.enabledServers.clear();
    this.updateDisplay();
    this.renderDropdown();
  }
  /** Set enabled servers (call when restoring conversation state). */
  setEnabledServers(names) {
    this.enabledServers = new Set(names);
    this.pruneEnabledServers();
    this.updateDisplay();
    this.renderDropdown();
  }
  pruneEnabledServers() {
    var _a;
    if (!this.mcpService) return;
    const activeNames = new Set(this.mcpService.getServers().filter((s) => s.enabled).map((s) => s.name));
    let changed = false;
    for (const name of this.enabledServers) {
      if (!activeNames.has(name)) {
        this.enabledServers.delete(name);
        changed = true;
      }
    }
    if (changed) {
      (_a = this.onChangeCallback) == null ? void 0 : _a.call(this, this.enabledServers);
    }
  }
  render() {
    this.container.empty();
    const iconWrapper = this.container.createDiv({ cls: "claudian-mcp-selector-icon-wrapper" });
    this.iconEl = iconWrapper.createDiv({ cls: "claudian-mcp-selector-icon" });
    this.iconEl.innerHTML = MCP_ICON_SVG;
    this.badgeEl = iconWrapper.createDiv({ cls: "claudian-mcp-selector-badge" });
    this.updateDisplay();
    this.dropdownEl = this.container.createDiv({ cls: "claudian-mcp-selector-dropdown" });
    this.renderDropdown();
    this.container.addEventListener("mouseenter", () => {
      this.renderDropdown();
    });
  }
  renderDropdown() {
    var _a;
    if (!this.dropdownEl) return;
    this.pruneEnabledServers();
    this.dropdownEl.empty();
    const headerEl = this.dropdownEl.createDiv({ cls: "claudian-mcp-selector-header" });
    headerEl.setText("MCP Servers");
    const listEl = this.dropdownEl.createDiv({ cls: "claudian-mcp-selector-list" });
    const allServers = ((_a = this.mcpService) == null ? void 0 : _a.getServers()) || [];
    const servers = allServers.filter((s) => s.enabled);
    if (servers.length === 0) {
      const emptyEl = listEl.createDiv({ cls: "claudian-mcp-selector-empty" });
      emptyEl.setText(allServers.length === 0 ? "No MCP servers configured" : "All MCP servers disabled");
      return;
    }
    for (const server of servers) {
      this.renderServerItem(listEl, server);
    }
  }
  renderServerItem(listEl, server) {
    const itemEl = listEl.createDiv({ cls: "claudian-mcp-selector-item" });
    itemEl.dataset.serverName = server.name;
    const isEnabled = this.enabledServers.has(server.name);
    if (isEnabled) {
      itemEl.addClass("enabled");
    }
    const checkEl = itemEl.createDiv({ cls: "claudian-mcp-selector-check" });
    if (isEnabled) {
      checkEl.innerHTML = CHECK_ICON_SVG;
    }
    const infoEl = itemEl.createDiv({ cls: "claudian-mcp-selector-item-info" });
    const nameEl = infoEl.createSpan({ cls: "claudian-mcp-selector-item-name" });
    nameEl.setText(server.name);
    if (server.contextSaving) {
      const csEl = infoEl.createSpan({ cls: "claudian-mcp-selector-cs-badge" });
      csEl.setText("@");
      csEl.setAttribute("title", "Context-saving: can also enable via @" + server.name);
    }
    itemEl.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.toggleServer(server.name, itemEl);
    });
  }
  toggleServer(name, itemEl) {
    var _a;
    if (this.enabledServers.has(name)) {
      this.enabledServers.delete(name);
    } else {
      this.enabledServers.add(name);
    }
    const isEnabled = this.enabledServers.has(name);
    const checkEl = itemEl.querySelector(".claudian-mcp-selector-check");
    if (isEnabled) {
      itemEl.addClass("enabled");
      if (checkEl) checkEl.innerHTML = CHECK_ICON_SVG;
    } else {
      itemEl.removeClass("enabled");
      if (checkEl) checkEl.innerHTML = "";
    }
    this.updateDisplay();
    (_a = this.onChangeCallback) == null ? void 0 : _a.call(this, this.enabledServers);
  }
  updateDisplay() {
    var _a;
    this.pruneEnabledServers();
    if (!this.iconEl || !this.badgeEl) return;
    const count = this.enabledServers.size;
    const hasServers = (((_a = this.mcpService) == null ? void 0 : _a.getServers().length) || 0) > 0;
    if (!hasServers) {
      this.container.style.display = "none";
      return;
    }
    this.container.style.display = "";
    if (count > 0) {
      this.iconEl.addClass("active");
      this.iconEl.setAttribute("title", `${count} MCP server${count > 1 ? "s" : ""} enabled (click to manage)`);
      if (count > 1) {
        this.badgeEl.setText(String(count));
        this.badgeEl.addClass("visible");
      } else {
        this.badgeEl.removeClass("visible");
      }
    } else {
      this.iconEl.removeClass("active");
      this.iconEl.setAttribute("title", "MCP servers (click to enable)");
      this.badgeEl.removeClass("visible");
    }
  }
};
function createInputToolbar(parentEl, callbacks) {
  const modelSelector = new ModelSelector(parentEl, callbacks);
  const thinkingBudgetSelector = new ThinkingBudgetSelector(parentEl, callbacks);
  const contextUsageMeter = null;
  const externalContextSelector = new ExternalContextSelector(parentEl, callbacks);
  const mcpServerSelector = new McpServerSelector(parentEl);
  const permissionToggle = new PermissionToggle(parentEl, callbacks);
  return { modelSelector, thinkingBudgetSelector, contextUsageMeter, externalContextSelector, mcpServerSelector, permissionToggle };
}

// src/features/chat/ui/InstructionModeManager.ts
var INSTRUCTION_MODE_PLACEHOLDER = "# Save in custom system prompt";
var InstructionModeManager = class {
  constructor(inputEl, callbacks) {
    this.state = { active: false, rawInstruction: "" };
    this.isSubmitting = false;
    this.originalPlaceholder = "";
    this.inputEl = inputEl;
    this.callbacks = callbacks;
    this.originalPlaceholder = inputEl.placeholder;
  }
  /**
   * Handles keydown to detect # trigger.
   * Returns true if the event was consumed (should prevent default).
   */
  handleTriggerKey(e) {
    if (!this.state.active && this.inputEl.value === "" && e.key === "#") {
      if (this.enterMode()) {
        e.preventDefault();
        return true;
      }
    }
    return false;
  }
  /** Handles input changes to track instruction text. */
  handleInputChange() {
    if (!this.state.active) return;
    const text = this.inputEl.value;
    if (text === "") {
      this.exitMode();
    } else {
      this.state.rawInstruction = text;
    }
  }
  /**
   * Enters instruction mode.
   * Only enters if the indicator can be successfully shown.
   * Returns true if mode was entered, false otherwise.
   */
  enterMode() {
    const wrapper = this.callbacks.getInputWrapper();
    if (!wrapper) return false;
    wrapper.addClass("claudian-input-instruction-mode");
    this.state = { active: true, rawInstruction: "" };
    this.inputEl.placeholder = INSTRUCTION_MODE_PLACEHOLDER;
    return true;
  }
  /** Exits instruction mode, restoring original state. */
  exitMode() {
    const wrapper = this.callbacks.getInputWrapper();
    if (wrapper) {
      wrapper.removeClass("claudian-input-instruction-mode");
    }
    this.state = { active: false, rawInstruction: "" };
    this.inputEl.placeholder = this.originalPlaceholder;
  }
  /** Handles keydown events. Returns true if handled. */
  handleKeydown(e) {
    if (!this.state.active) return false;
    if (e.key === "Enter" && !e.shiftKey && !e.isComposing) {
      if (!this.state.rawInstruction.trim()) {
        return false;
      }
      e.preventDefault();
      this.submit();
      return true;
    }
    if (e.key === "Escape" && !e.isComposing) {
      e.preventDefault();
      this.cancel();
      return true;
    }
    return false;
  }
  /** Checks if instruction mode is active. */
  isActive() {
    return this.state.active;
  }
  /** Gets the current raw instruction text. */
  getRawInstruction() {
    return this.state.rawInstruction;
  }
  /** Submits the instruction for refinement. */
  async submit() {
    if (this.isSubmitting) return;
    const rawInstruction = this.state.rawInstruction.trim();
    if (!rawInstruction) return;
    this.isSubmitting = true;
    try {
      await this.callbacks.onSubmit(rawInstruction);
    } finally {
      this.isSubmitting = false;
    }
  }
  /** Cancels instruction mode and clears input. */
  cancel() {
    var _a, _b;
    this.inputEl.value = "";
    this.exitMode();
    (_b = (_a = this.callbacks).resetInputHeight) == null ? void 0 : _b.call(_a);
  }
  /** Clears the input and resets state (called after successful submission). */
  clear() {
    var _a, _b;
    this.inputEl.value = "";
    this.exitMode();
    (_b = (_a = this.callbacks).resetInputHeight) == null ? void 0 : _b.call(_a);
  }
  /** Cleans up event listeners. */
  destroy() {
    const wrapper = this.callbacks.getInputWrapper();
    if (wrapper) {
      wrapper.removeClass("claudian-input-instruction-mode");
    }
    this.inputEl.placeholder = this.originalPlaceholder;
  }
};

// src/features/chat/ui/TodoPanel.ts
var import_obsidian19 = require("obsidian");
var TodoPanel = class {
  constructor() {
    this.containerEl = null;
    this.panelEl = null;
    this.todoContainerEl = null;
    this.todoHeaderEl = null;
    this.todoContentEl = null;
    this.isExpanded = false;
    this.currentTodos = null;
    // Event handler references for cleanup
    this.clickHandler = null;
    this.keydownHandler = null;
  }
  /**
   * Mount the panel into the messages container.
   * Appends to the end of the messages area.
   */
  mount(containerEl) {
    this.containerEl = containerEl;
    this.createPanel();
  }
  /**
   * Remount the panel after the container was cleared.
   * Called when messagesEl.empty() removes the panel from DOM.
   */
  remount() {
    if (!this.containerEl) {
      return;
    }
    this.panelEl = null;
    this.todoContainerEl = null;
    this.todoHeaderEl = null;
    this.todoContentEl = null;
    this.createPanel();
  }
  /**
   * Create the panel structure.
   */
  createPanel() {
    if (!this.containerEl) {
      return;
    }
    this.panelEl = document.createElement("div");
    this.panelEl.className = "claudian-todo-panel";
    this.todoContainerEl = document.createElement("div");
    this.todoContainerEl.className = "claudian-todo-panel-todos";
    this.todoContainerEl.style.display = "none";
    this.panelEl.appendChild(this.todoContainerEl);
    this.todoHeaderEl = document.createElement("div");
    this.todoHeaderEl.className = "claudian-todo-panel-header";
    this.todoHeaderEl.setAttribute("tabindex", "0");
    this.todoHeaderEl.setAttribute("role", "button");
    this.clickHandler = () => this.toggle();
    this.keydownHandler = (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        this.toggle();
      }
    };
    this.todoHeaderEl.addEventListener("click", this.clickHandler);
    this.todoHeaderEl.addEventListener("keydown", this.keydownHandler);
    this.todoContainerEl.appendChild(this.todoHeaderEl);
    this.todoContentEl = document.createElement("div");
    this.todoContentEl.className = "claudian-todo-panel-content";
    this.todoContentEl.style.display = "none";
    this.todoContainerEl.appendChild(this.todoContentEl);
    this.containerEl.appendChild(this.panelEl);
  }
  /**
   * Update the panel with new todo items.
   * Called by ChatState.onTodosChanged callback when TodoWrite tool is used.
   * Passing null or empty array hides the panel.
   */
  updateTodos(todos) {
    if (!this.todoContainerEl || !this.todoHeaderEl || !this.todoContentEl) {
      return;
    }
    this.currentTodos = todos;
    if (!todos || todos.length === 0) {
      this.todoContainerEl.style.display = "none";
      this.todoHeaderEl.empty();
      this.todoContentEl.empty();
      return;
    }
    this.todoContainerEl.style.display = "block";
    const completedCount = todos.filter((t2) => t2.status === "completed").length;
    const totalCount = todos.length;
    const currentTask = todos.find((t2) => t2.status === "in_progress");
    this.renderHeader(completedCount, totalCount, currentTask);
    this.renderContent(todos);
    this.updateAriaLabel(completedCount, totalCount);
    this.scrollToBottom();
  }
  /**
   * Render the collapsed header.
   */
  renderHeader(completedCount, totalCount, currentTask) {
    if (!this.todoHeaderEl) return;
    this.todoHeaderEl.empty();
    const icon = document.createElement("span");
    icon.className = "claudian-todo-panel-icon";
    (0, import_obsidian19.setIcon)(icon, "list-checks");
    this.todoHeaderEl.appendChild(icon);
    const label = document.createElement("span");
    label.className = "claudian-todo-panel-label";
    label.textContent = `Tasks (${completedCount}/${totalCount})`;
    this.todoHeaderEl.appendChild(label);
    if (!this.isExpanded && currentTask) {
      const current = document.createElement("span");
      current.className = "claudian-todo-panel-current";
      current.textContent = currentTask.activeForm;
      this.todoHeaderEl.appendChild(current);
    }
  }
  /**
   * Render the expanded content.
   */
  renderContent(todos) {
    if (!this.todoContentEl) return;
    renderTodoItems(this.todoContentEl, todos);
  }
  /**
   * Toggle expanded/collapsed state.
   */
  toggle() {
    this.isExpanded = !this.isExpanded;
    this.updateDisplay();
  }
  /**
   * Update display based on expanded state.
   */
  updateDisplay() {
    if (!this.todoContentEl || !this.todoHeaderEl) return;
    this.todoContentEl.style.display = this.isExpanded ? "block" : "none";
    if (this.currentTodos && this.currentTodos.length > 0) {
      const completedCount = this.currentTodos.filter((t2) => t2.status === "completed").length;
      const totalCount = this.currentTodos.length;
      const currentTask = this.currentTodos.find((t2) => t2.status === "in_progress");
      this.renderHeader(completedCount, totalCount, currentTask);
      this.updateAriaLabel(completedCount, totalCount);
    }
    this.scrollToBottom();
  }
  /**
   * Update ARIA label.
   */
  updateAriaLabel(completedCount, totalCount) {
    if (!this.todoHeaderEl) return;
    const action = this.isExpanded ? "Collapse" : "Expand";
    this.todoHeaderEl.setAttribute(
      "aria-label",
      `${action} task list - ${completedCount} of ${totalCount} completed`
    );
    this.todoHeaderEl.setAttribute("aria-expanded", String(this.isExpanded));
  }
  /**
   * Scroll messages container to bottom.
   */
  scrollToBottom() {
    if (this.containerEl) {
      this.containerEl.scrollTop = this.containerEl.scrollHeight;
    }
  }
  /**
   * Destroy the panel.
   */
  destroy() {
    if (this.todoHeaderEl) {
      if (this.clickHandler) {
        this.todoHeaderEl.removeEventListener("click", this.clickHandler);
      }
      if (this.keydownHandler) {
        this.todoHeaderEl.removeEventListener("keydown", this.keydownHandler);
      }
    }
    this.clickHandler = null;
    this.keydownHandler = null;
    if (this.panelEl) {
      this.panelEl.remove();
      this.panelEl = null;
    }
    this.todoContainerEl = null;
    this.todoHeaderEl = null;
    this.todoContentEl = null;
    this.containerEl = null;
    this.currentTodos = null;
  }
};

// src/features/chat/tabs/types.ts
var DEFAULT_MAX_TABS = 3;
var MIN_TABS = 3;
var MAX_TABS = 10;
var TEXTAREA_MIN_MAX_HEIGHT = 150;
var TEXTAREA_MAX_HEIGHT_PERCENT = 0.55;
function generateTabId() {
  return `tab-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
}

// src/features/chat/tabs/Tab.ts
function createTab(options) {
  var _a;
  const {
    containerEl,
    conversation,
    tabId,
    onStreamingChanged,
    onAttentionChanged,
    onConversationIdChanged
  } = options;
  const id = tabId != null ? tabId : generateTabId();
  const contentEl = containerEl.createDiv({ cls: "claudian-tab-content" });
  contentEl.style.display = "none";
  const state = new ChatState({
    onStreamingStateChanged: (isStreaming) => {
      onStreamingChanged == null ? void 0 : onStreamingChanged(isStreaming);
    },
    onAttentionChanged: (needsAttention) => {
      onAttentionChanged == null ? void 0 : onAttentionChanged(needsAttention);
    },
    onConversationChanged: (conversationId) => {
      onConversationIdChanged == null ? void 0 : onConversationIdChanged(conversationId);
    }
  });
  const asyncSubagentManager = new AsyncSubagentManager(() => {
  });
  const dom = buildTabDOM(contentEl);
  const tab = {
    id,
    conversationId: (_a = conversation == null ? void 0 : conversation.id) != null ? _a : null,
    service: null,
    serviceInitialized: false,
    state,
    controllers: {
      selectionController: null,
      conversationController: null,
      streamController: null,
      inputController: null,
      navigationController: null
    },
    services: {
      asyncSubagentManager,
      instructionRefineService: null,
      titleGenerationService: null
    },
    ui: {
      fileContextManager: null,
      imageContextManager: null,
      modelSelector: null,
      thinkingBudgetSelector: null,
      externalContextSelector: null,
      mcpServerSelector: null,
      permissionToggle: null,
      slashCommandManager: null,
      slashCommandDropdown: null,
      instructionModeManager: null,
      contextUsageMeter: null,
      todoPanel: null
    },
    dom,
    renderer: null
  };
  return tab;
}
function autoResizeTextarea(textarea) {
  var _a, _b;
  textarea.style.minHeight = "";
  const viewHeight = (_b = (_a = textarea.closest(".claudian-container")) == null ? void 0 : _a.clientHeight) != null ? _b : window.innerHeight;
  const maxHeight = Math.max(TEXTAREA_MIN_MAX_HEIGHT, viewHeight * TEXTAREA_MAX_HEIGHT_PERCENT);
  const flexAllocatedHeight = textarea.offsetHeight;
  const contentHeight = Math.min(textarea.scrollHeight, maxHeight);
  if (contentHeight > flexAllocatedHeight) {
    textarea.style.minHeight = `${contentHeight}px`;
  }
  textarea.style.maxHeight = `${maxHeight}px`;
}
function buildTabDOM(contentEl) {
  const messagesWrapperEl = contentEl.createDiv({ cls: "claudian-messages-wrapper" });
  const messagesEl = messagesWrapperEl.createDiv({ cls: "claudian-messages" });
  const welcomeEl = messagesEl.createDiv({ cls: "claudian-welcome" });
  const scrollToBottomEl = messagesWrapperEl.createEl("button", {
    cls: "claudian-scroll-to-bottom",
    attr: {
      "aria-label": "Scroll to bottom",
      type: "button"
    }
  });
  scrollToBottomEl.textContent = "Scroll to bottom";
  const todoPanelContainerEl = contentEl.createDiv({ cls: "claudian-todo-panel-container" });
  const inputContainerEl = contentEl.createDiv({ cls: "claudian-input-container" });
  const navRowEl = inputContainerEl.createDiv({ cls: "claudian-input-nav-row" });
  const inputWrapper = inputContainerEl.createDiv({ cls: "claudian-input-wrapper" });
  const contextRowEl = inputWrapper.createDiv({ cls: "claudian-context-row" });
  const inputEl = inputWrapper.createEl("textarea", {
    cls: "claudian-input",
    attr: {
      placeholder: "How can I help you today?",
      rows: "3"
    }
  });
  return {
    contentEl,
    messagesEl,
    welcomeEl,
    todoPanelContainerEl,
    inputContainerEl,
    inputWrapper,
    inputEl,
    navRowEl,
    contextRowEl,
    selectionIndicatorEl: null,
    scrollToBottomEl,
    eventCleanups: []
  };
}
async function initializeTabService(tab, plugin, mcpManager) {
  var _a;
  if (tab.serviceInitialized) {
    return;
  }
  let service = null;
  try {
    service = new ClaudianService(plugin, mcpManager);
    try {
      await service.loadCCPermissions();
    } catch (e) {
    }
    let sessionId;
    let externalContextPaths = plugin.settings.persistentExternalContextPaths || [];
    if (tab.conversationId) {
      const conversation = await plugin.getConversationById(tab.conversationId);
      sessionId = (_a = conversation == null ? void 0 : conversation.sessionId) != null ? _a : void 0;
      if (conversation) {
        const hasMessages = conversation.messages.length > 0;
        externalContextPaths = hasMessages ? conversation.externalContextPaths || [] : plugin.settings.persistentExternalContextPaths || [];
      }
    }
    service.ensureReady({
      sessionId,
      externalContextPaths
    }).catch(() => {
    });
    tab.service = service;
    tab.serviceInitialized = true;
  } catch (error2) {
    service == null ? void 0 : service.closePersistentQuery("initialization failed");
    tab.service = null;
    tab.serviceInitialized = false;
    throw error2;
  }
}
function initializeContextManagers(tab, plugin) {
  const { dom } = tab;
  const app = plugin.app;
  tab.ui.fileContextManager = new FileContextManager(
    app,
    dom.contextRowEl,
    dom.inputEl,
    {
      getExcludedTags: () => plugin.settings.excludedTags,
      onChipsChanged: () => {
        var _a, _b;
        (_a = tab.controllers.selectionController) == null ? void 0 : _a.updateContextRowVisibility();
        autoResizeTextarea(dom.inputEl);
        (_b = tab.renderer) == null ? void 0 : _b.scrollToBottomIfNeeded();
      },
      getExternalContexts: () => {
        var _a;
        return ((_a = tab.ui.externalContextSelector) == null ? void 0 : _a.getExternalContexts()) || [];
      }
    },
    dom.inputContainerEl
  );
  tab.ui.fileContextManager.setMcpService(plugin.mcpService);
  tab.ui.imageContextManager = new ImageContextManager(
    dom.inputContainerEl,
    dom.inputEl,
    {
      onImagesChanged: () => {
        var _a, _b;
        (_a = tab.controllers.selectionController) == null ? void 0 : _a.updateContextRowVisibility();
        autoResizeTextarea(dom.inputEl);
        (_b = tab.renderer) == null ? void 0 : _b.scrollToBottomIfNeeded();
      }
    },
    dom.contextRowEl
  );
}
function initializeSlashCommands(tab, plugin) {
  const { dom } = tab;
  const vaultPath = getVaultPath(plugin.app);
  if (vaultPath) {
    tab.ui.slashCommandManager = new SlashCommandManager(plugin.app, vaultPath);
    tab.ui.slashCommandManager.setCommands(plugin.settings.slashCommands);
    tab.ui.slashCommandDropdown = new SlashCommandDropdown(
      dom.inputContainerEl,
      dom.inputEl,
      {
        onSelect: () => {
        },
        onHide: () => {
        },
        getCommands: () => plugin.settings.slashCommands
      }
    );
  }
}
function initializeInstructionAndTodo(tab, plugin) {
  const { dom } = tab;
  tab.services.instructionRefineService = new InstructionRefineService(plugin);
  tab.services.titleGenerationService = new TitleGenerationService(plugin);
  tab.ui.instructionModeManager = new InstructionModeManager(
    dom.inputEl,
    {
      onSubmit: async (rawInstruction) => {
        var _a;
        await ((_a = tab.controllers.inputController) == null ? void 0 : _a.handleInstructionSubmit(rawInstruction));
      },
      getInputWrapper: () => dom.inputWrapper
    }
  );
  tab.ui.todoPanel = new TodoPanel();
  tab.ui.todoPanel.mount(dom.todoPanelContainerEl);
}
function initializeInputToolbar(tab, plugin) {
  var _a;
  const { dom } = tab;
  const inputToolbar = dom.inputWrapper.createDiv({ cls: "claudian-input-toolbar" });
  const toolbarComponents = createInputToolbar(inputToolbar, {
    getSettings: () => ({
      model: plugin.settings.model,
      thinkingBudget: plugin.settings.thinkingBudget,
      permissionMode: plugin.settings.permissionMode,
      show1MModel: plugin.settings.show1MModel
    }),
    getEnvironmentVariables: () => plugin.getActiveEnvironmentVariables(),
    onModelChange: async (model) => {
      var _a2, _b, _c;
      plugin.settings.model = model;
      const isDefaultModel = DEFAULT_CLAUDE_MODELS.find((m) => m.value === model);
      if (isDefaultModel) {
        plugin.settings.thinkingBudget = DEFAULT_THINKING_BUDGET[model];
        plugin.settings.lastClaudeModel = model;
      } else {
        plugin.settings.lastCustomModel = model;
      }
      await plugin.saveSettings();
      (_a2 = tab.ui.thinkingBudgetSelector) == null ? void 0 : _a2.updateDisplay();
      (_b = tab.ui.modelSelector) == null ? void 0 : _b.updateDisplay();
      (_c = tab.ui.modelSelector) == null ? void 0 : _c.renderOptions();
    },
    onThinkingBudgetChange: async (budget) => {
      plugin.settings.thinkingBudget = budget;
      await plugin.saveSettings();
    },
    onPermissionModeChange: async (mode) => {
      plugin.settings.permissionMode = mode;
      await plugin.saveSettings();
    }
  });
  tab.ui.modelSelector = toolbarComponents.modelSelector;
  tab.ui.thinkingBudgetSelector = toolbarComponents.thinkingBudgetSelector;
  tab.ui.contextUsageMeter = toolbarComponents.contextUsageMeter;
  tab.ui.externalContextSelector = toolbarComponents.externalContextSelector;
  tab.ui.mcpServerSelector = toolbarComponents.mcpServerSelector;
  tab.ui.permissionToggle = toolbarComponents.permissionToggle;
  tab.ui.mcpServerSelector.setMcpService(plugin.mcpService);
  (_a = tab.ui.fileContextManager) == null ? void 0 : _a.setOnMcpMentionChange((servers) => {
    var _a2;
    (_a2 = tab.ui.mcpServerSelector) == null ? void 0 : _a2.addMentionedServers(servers);
  });
  tab.ui.externalContextSelector.setOnChange(() => {
    var _a2;
    (_a2 = tab.ui.fileContextManager) == null ? void 0 : _a2.preScanExternalContexts();
  });
  tab.ui.externalContextSelector.setPersistentPaths(
    plugin.settings.persistentExternalContextPaths || []
  );
  tab.ui.externalContextSelector.setOnPersistenceChange(async (paths) => {
    plugin.settings.persistentExternalContextPaths = paths;
    await plugin.saveSettings();
  });
}
function initializeTabUI(tab, plugin) {
  const { dom, state } = tab;
  initializeContextManagers(tab, plugin);
  dom.selectionIndicatorEl = dom.contextRowEl.createDiv({ cls: "claudian-selection-indicator" });
  dom.selectionIndicatorEl.style.display = "none";
  initializeSlashCommands(tab, plugin);
  initializeInstructionAndTodo(tab, plugin);
  initializeInputToolbar(tab, plugin);
  const updateScrollToBottomVisibility = () => {
    if (dom.scrollToBottomEl) {
      const shouldShow = !state.autoScrollEnabled;
      dom.scrollToBottomEl.classList.toggle("visible", shouldShow);
    }
  };
  state.callbacks = {
    ...state.callbacks,
    onUsageChanged: (usage) => {
      var _a;
      return (_a = tab.ui.contextUsageMeter) == null ? void 0 : _a.update(usage);
    },
    onTodosChanged: (todos) => {
      var _a;
      return (_a = tab.ui.todoPanel) == null ? void 0 : _a.updateTodos(todos);
    },
    onAutoScrollChanged: () => updateScrollToBottomVisibility()
  };
  updateScrollToBottomVisibility();
}
function initializeTabControllers(tab, plugin, component, mcpManager) {
  const { dom, state, services, ui } = tab;
  tab.renderer = new MessageRenderer(plugin, component, dom.messagesEl);
  tab.controllers.selectionController = new SelectionController(
    plugin.app,
    dom.selectionIndicatorEl,
    dom.inputEl,
    dom.contextRowEl,
    () => autoResizeTextarea(dom.inputEl)
  );
  tab.controllers.streamController = new StreamController({
    plugin,
    state,
    renderer: tab.renderer,
    asyncSubagentManager: services.asyncSubagentManager,
    getMessagesEl: () => dom.messagesEl,
    getFileContextManager: () => ui.fileContextManager,
    updateQueueIndicator: () => {
      var _a;
      return (_a = tab.controllers.inputController) == null ? void 0 : _a.updateQueueIndicator();
    },
    getAgentService: () => tab.service
  });
  services.asyncSubagentManager.setCallback(
    (subagent) => {
      var _a;
      return (_a = tab.controllers.streamController) == null ? void 0 : _a.onAsyncSubagentStateChange(subagent);
    }
  );
  tab.controllers.conversationController = new ConversationController(
    {
      plugin,
      state,
      renderer: tab.renderer,
      asyncSubagentManager: services.asyncSubagentManager,
      getHistoryDropdown: () => null,
      // Tab doesn't have its own history dropdown
      getWelcomeEl: () => dom.welcomeEl,
      setWelcomeEl: (el) => {
        dom.welcomeEl = el;
      },
      getMessagesEl: () => dom.messagesEl,
      getInputEl: () => dom.inputEl,
      getFileContextManager: () => ui.fileContextManager,
      getImageContextManager: () => ui.imageContextManager,
      getMcpServerSelector: () => ui.mcpServerSelector,
      getExternalContextSelector: () => ui.externalContextSelector,
      clearQueuedMessage: () => {
        var _a;
        return (_a = tab.controllers.inputController) == null ? void 0 : _a.clearQueuedMessage();
      },
      getTitleGenerationService: () => services.titleGenerationService,
      getTodoPanel: () => ui.todoPanel,
      getAgentService: () => tab.service
      // Use tab's service instead of plugin's
    },
    {}
  );
  const generateId = () => `msg-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
  tab.controllers.inputController = new InputController({
    plugin,
    state,
    renderer: tab.renderer,
    streamController: tab.controllers.streamController,
    selectionController: tab.controllers.selectionController,
    conversationController: tab.controllers.conversationController,
    getInputEl: () => dom.inputEl,
    getWelcomeEl: () => dom.welcomeEl,
    getMessagesEl: () => dom.messagesEl,
    getFileContextManager: () => ui.fileContextManager,
    getImageContextManager: () => ui.imageContextManager,
    getSlashCommandManager: () => ui.slashCommandManager,
    getMcpServerSelector: () => ui.mcpServerSelector,
    getExternalContextSelector: () => ui.externalContextSelector,
    getInstructionModeManager: () => ui.instructionModeManager,
    getInstructionRefineService: () => services.instructionRefineService,
    getTitleGenerationService: () => services.titleGenerationService,
    generateId,
    resetContextMeter: () => {
      var _a;
      return (_a = ui.contextUsageMeter) == null ? void 0 : _a.update(null);
    },
    resetInputHeight: () => {
    },
    // Override to use tab's service instead of plugin.agentService
    getAgentService: () => tab.service,
    // Lazy initialization: ensure service is ready before first query
    // initializeTabService() handles session ID resolution from tab.conversationId
    ensureServiceInitialized: async () => {
      if (tab.serviceInitialized) {
        return true;
      }
      try {
        await initializeTabService(tab, plugin, mcpManager);
        setupApprovalCallback(tab);
        return true;
      } catch (e) {
        return false;
      }
    }
  });
  tab.controllers.navigationController = new NavigationController({
    getMessagesEl: () => dom.messagesEl,
    getInputEl: () => dom.inputEl,
    getSettings: () => plugin.settings.keyboardNavigation,
    isStreaming: () => state.isStreaming,
    shouldSkipEscapeHandling: () => {
      var _a, _b, _c;
      if ((_a = ui.instructionModeManager) == null ? void 0 : _a.isActive()) return true;
      if ((_b = ui.slashCommandDropdown) == null ? void 0 : _b.isVisible()) return true;
      if ((_c = ui.fileContextManager) == null ? void 0 : _c.isMentionDropdownVisible()) return true;
      return false;
    }
  });
  tab.controllers.navigationController.initialize();
}
function wireTabInputEvents(tab) {
  const { dom, ui, state, controllers } = tab;
  const keydownHandler = (e) => {
    var _a, _b, _c, _d, _e, _f;
    if ((_a = ui.instructionModeManager) == null ? void 0 : _a.handleTriggerKey(e)) {
      return;
    }
    if ((_b = ui.instructionModeManager) == null ? void 0 : _b.handleKeydown(e)) {
      return;
    }
    if ((_c = ui.slashCommandDropdown) == null ? void 0 : _c.handleKeydown(e)) {
      return;
    }
    if ((_d = ui.fileContextManager) == null ? void 0 : _d.handleMentionKeydown(e)) {
      return;
    }
    if (e.key === "Escape" && !e.isComposing && state.isStreaming) {
      e.preventDefault();
      (_e = controllers.inputController) == null ? void 0 : _e.cancelStreaming();
      return;
    }
    if (e.key === "Enter" && !e.shiftKey && !e.isComposing) {
      e.preventDefault();
      void ((_f = controllers.inputController) == null ? void 0 : _f.sendMessage());
    }
  };
  dom.inputEl.addEventListener("keydown", keydownHandler);
  dom.eventCleanups.push(() => dom.inputEl.removeEventListener("keydown", keydownHandler));
  const inputHandler = () => {
    var _a, _b;
    (_a = ui.fileContextManager) == null ? void 0 : _a.handleInputChange();
    (_b = ui.instructionModeManager) == null ? void 0 : _b.handleInputChange();
    autoResizeTextarea(dom.inputEl);
  };
  dom.inputEl.addEventListener("input", inputHandler);
  dom.eventCleanups.push(() => dom.inputEl.removeEventListener("input", inputHandler));
  const focusHandler = () => {
    var _a;
    (_a = controllers.selectionController) == null ? void 0 : _a.showHighlight();
  };
  dom.inputEl.addEventListener("focus", focusHandler);
  dom.eventCleanups.push(() => dom.inputEl.removeEventListener("focus", focusHandler));
  const SCROLL_THRESHOLD = 20;
  const RE_ENABLE_DELAY = 150;
  let reEnableTimeout = null;
  const scrollHandler = () => {
    const { scrollTop, scrollHeight, clientHeight } = dom.messagesEl;
    const isAtBottom = scrollHeight - scrollTop - clientHeight <= SCROLL_THRESHOLD;
    if (!isAtBottom) {
      if (reEnableTimeout) {
        clearTimeout(reEnableTimeout);
        reEnableTimeout = null;
      }
      state.autoScrollEnabled = false;
    } else if (!state.autoScrollEnabled) {
      if (!reEnableTimeout) {
        reEnableTimeout = setTimeout(() => {
          state.autoScrollEnabled = true;
          reEnableTimeout = null;
        }, RE_ENABLE_DELAY);
      }
    }
  };
  dom.messagesEl.addEventListener("scroll", scrollHandler);
  dom.eventCleanups.push(() => {
    dom.messagesEl.removeEventListener("scroll", scrollHandler);
    if (reEnableTimeout) clearTimeout(reEnableTimeout);
  });
  if (dom.scrollToBottomEl) {
    const scrollToBottomHandler = () => {
      dom.messagesEl.scrollTop = dom.messagesEl.scrollHeight;
      state.autoScrollEnabled = true;
    };
    dom.scrollToBottomEl.addEventListener("click", scrollToBottomHandler);
    dom.eventCleanups.push(() => {
      var _a;
      return (_a = dom.scrollToBottomEl) == null ? void 0 : _a.removeEventListener("click", scrollToBottomHandler);
    });
  }
}
function activateTab(tab) {
  var _a;
  tab.dom.contentEl.style.display = "flex";
  (_a = tab.controllers.selectionController) == null ? void 0 : _a.start();
}
function deactivateTab(tab) {
  var _a;
  tab.dom.contentEl.style.display = "none";
  (_a = tab.controllers.selectionController) == null ? void 0 : _a.stop();
}
async function destroyTab(tab) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  (_a = tab.controllers.selectionController) == null ? void 0 : _a.stop();
  (_b = tab.controllers.selectionController) == null ? void 0 : _b.clear();
  (_c = tab.controllers.navigationController) == null ? void 0 : _c.dispose();
  cleanupThinkingBlock(tab.state.currentThinkingState);
  tab.state.currentThinkingState = null;
  (_d = tab.ui.fileContextManager) == null ? void 0 : _d.destroy();
  (_e = tab.ui.slashCommandDropdown) == null ? void 0 : _e.destroy();
  tab.ui.slashCommandDropdown = null;
  tab.ui.slashCommandManager = null;
  (_f = tab.ui.instructionModeManager) == null ? void 0 : _f.destroy();
  tab.ui.instructionModeManager = null;
  (_g = tab.services.instructionRefineService) == null ? void 0 : _g.cancel();
  tab.services.instructionRefineService = null;
  (_h = tab.services.titleGenerationService) == null ? void 0 : _h.cancel();
  tab.services.titleGenerationService = null;
  (_i = tab.ui.todoPanel) == null ? void 0 : _i.destroy();
  tab.ui.todoPanel = null;
  tab.services.asyncSubagentManager.orphanAllActive();
  tab.state.asyncSubagentStates.clear();
  for (const cleanup of tab.dom.eventCleanups) {
    cleanup();
  }
  tab.dom.eventCleanups.length = 0;
  (_j = tab.service) == null ? void 0 : _j.closePersistentQuery("tab closed");
  tab.service = null;
  tab.dom.contentEl.remove();
}
function getTabTitle(tab, plugin) {
  if (tab.conversationId) {
    const conversation = plugin.getConversationSync(tab.conversationId);
    if (conversation == null ? void 0 : conversation.title) {
      return conversation.title;
    }
  }
  return "New Chat";
}
function setupApprovalCallback(tab) {
  if (tab.service && tab.controllers.inputController) {
    tab.service.setApprovalCallback(
      (toolName, input, description) => tab.controllers.inputController.handleApprovalRequest(toolName, input, description)
    );
  }
}

// src/features/chat/tabs/TabBar.ts
var TabBar = class {
  constructor(containerEl, callbacks) {
    this.containerEl = containerEl;
    this.callbacks = callbacks;
    this.build();
  }
  /** Builds the tab bar UI. */
  build() {
    this.containerEl.addClass("claudian-tab-badges");
  }
  /**
   * Updates the tab bar with new tab data.
   * @param items Tab items to render.
   */
  update(items) {
    this.containerEl.empty();
    for (const item of items) {
      this.renderBadge(item);
    }
  }
  /** Renders a single tab badge. */
  renderBadge(item) {
    let stateClass = "claudian-tab-badge-idle";
    if (item.isActive) {
      stateClass = "claudian-tab-badge-active";
    } else if (item.needsAttention) {
      stateClass = "claudian-tab-badge-attention";
    } else if (item.isStreaming) {
      stateClass = "claudian-tab-badge-streaming";
    }
    const badgeEl = this.containerEl.createDiv({
      cls: `claudian-tab-badge ${stateClass}`,
      text: String(item.index)
    });
    badgeEl.setAttribute("aria-label", item.title);
    badgeEl.setAttribute("title", item.title);
    badgeEl.addEventListener("click", () => {
      this.callbacks.onTabClick(item.id);
    });
    if (item.canClose) {
      badgeEl.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        this.callbacks.onTabClose(item.id);
      });
    }
  }
  /** Destroys the tab bar. */
  destroy() {
    this.containerEl.empty();
    this.containerEl.removeClass("claudian-tab-badges");
  }
};

// src/features/chat/tabs/TabManager.ts
var TabManager = class {
  constructor(plugin, mcpManager, containerEl, view, callbacks = {}) {
    this.tabs = /* @__PURE__ */ new Map();
    this.activeTabId = null;
    /** Guard to prevent concurrent tab switches. */
    this.isSwitchingTab = false;
    this.plugin = plugin;
    this.mcpManager = mcpManager;
    this.containerEl = containerEl;
    this.view = view;
    this.callbacks = callbacks;
  }
  /**
   * Gets the current max tabs limit from settings.
   * Clamps to MIN_TABS and MAX_TABS bounds.
   */
  getMaxTabs() {
    var _a;
    const settingsValue = (_a = this.plugin.settings.maxTabs) != null ? _a : DEFAULT_MAX_TABS;
    return Math.max(MIN_TABS, Math.min(MAX_TABS, settingsValue));
  }
  // ============================================
  // Tab Lifecycle
  // ============================================
  /**
   * Creates a new tab.
   * @param conversationId Optional conversation to load into the tab.
   * @param tabId Optional tab ID (for restoration).
   * @returns The created tab, or null if max tabs reached.
   */
  async createTab(conversationId, tabId) {
    var _a, _b;
    const maxTabs = this.getMaxTabs();
    if (this.tabs.size >= maxTabs) {
      return null;
    }
    const conversation = conversationId ? await this.plugin.getConversationById(conversationId) : void 0;
    const tab = createTab({
      plugin: this.plugin,
      mcpManager: this.mcpManager,
      containerEl: this.containerEl,
      conversation: conversation != null ? conversation : void 0,
      tabId,
      onStreamingChanged: (isStreaming) => {
        var _a2, _b2;
        (_b2 = (_a2 = this.callbacks).onTabStreamingChanged) == null ? void 0 : _b2.call(_a2, tab.id, isStreaming);
      },
      onTitleChanged: (title) => {
        var _a2, _b2;
        (_b2 = (_a2 = this.callbacks).onTabTitleChanged) == null ? void 0 : _b2.call(_a2, tab.id, title);
      },
      onAttentionChanged: (needsAttention) => {
        var _a2, _b2;
        (_b2 = (_a2 = this.callbacks).onTabAttentionChanged) == null ? void 0 : _b2.call(_a2, tab.id, needsAttention);
      },
      onConversationIdChanged: (conversationId2) => {
        var _a2, _b2;
        tab.conversationId = conversationId2;
        (_b2 = (_a2 = this.callbacks).onTabConversationChanged) == null ? void 0 : _b2.call(_a2, tab.id, conversationId2);
      }
    });
    initializeTabUI(tab, this.plugin);
    initializeTabControllers(tab, this.plugin, this.view, this.mcpManager);
    wireTabInputEvents(tab);
    this.tabs.set(tab.id, tab);
    (_b = (_a = this.callbacks).onTabCreated) == null ? void 0 : _b.call(_a, tab);
    await this.switchToTab(tab.id);
    return tab;
  }
  /**
   * Switches to a different tab.
   * @param tabId The tab to switch to.
   */
  async switchToTab(tabId) {
    var _a, _b, _c, _d, _e;
    const tab = this.tabs.get(tabId);
    if (!tab) {
      return;
    }
    if (this.isSwitchingTab) {
      return;
    }
    this.isSwitchingTab = true;
    const previousTabId = this.activeTabId;
    try {
      if (previousTabId && previousTabId !== tabId) {
        const currentTab = this.tabs.get(previousTabId);
        if (currentTab) {
          deactivateTab(currentTab);
        }
      }
      this.activeTabId = tabId;
      activateTab(tab);
      if (tab.conversationId && tab.state.messages.length === 0) {
        await ((_a = tab.controllers.conversationController) == null ? void 0 : _a.switchTo(tab.conversationId));
      } else if (tab.conversationId && tab.state.messages.length > 0 && tab.service) {
        const conversation = await this.plugin.getConversationById(tab.conversationId);
        if (conversation) {
          const hasMessages = conversation.messages.length > 0;
          const externalContextPaths = hasMessages ? conversation.externalContextPaths || [] : this.plugin.settings.persistentExternalContextPaths || [];
          tab.service.setSessionId((_b = conversation.sessionId) != null ? _b : null, externalContextPaths);
        }
      } else if (!tab.conversationId && tab.state.messages.length === 0) {
        (_c = tab.controllers.conversationController) == null ? void 0 : _c.initializeWelcome();
      }
      (_e = (_d = this.callbacks).onTabSwitched) == null ? void 0 : _e.call(_d, previousTabId, tabId);
    } finally {
      this.isSwitchingTab = false;
    }
  }
  /**
   * Closes a tab.
   * @param tabId The tab to close.
   * @param force If true, close even if streaming.
   * @returns True if the tab was closed.
   */
  async closeTab(tabId, force = false) {
    var _a, _b, _c;
    const tab = this.tabs.get(tabId);
    if (!tab) {
      return false;
    }
    if (tab.state.isStreaming && !force) {
      return false;
    }
    if (this.tabs.size === 1 && !tab.conversationId && tab.state.messages.length === 0) {
      return false;
    }
    await ((_a = tab.controllers.conversationController) == null ? void 0 : _a.save());
    const tabIdsBefore = Array.from(this.tabs.keys());
    const closingIndex = tabIdsBefore.indexOf(tabId);
    await destroyTab(tab);
    this.tabs.delete(tabId);
    (_c = (_b = this.callbacks).onTabClosed) == null ? void 0 : _c.call(_b, tabId);
    if (this.activeTabId === tabId) {
      this.activeTabId = null;
      if (this.tabs.size > 0) {
        const fallbackTabId = closingIndex === 0 ? tabIdsBefore[1] : tabIdsBefore[closingIndex - 1];
        if (fallbackTabId && this.tabs.has(fallbackTabId)) {
          await this.switchToTab(fallbackTabId);
          if (this.tabs.size === 1) {
            await this.initializeActiveTabService();
          }
        }
      } else {
        await this.createTab();
        await this.initializeActiveTabService();
      }
    }
    return true;
  }
  // ============================================
  // Tab Queries
  // ============================================
  /** Gets the currently active tab. */
  getActiveTab() {
    var _a;
    return this.activeTabId ? (_a = this.tabs.get(this.activeTabId)) != null ? _a : null : null;
  }
  /** Gets the active tab ID. */
  getActiveTabId() {
    return this.activeTabId;
  }
  /** Gets a tab by ID. */
  getTab(tabId) {
    var _a;
    return (_a = this.tabs.get(tabId)) != null ? _a : null;
  }
  /** Gets all tabs. */
  getAllTabs() {
    return Array.from(this.tabs.values());
  }
  /** Gets the number of tabs. */
  getTabCount() {
    return this.tabs.size;
  }
  /** Checks if more tabs can be created. */
  canCreateTab() {
    return this.tabs.size < this.getMaxTabs();
  }
  // ============================================
  // Tab Bar Data
  // ============================================
  /** Gets data for rendering the tab bar. */
  getTabBarItems() {
    const items = [];
    let index = 1;
    for (const tab of this.tabs.values()) {
      items.push({
        id: tab.id,
        index: index++,
        title: getTabTitle(tab, this.plugin),
        isActive: tab.id === this.activeTabId,
        isStreaming: tab.state.isStreaming,
        needsAttention: tab.state.needsAttention,
        canClose: this.tabs.size > 1 || !tab.state.isStreaming
      });
    }
    return items;
  }
  // ============================================
  // Conversation Management
  // ============================================
  /**
   * Opens a conversation in a new tab or existing tab.
   * @param conversationId The conversation to open.
   * @param preferNewTab If true, prefer opening in a new tab.
   */
  async openConversation(conversationId, preferNewTab = false) {
    var _a, _b;
    for (const tab of this.tabs.values()) {
      if (tab.conversationId === conversationId) {
        await this.switchToTab(tab.id);
        return;
      }
    }
    const crossViewResult = this.plugin.findConversationAcrossViews(conversationId);
    const isSameView = (crossViewResult == null ? void 0 : crossViewResult.view) === this.view;
    if (crossViewResult && !isSameView) {
      this.plugin.app.workspace.revealLeaf(crossViewResult.view.leaf);
      await ((_a = crossViewResult.view.getTabManager()) == null ? void 0 : _a.switchToTab(crossViewResult.tabId));
      return;
    }
    if (preferNewTab && this.canCreateTab()) {
      await this.createTab(conversationId);
    } else {
      const activeTab = this.getActiveTab();
      if (activeTab) {
        await ((_b = activeTab.controllers.conversationController) == null ? void 0 : _b.switchTo(conversationId));
      }
    }
  }
  /**
   * Creates a new conversation in the active tab.
   */
  async createNewConversation() {
    var _a;
    const activeTab = this.getActiveTab();
    if (activeTab) {
      await ((_a = activeTab.controllers.conversationController) == null ? void 0 : _a.createNew());
      activeTab.conversationId = activeTab.state.currentConversationId;
    }
  }
  // ============================================
  // Persistence
  // ============================================
  /** Gets the state to persist. */
  getPersistedState() {
    const openTabs = [];
    for (const tab of this.tabs.values()) {
      openTabs.push({
        tabId: tab.id,
        conversationId: tab.conversationId
      });
    }
    return {
      openTabs,
      activeTabId: this.activeTabId
    };
  }
  /** Restores state from persisted data. */
  async restoreState(state) {
    for (const tabState of state.openTabs) {
      try {
        await this.createTab(tabState.conversationId, tabState.tabId);
      } catch (e) {
      }
    }
    if (state.activeTabId && this.tabs.has(state.activeTabId)) {
      try {
        await this.switchToTab(state.activeTabId);
      } catch (e) {
      }
    }
    if (this.tabs.size === 0) {
      await this.createTab();
    }
    await this.initializeActiveTabService();
  }
  /**
   * Initializes the active tab's service if not already done.
   * Called after restore to ensure the visible tab is ready immediately.
   */
  async initializeActiveTabService() {
    const activeTab = this.getActiveTab();
    if (!activeTab || activeTab.serviceInitialized) {
      return;
    }
    try {
      await initializeTabService(activeTab, this.plugin, this.mcpManager);
      setupApprovalCallback(activeTab);
    } catch (e) {
    }
  }
  // ============================================
  // Broadcast
  // ============================================
  /**
   * Broadcasts a function call to all tabs' ClaudianService instances.
   * Used by settings managers to apply configuration changes to all tabs.
   * @param fn Function to call on each service.
   */
  async broadcastToAllTabs(fn) {
    const promises = [];
    for (const tab of this.tabs.values()) {
      if (tab.service && tab.serviceInitialized) {
        promises.push(
          fn(tab.service).catch(() => {
          })
        );
      }
    }
    await Promise.all(promises);
  }
  // ============================================
  // Cleanup
  // ============================================
  /** Destroys all tabs and cleans up resources. */
  async destroy() {
    var _a;
    for (const tab of this.tabs.values()) {
      await ((_a = tab.controllers.conversationController) == null ? void 0 : _a.save());
    }
    for (const tab of this.tabs.values()) {
      await destroyTab(tab);
    }
    this.tabs.clear();
    this.activeTabId = null;
  }
};

// src/features/chat/ClaudianView.ts
var ClaudianView = class extends import_obsidian20.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    // Tab management
    this.tabManager = null;
    this.tabBar = null;
    this.tabBarContainerEl = null;
    this.tabContentEl = null;
    this.navRowContent = null;
    // DOM Elements
    this.viewContainerEl = null;
    // Header elements
    this.historyDropdown = null;
    // Event refs for cleanup
    this.eventRefs = [];
    // Debouncing for tab bar updates
    this.pendingTabBarUpdate = null;
    // Debouncing for tab state persistence
    this.pendingPersist = null;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_CLAUDIAN;
  }
  getDisplayText() {
    return "Claudian";
  }
  getIcon() {
    return "bot";
  }
  /** Refreshes the model selector display (used after env var changes). */
  refreshModelSelector() {
    var _a, _b, _c;
    const activeTab = (_a = this.tabManager) == null ? void 0 : _a.getActiveTab();
    (_b = activeTab == null ? void 0 : activeTab.ui.modelSelector) == null ? void 0 : _b.updateDisplay();
    (_c = activeTab == null ? void 0 : activeTab.ui.modelSelector) == null ? void 0 : _c.renderOptions();
  }
  async onOpen() {
    this.viewContainerEl = this.containerEl.children[1];
    this.viewContainerEl.empty();
    this.viewContainerEl.addClass("claudian-container");
    const header = this.viewContainerEl.createDiv({ cls: "claudian-header" });
    this.buildHeader(header);
    this.navRowContent = this.buildNavRowContent();
    this.tabContentEl = this.viewContainerEl.createDiv({ cls: "claudian-tab-content-container" });
    this.tabManager = new TabManager(
      this.plugin,
      this.plugin.mcpService.getManager(),
      this.tabContentEl,
      this,
      {
        onTabCreated: () => {
          this.updateTabBar();
          this.updateNavRowLocation();
          this.persistTabState();
        },
        onTabSwitched: () => {
          this.updateTabBar();
          this.updateHistoryDropdown();
          this.updateNavRowLocation();
          this.persistTabState();
        },
        onTabClosed: () => {
          this.updateTabBar();
          this.persistTabState();
        },
        onTabStreamingChanged: () => this.updateTabBar(),
        onTabTitleChanged: () => this.updateTabBar(),
        onTabAttentionChanged: () => this.updateTabBar(),
        onTabConversationChanged: () => {
          this.persistTabState();
        }
      }
    );
    this.wireEventHandlers();
    await this.restoreOrCreateTabs();
    this.updateTabBarVisibility();
    this.updateNavRowLocation();
  }
  async onClose() {
    var _a, _b;
    if (this.pendingTabBarUpdate !== null) {
      cancelAnimationFrame(this.pendingTabBarUpdate);
      this.pendingTabBarUpdate = null;
    }
    for (const ref of this.eventRefs) {
      this.plugin.app.vault.offref(ref);
    }
    this.eventRefs = [];
    await this.persistTabStateImmediate();
    await ((_a = this.tabManager) == null ? void 0 : _a.destroy());
    this.tabManager = null;
    (_b = this.tabBar) == null ? void 0 : _b.destroy();
    this.tabBar = null;
  }
  // ============================================
  // UI Building
  // ============================================
  buildHeader(header) {
    const titleContainer = header.createDiv({ cls: "claudian-title" });
    const logoEl = titleContainer.createSpan({ cls: "claudian-logo" });
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("viewBox", LOGO_SVG.viewBox);
    svg.setAttribute("width", LOGO_SVG.width);
    svg.setAttribute("height", LOGO_SVG.height);
    svg.setAttribute("fill", "none");
    const path9 = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path9.setAttribute("d", LOGO_SVG.path);
    path9.setAttribute("fill", LOGO_SVG.fill);
    svg.appendChild(path9);
    logoEl.appendChild(svg);
    titleContainer.createEl("h4", { text: "Claudian" });
  }
  /**
   * Builds the nav row content (tab badges + header actions).
   * This is called once and the content is moved between tabs.
   */
  buildNavRowContent() {
    const fragment = document.createDocumentFragment();
    this.tabBarContainerEl = document.createElement("div");
    this.tabBarContainerEl.className = "claudian-tab-bar-container";
    this.tabBar = new TabBar(this.tabBarContainerEl, {
      onTabClick: (tabId) => this.handleTabClick(tabId),
      onTabClose: (tabId) => this.handleTabClose(tabId),
      onNewTab: () => this.handleNewTab()
    });
    fragment.appendChild(this.tabBarContainerEl);
    const headerActions = document.createElement("div");
    headerActions.className = "claudian-header-actions";
    const newTabBtn = headerActions.createDiv({ cls: "claudian-header-btn claudian-new-tab-btn" });
    (0, import_obsidian20.setIcon)(newTabBtn, "square-plus");
    newTabBtn.setAttribute("aria-label", "New tab");
    newTabBtn.addEventListener("click", async () => {
      await this.handleNewTab();
    });
    const newBtn = headerActions.createDiv({ cls: "claudian-header-btn" });
    (0, import_obsidian20.setIcon)(newBtn, "square-pen");
    newBtn.setAttribute("aria-label", "New conversation");
    newBtn.addEventListener("click", async () => {
      var _a;
      await ((_a = this.tabManager) == null ? void 0 : _a.createNewConversation());
      this.updateHistoryDropdown();
    });
    const historyContainer = headerActions.createDiv({ cls: "claudian-history-container" });
    const historyBtn = historyContainer.createDiv({ cls: "claudian-header-btn" });
    (0, import_obsidian20.setIcon)(historyBtn, "history");
    historyBtn.setAttribute("aria-label", "Chat history");
    this.historyDropdown = historyContainer.createDiv({ cls: "claudian-history-menu" });
    historyBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      this.toggleHistoryDropdown();
    });
    fragment.appendChild(headerActions);
    const wrapper = document.createElement("div");
    wrapper.style.display = "contents";
    wrapper.appendChild(fragment);
    return wrapper;
  }
  /**
   * Moves nav row content to the active tab's nav row.
   */
  updateNavRowLocation() {
    var _a;
    const activeTab = (_a = this.tabManager) == null ? void 0 : _a.getActiveTab();
    if (!activeTab || !this.navRowContent) return;
    activeTab.dom.navRowEl.appendChild(this.navRowContent);
  }
  // ============================================
  // Tab Management
  // ============================================
  handleTabClick(tabId) {
    var _a;
    (_a = this.tabManager) == null ? void 0 : _a.switchToTab(tabId);
  }
  async handleTabClose(tabId) {
    var _a, _b, _c;
    const tab = (_a = this.tabManager) == null ? void 0 : _a.getTab(tabId);
    const force = (_b = tab == null ? void 0 : tab.state.isStreaming) != null ? _b : false;
    await ((_c = this.tabManager) == null ? void 0 : _c.closeTab(tabId, force));
    this.updateTabBarVisibility();
  }
  async handleNewTab() {
    var _a, _b;
    const tab = await ((_a = this.tabManager) == null ? void 0 : _a.createTab());
    if (!tab) {
      const maxTabs = (_b = this.plugin.settings.maxTabs) != null ? _b : 3;
      new import_obsidian20.Notice(`Maximum ${maxTabs} tabs allowed`);
      return;
    }
    this.updateTabBarVisibility();
  }
  updateTabBar() {
    if (!this.tabManager || !this.tabBar) return;
    if (this.pendingTabBarUpdate !== null) {
      cancelAnimationFrame(this.pendingTabBarUpdate);
    }
    this.pendingTabBarUpdate = requestAnimationFrame(() => {
      this.pendingTabBarUpdate = null;
      if (!this.tabManager || !this.tabBar) return;
      const items = this.tabManager.getTabBarItems();
      this.tabBar.update(items);
      this.updateTabBarVisibility();
    });
  }
  updateTabBarVisibility() {
    if (!this.tabBarContainerEl || !this.tabManager) return;
    const tabCount = this.tabManager.getTabCount();
    const showTabBar = tabCount >= 2;
    this.tabBarContainerEl.style.display = showTabBar ? "flex" : "none";
  }
  // ============================================
  // History Dropdown
  // ============================================
  toggleHistoryDropdown() {
    if (!this.historyDropdown) return;
    const isVisible = this.historyDropdown.hasClass("visible");
    if (isVisible) {
      this.historyDropdown.removeClass("visible");
    } else {
      this.updateHistoryDropdown();
      this.historyDropdown.addClass("visible");
    }
  }
  updateHistoryDropdown() {
    var _a;
    if (!this.historyDropdown) return;
    this.historyDropdown.empty();
    const activeTab = (_a = this.tabManager) == null ? void 0 : _a.getActiveTab();
    const conversationController = activeTab == null ? void 0 : activeTab.controllers.conversationController;
    if (conversationController) {
      conversationController.renderHistoryDropdown(this.historyDropdown, {
        onSelectConversation: async (conversationId) => {
          var _a2, _b, _c, _d, _e, _f;
          const existingTab = this.findTabWithConversation(conversationId);
          if (existingTab) {
            await ((_a2 = this.tabManager) == null ? void 0 : _a2.switchToTab(existingTab.id));
            (_b = this.historyDropdown) == null ? void 0 : _b.removeClass("visible");
            return;
          }
          const crossViewResult = this.plugin.findConversationAcrossViews(conversationId);
          if (crossViewResult && crossViewResult.view !== this) {
            this.plugin.app.workspace.revealLeaf(crossViewResult.view.leaf);
            await ((_c = crossViewResult.view.getTabManager()) == null ? void 0 : _c.switchToTab(crossViewResult.tabId));
            (_d = this.historyDropdown) == null ? void 0 : _d.removeClass("visible");
            return;
          }
          await ((_e = this.tabManager) == null ? void 0 : _e.openConversation(conversationId));
          (_f = this.historyDropdown) == null ? void 0 : _f.removeClass("visible");
        }
      });
    }
  }
  findTabWithConversation(conversationId) {
    var _a, _b, _c;
    const tabs = (_b = (_a = this.tabManager) == null ? void 0 : _a.getAllTabs()) != null ? _b : [];
    return (_c = tabs.find((tab) => tab.conversationId === conversationId)) != null ? _c : null;
  }
  // ============================================
  // Event Wiring
  // ============================================
  wireEventHandlers() {
    this.registerDomEvent(document, "click", () => {
      var _a;
      (_a = this.historyDropdown) == null ? void 0 : _a.removeClass("visible");
    });
    this.registerDomEvent(document, "keydown", (e) => {
      var _a, _b;
      if (e.key === "Escape" && !e.isComposing) {
        const activeTab = (_a = this.tabManager) == null ? void 0 : _a.getActiveTab();
        if (activeTab == null ? void 0 : activeTab.state.isStreaming) {
          e.preventDefault();
          (_b = activeTab.controllers.inputController) == null ? void 0 : _b.cancelStreaming();
        }
      }
    });
    const createRef = this.plugin.app.vault.on("create", () => {
      var _a, _b, _c;
      (_c = (_b = (_a = this.tabManager) == null ? void 0 : _a.getActiveTab()) == null ? void 0 : _b.ui.fileContextManager) == null ? void 0 : _c.markFilesCacheDirty();
    });
    this.eventRefs.push(createRef);
    const deleteRef = this.plugin.app.vault.on("delete", () => {
      var _a, _b, _c;
      (_c = (_b = (_a = this.tabManager) == null ? void 0 : _a.getActiveTab()) == null ? void 0 : _b.ui.fileContextManager) == null ? void 0 : _c.markFilesCacheDirty();
    });
    this.eventRefs.push(deleteRef);
    const renameRef = this.plugin.app.vault.on("rename", () => {
      var _a, _b, _c;
      (_c = (_b = (_a = this.tabManager) == null ? void 0 : _a.getActiveTab()) == null ? void 0 : _b.ui.fileContextManager) == null ? void 0 : _c.markFilesCacheDirty();
    });
    this.eventRefs.push(renameRef);
    const modifyRef = this.plugin.app.vault.on("modify", () => {
      var _a, _b, _c;
      (_c = (_b = (_a = this.tabManager) == null ? void 0 : _a.getActiveTab()) == null ? void 0 : _b.ui.fileContextManager) == null ? void 0 : _c.markFilesCacheDirty();
    });
    this.eventRefs.push(modifyRef);
    this.registerEvent(
      this.plugin.app.workspace.on("file-open", (file) => {
        var _a, _b, _c;
        if (file) {
          (_c = (_b = (_a = this.tabManager) == null ? void 0 : _a.getActiveTab()) == null ? void 0 : _b.ui.fileContextManager) == null ? void 0 : _c.handleFileOpen(file);
        }
      })
    );
    this.registerDomEvent(document, "click", (e) => {
      var _a;
      const activeTab = (_a = this.tabManager) == null ? void 0 : _a.getActiveTab();
      if (activeTab) {
        const fcm = activeTab.ui.fileContextManager;
        if (fcm && !fcm.containsElement(e.target) && e.target !== activeTab.dom.inputEl) {
          fcm.hideMentionDropdown();
        }
      }
    });
  }
  // ============================================
  // Persistence
  // ============================================
  async restoreOrCreateTabs() {
    if (!this.tabManager) return;
    const persistedState = await this.plugin.storage.getTabManagerState();
    if (persistedState && persistedState.openTabs.length > 0) {
      await this.tabManager.restoreState(persistedState);
      await this.plugin.storage.clearLegacyActiveConversationId();
      return;
    }
    const legacyActiveId = await this.plugin.storage.getLegacyActiveConversationId();
    if (legacyActiveId) {
      const conversation = await this.plugin.getConversationById(legacyActiveId);
      if (conversation) {
        await this.tabManager.createTab(conversation.id);
      } else {
        await this.tabManager.createTab();
      }
      await this.plugin.storage.clearLegacyActiveConversationId();
      return;
    }
    await this.tabManager.createTab();
    await this.plugin.storage.clearLegacyActiveConversationId();
  }
  persistTabState() {
    if (this.pendingPersist !== null) {
      clearTimeout(this.pendingPersist);
    }
    this.pendingPersist = setTimeout(() => {
      this.pendingPersist = null;
      if (!this.tabManager) return;
      const state = this.tabManager.getPersistedState();
      this.plugin.storage.setTabManagerState(state).catch(() => {
      });
    }, 300);
  }
  /** Force immediate persistence (for onClose/onunload). */
  async persistTabStateImmediate() {
    if (this.pendingPersist !== null) {
      clearTimeout(this.pendingPersist);
      this.pendingPersist = null;
    }
    if (!this.tabManager) return;
    const state = this.tabManager.getPersistedState();
    await this.plugin.storage.setTabManagerState(state);
  }
  // ============================================
  // Public API
  // ============================================
  /** Gets the currently active tab. */
  getActiveTab() {
    var _a, _b;
    return (_b = (_a = this.tabManager) == null ? void 0 : _a.getActiveTab()) != null ? _b : null;
  }
  /** Gets the tab manager. */
  getTabManager() {
    return this.tabManager;
  }
};

// src/features/inline-edit/ui/InlineEditModal.ts
var import_obsidian21 = require("obsidian");

// src/utils/inlineEdit.ts
function normalizeInsertionText(text) {
  return text.replace(/^(?:\r?\n)+|(?:\r?\n)+$/g, "");
}
function escapeHtml2(text) {
  return text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

// src/core/prompts/inlineEdit.ts
function getInlineEditSystemPrompt() {
  return `Today is ${getTodayDate()}.

You are **Claudian**, an expert editor and writing assistant embedded in Obsidian. You help users refine their text, answer questions, and generate content with high precision.

## Core Directives

1.  **Style Matching**: Mimic the user's tone, voice, and formatting style (indentation, bullet points, capitalization).
2.  **Context Awareness**: Always Read the full file (or significant context) to understand the broader topic before editing. Do not rely solely on the selection.
3.  **Silent Execution**: Use tools (Read, WebSearch) silently. Your final output must be ONLY the result.
4.  **No Fluff**: No pleasantries, no "Here is the text", no "I have updated...". Just the content.

## Input Format

User messages use XML tags:

### Selection Mode
\`\`\`xml
<editor_selection path="path/to/file.md">
selected text here
</editor_selection>

<query>
user's instruction
</query>
\`\`\`
Use \`<replacement>\` tags for edits.

### Cursor Mode
\`\`\`xml
<editor_cursor path="path/to/file.md">
text before|text after #inline
</editor_cursor>
\`\`\`
Or between paragraphs:
\`\`\`xml
<editor_cursor path="path/to/file.md">
Previous paragraph
| #inbetween
Next paragraph
</editor_cursor>
\`\`\`
Use \`<insertion>\` tags to insert new content at the cursor position (\`|\`).

## Tools & Path Rules

- **Tools**: Read, Grep, Glob, LS, WebSearch, WebFetch. (All read-only).
- **Paths**: Must be RELATIVE to vault root (e.g., "notes/file.md").

## Thinking Process

Before generating the final output, mentally check:
1.  **Context**: Have I read enough of the file to understand the *topic* and *structure*?
2.  **Style**: What is the user's indentation (2 vs 4 spaces, tabs)? What is their tone?
3.  **Type**: Is this **Prose** (flow, grammar, clarity) or **Code** (syntax, logic, variable names)?
    - *Prose*: Ensure smooth transitions.
    - *Code*: Preserve syntax validity; do not break surrounding brackets/indentation.

## Output Rules - CRITICAL

**ABSOLUTE RULE**: Your text output must contain ONLY the final answer, replacement, or insertion. NEVER output:
- "I'll read the file..." / "Let me check..." / "I will..."
- "I'm asked about..." / "The user wants..."
- "Based on my analysis..." / "After reading..."
- "Here's..." / "The answer is..."
- ANY announcement of what you're about to do or did

Use tools silently. Your text output = final result only.

### When Replacing Selected Text (Selection Mode)

If the user wants to MODIFY or REPLACE the selected text, wrap the replacement in <replacement> tags:

<replacement>your replacement text here</replacement>

The content inside the tags should be ONLY the replacement text - no explanation.

### When Inserting at Cursor (Cursor Mode)

If the user wants to INSERT new content at the cursor position, wrap the insertion in <insertion> tags:

<insertion>your inserted text here</insertion>

The content inside the tags should be ONLY the text to insert - no explanation.

### When Answering Questions or Providing Information

If the user is asking a QUESTION, respond WITHOUT tags. Output the answer directly.

WRONG: "I'll read the full context of this file to give you a better explanation. This is a guide about..."
CORRECT: "This is a guide about..."

### When Clarification is Needed

If the request is ambiguous, ask a clarifying question. Keep questions concise and specific.

## Examples

### Selection Mode
Input:
\`\`\`xml
<editor_selection path="notes/readme.md">
Hello world
</editor_selection>

<query>
translate to French
</query>
\`\`\`

CORRECT (replacement):
<replacement>Bonjour le monde</replacement>

Input:
\`\`\`xml
<editor_selection path="notes/code.md">
const x = arr.reduce((a, b) => a + b, 0);
</editor_selection>

<query>
what does this do?
</query>
\`\`\`

CORRECT (question - no tags):
This code sums all numbers in the array \`arr\`. It uses \`reduce\` to iterate through the array, accumulating the total starting from 0.

### Cursor Mode

Input:
\`\`\`xml
<editor_cursor path="notes/draft.md">
The quick brown | jumps over the lazy dog. #inline
</editor_cursor>

<query>
what animal?
</query>
\`\`\`

CORRECT (insertion):
<insertion>fox</insertion>

### Q&A
Input:
\`\`\`xml
<editor_cursor path="notes/readme.md">
# Introduction
This is my project.
| #inbetween
## Features
</editor_cursor>

<query>
add a brief description section
</query>
\`\`\`

CORRECT (insertion):
<insertion>
## Description

This project provides tools for managing your notes efficiently.
</insertion>

Input:
\`\`\`xml
<editor_selection path="notes/draft.md">
The bank was steep.
</editor_selection>

<query>
translate to Spanish
</query>
\`\`\`

CORRECT (asking for clarification):
"Bank" can mean a financial institution (banco) or a river bank (orilla). Which meaning should I use?

Then after user clarifies "river bank":
<replacement>La orilla era empinada.</replacement>`;
}

// src/features/inline-edit/InlineEditService.ts
var InlineEditService = class {
  constructor(plugin) {
    this.abortController = null;
    this.sessionId = null;
    this.plugin = plugin;
  }
  /** Resets conversation state for a new edit session. */
  resetConversation() {
    this.sessionId = null;
  }
  /** Edits text according to instructions (initial request). */
  async editText(request) {
    this.sessionId = null;
    const prompt = this.buildPrompt(request);
    return this.sendMessage(prompt);
  }
  /** Continues conversation with a follow-up message. */
  async continueConversation(message, contextFiles) {
    if (!this.sessionId) {
      return { success: false, error: "No active conversation to continue" };
    }
    let prompt = message;
    if (contextFiles && contextFiles.length > 0) {
      prompt = prependContextFiles(message, contextFiles);
    }
    return this.sendMessage(prompt);
  }
  async sendMessage(prompt) {
    var _a;
    const vaultPath = getVaultPath(this.plugin.app);
    if (!vaultPath) {
      return { success: false, error: "Could not determine vault path" };
    }
    const resolvedClaudePath = this.plugin.getResolvedClaudeCliPath();
    if (!resolvedClaudePath) {
      return { success: false, error: "Claude CLI not found. Please install Claude Code CLI." };
    }
    this.abortController = new AbortController();
    const customEnv = parseEnvironmentVariables(this.plugin.getActiveEnvironmentVariables());
    const options = {
      cwd: vaultPath,
      systemPrompt: getInlineEditSystemPrompt(),
      model: this.plugin.settings.model,
      abortController: this.abortController,
      pathToClaudeCodeExecutable: resolvedClaudePath,
      env: {
        ...process.env,
        ...customEnv,
        PATH: getEnhancedPath(customEnv.PATH, resolvedClaudePath)
      },
      tools: [...READ_ONLY_TOOLS],
      // Only read-only tools needed
      permissionMode: "bypassPermissions",
      allowDangerouslySkipPermissions: true,
      settingSources: this.plugin.settings.loadUserClaudeSettings ? ["user", "project"] : ["project"],
      hooks: {
        PreToolUse: [
          this.createReadOnlyHook(),
          this.createVaultRestrictionHook(vaultPath)
        ]
      }
    };
    if (this.sessionId) {
      options.resume = this.sessionId;
    }
    const budgetSetting = this.plugin.settings.thinkingBudget;
    const budgetConfig = THINKING_BUDGETS.find((b) => b.value === budgetSetting);
    if (budgetConfig && budgetConfig.tokens > 0) {
      options.maxThinkingTokens = budgetConfig.tokens;
    }
    try {
      const response = query({ prompt, options });
      let responseText = "";
      for await (const message of response) {
        if ((_a = this.abortController) == null ? void 0 : _a.signal.aborted) {
          await response.interrupt();
          return { success: false, error: "Cancelled" };
        }
        if (message.type === "system" && message.subtype === "init" && message.session_id) {
          this.sessionId = message.session_id;
        }
        const text = this.extractTextFromMessage(message);
        if (text) {
          responseText += text;
        }
      }
      return this.parseResponse(responseText);
    } catch (error2) {
      const msg = error2 instanceof Error ? error2.message : "Unknown error";
      return { success: false, error: msg };
    } finally {
      this.abortController = null;
    }
  }
  /** Parses response text for <replacement> or <insertion> tag. */
  parseResponse(responseText) {
    const replacementMatch = responseText.match(/<replacement>([\s\S]*?)<\/replacement>/);
    if (replacementMatch) {
      return { success: true, editedText: replacementMatch[1] };
    }
    const insertionMatch = responseText.match(/<insertion>([\s\S]*?)<\/insertion>/);
    if (insertionMatch) {
      return { success: true, insertedText: insertionMatch[1] };
    }
    const trimmed = responseText.trim();
    if (trimmed) {
      return { success: true, clarification: trimmed };
    }
    return { success: false, error: "Empty response" };
  }
  buildPrompt(request) {
    let prompt;
    if (request.mode === "cursor") {
      prompt = this.buildCursorPrompt(request);
    } else {
      const lineAttr = request.startLine && request.lineCount ? ` lines="${request.startLine}-${request.startLine + request.lineCount - 1}"` : "";
      prompt = [
        `<editor_selection path="${request.notePath}"${lineAttr}>`,
        request.selectedText,
        "</editor_selection>",
        "",
        "<query>",
        request.instruction,
        "</query>"
      ].join("\n");
    }
    if (request.contextFiles && request.contextFiles.length > 0) {
      prompt = prependContextFiles(prompt, request.contextFiles);
    }
    return prompt;
  }
  buildCursorPrompt(request) {
    const ctx = request.cursorContext;
    const lineAttr = ` line="${ctx.line + 1}"`;
    let cursorContent;
    if (ctx.isInbetween) {
      const parts = [];
      if (ctx.beforeCursor) parts.push(ctx.beforeCursor);
      parts.push("| #inbetween");
      if (ctx.afterCursor) parts.push(ctx.afterCursor);
      cursorContent = parts.join("\n");
    } else {
      cursorContent = `${ctx.beforeCursor}|${ctx.afterCursor} #inline`;
    }
    return [
      `<editor_cursor path="${request.notePath}"${lineAttr}>`,
      cursorContent,
      "</editor_cursor>",
      "",
      "<query>",
      request.instruction,
      "</query>"
    ].join("\n");
  }
  /** Creates PreToolUse hook to enforce read-only mode. */
  createReadOnlyHook() {
    return {
      hooks: [
        async (hookInput) => {
          const input = hookInput;
          const toolName = input.tool_name;
          if (isReadOnlyTool(toolName)) {
            return { continue: true };
          }
          return {
            continue: false,
            hookSpecificOutput: {
              hookEventName: "PreToolUse",
              permissionDecision: "deny",
              permissionDecisionReason: `Inline edit mode: tool "${toolName}" is not allowed (read-only)`
            }
          };
        }
      ]
    };
  }
  /** Creates PreToolUse hook to restrict file tools to allowed paths. */
  createVaultRestrictionHook(vaultPath) {
    const fileTools = [TOOL_READ, TOOL_GLOB, TOOL_GREP, TOOL_LS];
    return {
      hooks: [
        async (hookInput) => {
          const input = hookInput;
          const toolName = input.tool_name;
          if (!fileTools.includes(toolName)) {
            return { continue: true };
          }
          const filePath = getPathFromToolInput(toolName, input.tool_input);
          if (!filePath) {
            return {
              continue: false,
              hookSpecificOutput: {
                hookEventName: "PreToolUse",
                permissionDecision: "deny",
                permissionDecisionReason: `Access denied: Could not determine path for "${toolName}" tool.`
              }
            };
          }
          let accessType;
          try {
            accessType = getPathAccessType(filePath, void 0, void 0, vaultPath);
          } catch (e) {
            return {
              continue: false,
              hookSpecificOutput: {
                hookEventName: "PreToolUse",
                permissionDecision: "deny",
                permissionDecisionReason: `Access denied: Failed to validate path "${filePath}".`
              }
            };
          }
          if (accessType === "vault" || accessType === "context" || accessType === "readwrite") {
            return { continue: true };
          }
          return {
            continue: false,
            hookSpecificOutput: {
              hookEventName: "PreToolUse",
              permissionDecision: "deny",
              permissionDecisionReason: `Access denied: Path "${filePath}" is outside allowed paths. Inline edit is restricted to vault and ~/.claude/ directories.`
            }
          };
        }
      ]
    };
  }
  extractTextFromMessage(message) {
    var _a, _b, _c;
    if (message.type === "assistant" && ((_a = message.message) == null ? void 0 : _a.content)) {
      for (const block of message.message.content) {
        if (block.type === "text" && block.text) {
          return block.text;
        }
      }
    }
    if (message.type === "stream_event") {
      const event = message.event;
      if ((event == null ? void 0 : event.type) === "content_block_start" && ((_b = event.content_block) == null ? void 0 : _b.type) === "text") {
        return event.content_block.text || null;
      }
      if ((event == null ? void 0 : event.type) === "content_block_delta" && ((_c = event.delta) == null ? void 0 : _c.type) === "text_delta") {
        return event.delta.text || null;
      }
    }
    return null;
  }
  /** Cancels the current edit operation. */
  cancel() {
    if (this.abortController) {
      this.abortController.abort();
    }
  }
};

// src/features/inline-edit/ui/InlineEditModal.ts
var import_state3 = require("@codemirror/state");
var import_view2 = require("@codemirror/view");
var showInlineEdit = import_state3.StateEffect.define();
var showDiff = import_state3.StateEffect.define();
var showInsertion = import_state3.StateEffect.define();
var hideInlineEdit = import_state3.StateEffect.define();
var activeController = null;
var DiffWidget = class extends import_view2.WidgetType {
  constructor(diffHtml, controller) {
    super();
    this.diffHtml = diffHtml;
    this.controller = controller;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = "claudian-inline-diff-replace";
    span.innerHTML = this.diffHtml;
    const btns = document.createElement("span");
    btns.className = "claudian-inline-diff-buttons";
    const rejectBtn = document.createElement("button");
    rejectBtn.className = "claudian-inline-diff-btn reject";
    rejectBtn.textContent = "\u2715";
    rejectBtn.title = "Reject (Esc)";
    rejectBtn.onclick = () => this.controller.reject();
    const acceptBtn = document.createElement("button");
    acceptBtn.className = "claudian-inline-diff-btn accept";
    acceptBtn.textContent = "\u2713";
    acceptBtn.title = "Accept (Enter)";
    acceptBtn.onclick = () => this.controller.accept();
    btns.appendChild(rejectBtn);
    btns.appendChild(acceptBtn);
    span.appendChild(btns);
    return span;
  }
  eq(other) {
    return this.diffHtml === other.diffHtml;
  }
  ignoreEvent() {
    return true;
  }
};
var InputWidget = class extends import_view2.WidgetType {
  constructor(controller) {
    super();
    this.controller = controller;
  }
  toDOM() {
    return this.controller.createInputDOM();
  }
  eq() {
    return false;
  }
  ignoreEvent() {
    return true;
  }
};
var inlineEditField = import_state3.StateField.define({
  create: () => import_view2.Decoration.none,
  update: (deco, tr) => {
    var _a;
    deco = deco.map(tr.changes);
    for (const e of tr.effects) {
      if (e.is(showInlineEdit)) {
        const builder = new import_state3.RangeSetBuilder();
        const isInbetween = (_a = e.value.isInbetween) != null ? _a : false;
        builder.add(e.value.inputPos, e.value.inputPos, import_view2.Decoration.widget({
          widget: new InputWidget(e.value.widget),
          block: !isInbetween,
          side: isInbetween ? 1 : -1
        }));
        deco = builder.finish();
      } else if (e.is(showDiff)) {
        const builder = new import_state3.RangeSetBuilder();
        builder.add(e.value.from, e.value.to, import_view2.Decoration.replace({
          widget: new DiffWidget(e.value.diffHtml, e.value.widget)
        }));
        deco = builder.finish();
      } else if (e.is(showInsertion)) {
        const builder = new import_state3.RangeSetBuilder();
        builder.add(e.value.pos, e.value.pos, import_view2.Decoration.widget({
          widget: new DiffWidget(e.value.diffHtml, e.value.widget),
          side: 1
          // Display after the position
        }));
        deco = builder.finish();
      } else if (e.is(hideInlineEdit)) {
        deco = import_view2.Decoration.none;
      }
    }
    return deco;
  },
  provide: (f) => import_view2.EditorView.decorations.from(f)
});
var installedEditors = /* @__PURE__ */ new WeakSet();
function computeDiff(oldText, newText) {
  const oldWords = oldText.split(/(\s+)/);
  const newWords = newText.split(/(\s+)/);
  const m = oldWords.length, n = newWords.length;
  const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
  for (let i2 = 1; i2 <= m; i2++) {
    for (let j2 = 1; j2 <= n; j2++) {
      dp[i2][j2] = oldWords[i2 - 1] === newWords[j2 - 1] ? dp[i2 - 1][j2 - 1] + 1 : Math.max(dp[i2 - 1][j2], dp[i2][j2 - 1]);
    }
  }
  const ops = [];
  let i = m, j = n;
  const temp = [];
  while (i > 0 || j > 0) {
    if (i > 0 && j > 0 && oldWords[i - 1] === newWords[j - 1]) {
      temp.push({ type: "equal", text: oldWords[i - 1] });
      i--;
      j--;
    } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
      temp.push({ type: "insert", text: newWords[j - 1] });
      j--;
    } else {
      temp.push({ type: "delete", text: oldWords[i - 1] });
      i--;
    }
  }
  temp.reverse();
  for (const op of temp) {
    if (ops.length > 0 && ops[ops.length - 1].type === op.type) {
      ops[ops.length - 1].text += op.text;
    } else {
      ops.push({ ...op });
    }
  }
  return ops;
}
function diffToHtml(ops) {
  return ops.map((op) => {
    const escaped = escapeHtml2(op.text);
    switch (op.type) {
      case "delete":
        return `<span class="claudian-diff-del">${escaped}</span>`;
      case "insert":
        return `<span class="claudian-diff-ins">${escaped}</span>`;
      default:
        return escaped;
    }
  }).join("");
}
var InlineEditModal = class {
  constructor(app, plugin, editContext, notePath) {
    this.app = app;
    this.plugin = plugin;
    this.editContext = editContext;
    this.notePath = notePath;
    this.controller = null;
  }
  async openAndWait() {
    if (activeController) {
      activeController.reject();
      return { decision: "reject" };
    }
    const view = this.app.workspace.getActiveViewOfType(import_obsidian21.MarkdownView);
    if (!view) return { decision: "reject" };
    const editor = view.editor;
    const editorView = getEditorView(editor);
    if (!editorView) return { decision: "reject" };
    return new Promise((resolve3) => {
      this.controller = new InlineEditController(
        this.app,
        this.plugin,
        editorView,
        editor,
        this.editContext,
        this.notePath,
        resolve3
      );
      activeController = this.controller;
      this.controller.show();
    });
  }
};
var InlineEditController = class {
  constructor(app, plugin, editorView, editor, editContext, notePath, resolve3) {
    this.app = app;
    this.plugin = plugin;
    this.editorView = editorView;
    this.editor = editor;
    this.notePath = notePath;
    this.resolve = resolve3;
    this.inputEl = null;
    this.spinnerEl = null;
    this.agentReplyEl = null;
    this.containerEl = null;
    this.editedText = null;
    this.insertedText = null;
    this.startLine = 0;
    this.cursorContext = null;
    this.escHandler = null;
    this.selectionListener = null;
    this.isConversing = false;
    // True when agent asked clarification
    this.slashCommandManager = null;
    this.slashCommandDropdown = null;
    this.mentionDropdown = null;
    this.attachedFiles = /* @__PURE__ */ new Set();
    this.inlineEditService = new InlineEditService(plugin);
    this.mode = editContext.mode;
    if (editContext.mode === "cursor") {
      this.cursorContext = editContext.cursorContext;
      this.selectedText = "";
    } else {
      this.selectedText = editContext.selectedText;
    }
    this.updatePositionsFromEditor();
  }
  updatePositionsFromEditor() {
    const doc = this.editorView.state.doc;
    if (this.mode === "cursor") {
      const ctx = this.cursorContext;
      const line = doc.line(ctx.line + 1);
      this.selFrom = line.from + ctx.column;
      this.selTo = this.selFrom;
    } else {
      const from = this.editor.getCursor("from");
      const to = this.editor.getCursor("to");
      const fromLine = doc.line(from.line + 1);
      const toLine = doc.line(to.line + 1);
      this.selFrom = fromLine.from + from.ch;
      this.selTo = toLine.from + to.ch;
      this.selectedText = this.editor.getSelection() || this.selectedText;
      this.startLine = from.line + 1;
    }
  }
  show() {
    if (!installedEditors.has(this.editorView)) {
      this.editorView.dispatch({
        effects: import_state3.StateEffect.appendConfig.of(inlineEditField)
      });
      installedEditors.add(this.editorView);
    }
    this.updateHighlight();
    if (this.mode === "selection") {
      this.attachSelectionListeners();
    }
    this.escHandler = (e) => {
      if (e.key === "Escape" && !e.isComposing) {
        this.reject();
      }
    };
    document.addEventListener("keydown", this.escHandler);
  }
  updateHighlight() {
    var _a;
    const doc = this.editorView.state.doc;
    const line = doc.lineAt(this.selFrom);
    const isInbetween = this.mode === "cursor" && ((_a = this.cursorContext) == null ? void 0 : _a.isInbetween);
    this.editorView.dispatch({
      effects: showInlineEdit.of({
        inputPos: isInbetween ? this.selFrom : line.from,
        selFrom: this.selFrom,
        selTo: this.selTo,
        widget: this,
        isInbetween
      })
    });
    this.updateSelectionHighlight();
  }
  updateSelectionHighlight() {
    if (this.mode === "selection" && this.selFrom !== this.selTo) {
      showSelectionHighlight(this.editorView, this.selFrom, this.selTo);
    } else {
      hideSelectionHighlight(this.editorView);
    }
  }
  attachSelectionListeners() {
    this.removeSelectionListeners();
    this.selectionListener = (e) => {
      const target = e.target;
      if (target && this.inputEl && (target === this.inputEl || this.inputEl.contains(target))) {
        return;
      }
      const prevFrom = this.selFrom;
      const prevTo = this.selTo;
      const newSelection = this.editor.getSelection();
      if (newSelection && newSelection.length > 0) {
        this.updatePositionsFromEditor();
        if (prevFrom !== this.selFrom || prevTo !== this.selTo) {
          this.updateHighlight();
        }
      }
    };
    this.editorView.dom.addEventListener("mouseup", this.selectionListener);
    this.editorView.dom.addEventListener("keyup", this.selectionListener);
  }
  createInputDOM() {
    const container = document.createElement("div");
    container.className = "claudian-inline-input-container";
    this.containerEl = container;
    this.agentReplyEl = document.createElement("div");
    this.agentReplyEl.className = "claudian-inline-agent-reply";
    this.agentReplyEl.style.display = "none";
    container.appendChild(this.agentReplyEl);
    const inputWrap = document.createElement("div");
    inputWrap.className = "claudian-inline-input-wrap";
    container.appendChild(inputWrap);
    this.inputEl = document.createElement("input");
    this.inputEl.type = "text";
    this.inputEl.className = "claudian-inline-input";
    this.inputEl.placeholder = this.mode === "cursor" ? "Insert instructions..." : "Edit instructions...";
    this.inputEl.spellcheck = false;
    inputWrap.appendChild(this.inputEl);
    this.spinnerEl = document.createElement("div");
    this.spinnerEl.className = "claudian-inline-spinner";
    this.spinnerEl.style.display = "none";
    inputWrap.appendChild(this.spinnerEl);
    const vaultPath = getVaultPath(this.app);
    if (vaultPath) {
      this.slashCommandManager = new SlashCommandManager(this.app, vaultPath);
      this.slashCommandManager.setCommands(this.plugin.settings.slashCommands);
      this.slashCommandDropdown = new SlashCommandDropdown(
        document.body,
        // Use body for fixed positioning
        this.inputEl,
        {
          onSelect: () => {
          },
          onHide: () => {
          },
          getCommands: () => this.plugin.settings.slashCommands
        },
        { fixed: true }
      );
    }
    this.mentionDropdown = new MentionDropdownController(
      document.body,
      this.inputEl,
      {
        onAttachFile: (filePath) => this.attachedFiles.add(filePath),
        onMcpMentionChange: () => {
        },
        getMentionedMcpServers: () => /* @__PURE__ */ new Set(),
        setMentionedMcpServers: () => false,
        addMentionedMcpServer: () => {
        },
        getExternalContexts: () => [],
        getCachedMarkdownFiles: () => {
          try {
            return this.app.vault.getMarkdownFiles();
          } catch (e) {
            return [];
          }
        },
        normalizePathForVault: (rawPath) => this.normalizePathForVault(rawPath)
      },
      { fixed: true }
    );
    this.inputEl.addEventListener("keydown", (e) => this.handleKeydown(e));
    this.inputEl.addEventListener("input", () => {
      var _a;
      return (_a = this.mentionDropdown) == null ? void 0 : _a.handleInputChange();
    });
    setTimeout(() => {
      var _a;
      return (_a = this.inputEl) == null ? void 0 : _a.focus();
    }, 50);
    return container;
  }
  async generate() {
    if (!this.inputEl || !this.spinnerEl) return;
    let userMessage = this.inputEl.value.trim();
    if (!userMessage) return;
    if (this.slashCommandManager) {
      this.slashCommandManager.setCommands(this.plugin.settings.slashCommands);
      const detected = this.slashCommandManager.detectCommand(userMessage);
      if (detected) {
        const cmd = this.plugin.settings.slashCommands.find(
          (c) => c.name.toLowerCase() === detected.commandName.toLowerCase()
        );
        if (cmd) {
          const expansion = await this.slashCommandManager.expandCommand(cmd, detected.args, {
            bash: {
              enabled: true,
              shouldBlockCommand: (bashCommand) => isCommandBlocked(
                bashCommand,
                getBashToolBlockedCommands(this.plugin.settings.blockedCommands),
                this.plugin.settings.enableBlocklist
              ),
              requestApproval: this.plugin.settings.permissionMode !== "yolo" ? (bashCommand) => this.requestInlineBashApproval(bashCommand) : void 0
            }
          });
          userMessage = expansion.expandedPrompt;
          if (expansion.errors.length > 0) {
            new import_obsidian21.Notice(formatSlashCommandWarnings(expansion.errors));
          }
        }
      }
    }
    this.removeSelectionListeners();
    this.inputEl.disabled = true;
    this.spinnerEl.style.display = "block";
    const contextFiles = Array.from(this.attachedFiles);
    this.attachedFiles.clear();
    let result;
    if (this.isConversing) {
      result = await this.inlineEditService.continueConversation(userMessage, contextFiles);
    } else {
      if (this.mode === "cursor") {
        result = await this.inlineEditService.editText({
          mode: "cursor",
          instruction: userMessage,
          notePath: this.notePath,
          cursorContext: this.cursorContext,
          contextFiles
        });
      } else {
        const lineCount = this.selectedText.split(/\r?\n/).length;
        result = await this.inlineEditService.editText({
          mode: "selection",
          instruction: userMessage,
          notePath: this.notePath,
          selectedText: this.selectedText,
          startLine: this.startLine,
          lineCount,
          contextFiles
        });
      }
    }
    this.spinnerEl.style.display = "none";
    if (result.success) {
      if (result.editedText !== void 0) {
        this.editedText = result.editedText;
        this.showDiffInPlace();
      } else if (result.insertedText !== void 0) {
        this.insertedText = result.insertedText;
        this.showInsertionInPlace();
      } else if (result.clarification) {
        this.showAgentReply(result.clarification);
        this.isConversing = true;
        this.inputEl.disabled = false;
        this.inputEl.value = "";
        this.inputEl.placeholder = "Reply to continue...";
        this.inputEl.focus();
      } else {
        this.handleError("No response from agent");
      }
    } else {
      this.handleError(result.error || "Error - try again");
    }
  }
  /** Show agent's clarification message. */
  showAgentReply(message) {
    if (!this.agentReplyEl || !this.containerEl) return;
    this.agentReplyEl.style.display = "block";
    this.agentReplyEl.textContent = message;
    this.containerEl.classList.add("has-agent-reply");
  }
  /** Handle error state. */
  handleError(errorMessage) {
    if (!this.inputEl) return;
    this.inputEl.disabled = false;
    this.inputEl.placeholder = errorMessage;
    this.updatePositionsFromEditor();
    this.updateHighlight();
    this.attachSelectionListeners();
    this.inputEl.focus();
  }
  showDiffInPlace() {
    if (this.editedText === null) return;
    hideSelectionHighlight(this.editorView);
    const diffOps = computeDiff(this.selectedText, this.editedText);
    const diffHtml = diffToHtml(diffOps);
    this.editorView.dispatch({
      effects: showDiff.of({
        from: this.selFrom,
        to: this.selTo,
        diffHtml,
        widget: this
      })
    });
    if (this.escHandler) {
      document.removeEventListener("keydown", this.escHandler);
    }
    this.escHandler = (e) => {
      if (e.key === "Escape" && !e.isComposing) {
        this.reject();
      } else if (e.key === "Enter" && !e.isComposing) {
        this.accept();
      }
    };
    document.addEventListener("keydown", this.escHandler);
  }
  /** Show insertion preview (all green, no deletions) for cursor mode. */
  showInsertionInPlace() {
    if (this.insertedText === null) return;
    hideSelectionHighlight(this.editorView);
    const trimmedText = normalizeInsertionText(this.insertedText);
    this.insertedText = trimmedText;
    const escaped = escapeHtml2(trimmedText);
    const diffHtml = `<span class="claudian-diff-ins">${escaped}</span>`;
    this.editorView.dispatch({
      effects: showInsertion.of({
        pos: this.selFrom,
        diffHtml,
        widget: this
      })
    });
    if (this.escHandler) {
      document.removeEventListener("keydown", this.escHandler);
    }
    this.escHandler = (e) => {
      if (e.key === "Escape" && !e.isComposing) {
        this.reject();
      } else if (e.key === "Enter" && !e.isComposing) {
        this.accept();
      }
    };
    document.addEventListener("keydown", this.escHandler);
  }
  accept() {
    var _a;
    const textToInsert = (_a = this.editedText) != null ? _a : this.insertedText;
    if (textToInsert !== null) {
      const doc = this.editorView.state.doc;
      const fromLine = doc.lineAt(this.selFrom);
      const toLine = doc.lineAt(this.selTo);
      const from = { line: fromLine.number - 1, ch: this.selFrom - fromLine.from };
      const to = { line: toLine.number - 1, ch: this.selTo - toLine.from };
      this.cleanup();
      this.editor.replaceRange(textToInsert, from, to);
      this.resolve({ decision: "accept", editedText: textToInsert });
    } else {
      this.cleanup();
      this.resolve({ decision: "reject" });
    }
  }
  reject() {
    this.cleanup({ keepSelectionHighlight: true });
    this.restoreSelectionHighlight();
    this.resolve({ decision: "reject" });
  }
  removeSelectionListeners() {
    if (this.selectionListener) {
      this.editorView.dom.removeEventListener("mouseup", this.selectionListener);
      this.editorView.dom.removeEventListener("keyup", this.selectionListener);
      this.selectionListener = null;
    }
  }
  cleanup(options) {
    var _a, _b;
    this.inlineEditService.cancel();
    this.inlineEditService.resetConversation();
    this.isConversing = false;
    this.removeSelectionListeners();
    if (this.escHandler) {
      document.removeEventListener("keydown", this.escHandler);
    }
    (_a = this.slashCommandDropdown) == null ? void 0 : _a.destroy();
    this.slashCommandDropdown = null;
    this.slashCommandManager = null;
    (_b = this.mentionDropdown) == null ? void 0 : _b.destroy();
    this.mentionDropdown = null;
    this.attachedFiles.clear();
    if (activeController === this) {
      activeController = null;
    }
    this.editorView.dispatch({
      effects: hideInlineEdit.of(null)
    });
    if (!(options == null ? void 0 : options.keepSelectionHighlight)) {
      hideSelectionHighlight(this.editorView);
    }
  }
  restoreSelectionHighlight() {
    if (this.mode !== "selection" || this.selFrom === this.selTo) {
      return;
    }
    showSelectionHighlight(this.editorView, this.selFrom, this.selTo);
  }
  handleKeydown(e) {
    var _a, _b;
    if ((_a = this.mentionDropdown) == null ? void 0 : _a.handleKeydown(e)) {
      return;
    }
    if ((_b = this.slashCommandDropdown) == null ? void 0 : _b.handleKeydown(e)) {
      return;
    }
    if (e.key === "Enter" && !e.isComposing) {
      e.preventDefault();
      this.generate();
    }
  }
  normalizePathForVault(rawPath) {
    try {
      const vaultPath = getVaultPath(this.app);
      return normalizePathForVault(rawPath, vaultPath);
    } catch (e) {
      new import_obsidian21.Notice("Failed to attach file: invalid path");
      return null;
    }
  }
  async requestInlineBashApproval(command) {
    const description = `Execute inline bash command:
${command}`;
    return new Promise((resolve3) => {
      const modal = new ApprovalModal(
        this.app,
        TOOL_BASH,
        { command },
        description,
        (decision) => resolve3(decision === "allow" || decision === "allow-always"),
        { showAlwaysAllow: false, title: "Inline bash execution" }
      );
      modal.open();
    });
  }
};

// src/features/settings/ClaudianSettings.ts
var fs8 = __toESM(require("fs"));
var import_obsidian28 = require("obsidian");

// src/i18n/locales/de.json
var de_exports = {};
__export(de_exports, {
  common: () => common,
  default: () => de_default,
  settings: () => settings
});
var common = {
  save: "Speichern",
  cancel: "Abbrechen",
  delete: "L\xF6schen",
  edit: "Bearbeiten",
  add: "Hinzuf\xFCgen",
  remove: "Entfernen",
  clear: "L\xF6schen",
  clearAll: "Alle l\xF6schen",
  loading: "L\xE4dt",
  error: "Fehler",
  success: "Erfolg",
  warning: "Warnung",
  confirm: "Best\xE4tigen",
  settings: "Einstellungen",
  advanced: "Erweitert",
  enabled: "Aktiviert",
  disabled: "Deaktiviert",
  platform: "Plattform"
};
var settings = {
  title: "Claudian Einstellungen",
  customization: "Anpassung",
  userName: {
    name: "Wie soll Claudian dich nennen?",
    desc: "Dein Name f\xFCr personalisierte Begr\xFC\xDFungen (leer lassen f\xFCr allgemeine Begr\xFC\xDFungen)"
  },
  excludedTags: {
    name: "Ausgeschlossene Tags",
    desc: "Notizen mit diesen Tags werden nicht automatisch als Kontext geladen (einer pro Zeile, ohne #)"
  },
  mediaFolder: {
    name: "Medienordner",
    desc: "Ordner mit Anh\xE4ngen/Bildern. Wenn Notizen ![[image.jpg]] verwenden, sucht Claude hier. Leer lassen f\xFCr Vault-Stammverzeichnis."
  },
  systemPrompt: {
    name: "Benutzerdefinierter System-Prompt",
    desc: "Zus\xE4tzliche Anweisungen, die an den Standard-System-Prompt angeh\xE4ngt werden"
  },
  autoTitle: {
    name: "Konversationstitel automatisch generieren",
    desc: "Generiert automatisch Konversationstitel nach dem ersten Austausch."
  },
  titleModel: {
    name: "Titel-Generierungsmodell",
    desc: "Modell zur automatischen Generierung von Konversationstiteln.",
    auto: "Automatisch (Haiku)"
  },
  navMappings: {
    name: "Vim-Style Navigationszuordnungen",
    desc: 'Eine Zuordnung pro Zeile. Format: "map <Taste> <Aktion>" (Aktionen: scrollUp, scrollDown, focusInput).'
  },
  hotkeys: "Tastenk\xFCrzel",
  inlineEditHotkey: {
    name: "Inline-Bearbeitung Tastenk\xFCrzel",
    descNoKey: "Kein Tastenk\xFCrzel festgelegt. Klicken zum Konfigurieren.",
    descWithKey: "Aktuell: {hotkey}",
    btnSet: "Tastenk\xFCrzel festlegen",
    btnChange: "\xC4ndern"
  },
  openChatHotkey: {
    name: "Chat \xF6ffnen Tastenk\xFCrzel",
    descNoKey: "Kein Tastenk\xFCrzel festgelegt. Klicken zum Konfigurieren.",
    descWithKey: "Aktuell: {hotkey}",
    btnSet: "Tastenk\xFCrzel festlegen",
    btnChange: "\xC4ndern"
  },
  newTabHotkey: {
    name: "Neuer Tab Tastenk\xFCrzel",
    descNoKey: "Kein Tastenk\xFCrzel festgelegt. Klicken zum Konfigurieren.",
    descWithKey: "Aktuell: {hotkey}",
    btnSet: "Tastenk\xFCrzel festlegen",
    btnChange: "\xC4ndern"
  },
  newSessionHotkey: {
    name: "Neue Sitzung Tastenk\xFCrzel",
    descNoKey: "Kein Tastenk\xFCrzel festgelegt. Klicken zum Konfigurieren.",
    descWithKey: "Aktuell: {hotkey}",
    btnSet: "Tastenk\xFCrzel festlegen",
    btnChange: "\xC4ndern"
  },
  closeTabHotkey: {
    name: "Tab schlie\xDFen Tastenk\xFCrzel",
    descNoKey: "Kein Tastenk\xFCrzel festgelegt. Klicken zum Konfigurieren.",
    descWithKey: "Aktuell: {hotkey}",
    btnSet: "Tastenk\xFCrzel festlegen",
    btnChange: "\xC4ndern"
  },
  slashCommands: {
    name: "Schr\xE4gstrich-Befehle",
    desc: "Erstelle benutzerdefinierte Prompt-Vorlagen, die durch /command ausgel\xF6st werden. Verwende $ARGUMENTS f\xFCr alle Argumente, $1/$2 f\xFCr Positionsargumente, @file f\xFCr Dateiinhalt und !`bash` f\xFCr Befehlsausgabe."
  },
  mcpServers: {
    name: "MCP-Server",
    desc: "Konfiguriere Model Context Protocol Server, um Claude mit externen Tools und Datenquellen zu erweitern. Server mit Kontext-Speichermodus ben\xF6tigen @mention zur Aktivierung."
  },
  plugins: {
    name: "Claude Code Plugins",
    desc: "Aktiviere oder deaktiviere Claude Code Plugins aus ~/.claude/plugins. Aktivierte Plugins werden pro Vault gespeichert."
  },
  safety: "Sicherheit",
  loadUserSettings: {
    name: "Benutzer-Claude-Einstellungen laden",
    desc: "L\xE4dt ~/.claude/settings.json. Wenn aktiviert, k\xF6nnen Benutzer-Claude-Code-Berechtigungsregeln den Sicherheitsmodus umgehen."
  },
  enableBlocklist: {
    name: "Befehlsblockliste aktivieren",
    desc: "Blockiert potenziell gef\xE4hrliche Bash-Befehle"
  },
  blockedCommands: {
    name: "Blockierte Befehle ({platform})",
    desc: "Muster zum Blockieren auf {platform} (einer pro Zeile). Unterst\xFCtzt Regex.",
    unixName: "Blockierte Befehle (Unix/Git Bash)",
    unixDesc: "Unix-Muster werden auch auf Windows blockiert, da Git Bash sie aufrufen kann."
  },
  exportPaths: {
    name: "Zugelassene Exportpfade",
    desc: "Pfade au\xDFerhalb des Vaults, in die Dateien exportiert werden k\xF6nnen (einer pro Zeile). Unterst\xFCtzt ~ f\xFCr Home-Verzeichnis."
  },
  environment: "Umgebung",
  customVariables: {
    name: "Benutzerdefinierte Variablen",
    desc: "Umgebungsvariablen f\xFCr Claude SDK (KEY=VALUE-Format, eine pro Zeile)"
  },
  envSnippets: {
    name: "Umgebungsvariablen-Snippets",
    addBtn: "Snippet hinzuf\xFCgen",
    editBtn: "Bearbeiten",
    deleteBtn: "L\xF6schen",
    useBtn: "Verwenden",
    noSnippets: "Keine gespeicherten Umgebungsvariablen-Snippets.",
    modal: {
      title: "Umgebungsvariablen-Snippet",
      name: "Name",
      namePlaceholder: "z.B. Produktions-API",
      description: "Beschreibung",
      descPlaceholder: "Optionale Beschreibung",
      envVars: "Umgebungsvariablen",
      envVarsPlaceholder: "ANTHROPIC_API_KEY=your-key\nANTHROPIC_BASE_URL=https://api.example.com",
      save: "Speichern",
      cancel: "Abbrechen"
    }
  },
  advanced: "Erweitert",
  show1MModel: {
    name: "Sonnet mit 1M-Kontextfenster aktivieren",
    desc: "Standard-Sonnet durch Sonnet (1M) in der Modellauswahl ersetzen. Gleiche Preise unter 200k Token. Erfordert Max-Abonnement."
  },
  maxTabs: {
    name: "Maximale Chat-Tabs",
    desc: "Maximale Anzahl gleichzeitiger Chat-Tabs (3-10). Jeder Tab verwendet eine separate Claude-Sitzung.",
    warning: "Mehr als 5 Tabs k\xF6nnen Leistung und Speichernutzung beeintr\xE4chtigen.",
    range: "{min} - {max}"
  },
  cliPath: {
    name: "Claude CLI-Pfad",
    desc: "Benutzerdefinierter Pfad zum Claude Code CLI. Leer lassen f\xFCr automatische Erkennung.",
    descWindows: "F\xFCr den nativen Installer verwenden Sie claude.exe. F\xFCr npm/pnpm/yarn oder andere Paketmanager-Installationen verwenden Sie den cli.js-Pfad (nicht claude.cmd).",
    descUnix: 'F\xFCgen Sie die Ausgabe von "which claude" ein \u2014 funktioniert sowohl f\xFCr native als auch npm/pnpm/yarn-Installationen.',
    validation: {
      notExist: "Pfad existiert nicht",
      isDirectory: "Pfad ist ein Verzeichnis, keine Datei"
    }
  },
  language: {
    name: "Sprache",
    desc: "Anzeigesprache der Plugin-Oberfl\xE4che \xE4ndern",
    en: "English",
    "zh-CN": "\u7B80\u4F53\u4E2D\u6587",
    "zh-TW": "\u7E41\u9AD4\u4E2D\u6587",
    ja: "\u65E5\u672C\u8A9E",
    ko: "\uD55C\uAD6D\uC5B4",
    de: "Deutsch",
    fr: "Fran\xE7ais",
    es: "Espa\xF1ol",
    ru: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439",
    pt: "Portugu\xEAs"
  }
};
var de_default = {
  common,
  settings
};

// src/i18n/locales/en.json
var en_exports = {};
__export(en_exports, {
  common: () => common2,
  default: () => en_default3,
  settings: () => settings2
});
var common2 = {
  save: "Save",
  cancel: "Cancel",
  delete: "Delete",
  edit: "Edit",
  add: "Add",
  remove: "Remove",
  clear: "Clear",
  clearAll: "Clear all",
  loading: "Loading",
  error: "Error",
  success: "Success",
  warning: "Warning",
  confirm: "Confirm",
  settings: "Settings",
  advanced: "Advanced",
  enabled: "Enabled",
  disabled: "Disabled",
  platform: "Platform"
};
var settings2 = {
  title: "Claudian Settings",
  customization: "Customization",
  userName: {
    name: "What should Claudian call you?",
    desc: "Your name for personalized greetings (leave empty for generic greetings)"
  },
  excludedTags: {
    name: "Excluded tags",
    desc: "Notes with these tags will not auto-load as context (one per line, without #)"
  },
  mediaFolder: {
    name: "Media folder",
    desc: "Folder containing attachments/images. When notes use ![[image.jpg]], Claude will look here. Leave empty for vault root."
  },
  systemPrompt: {
    name: "Custom system prompt",
    desc: "Additional instructions appended to the default system prompt"
  },
  autoTitle: {
    name: "Auto-generate conversation titles",
    desc: "Automatically generate conversation titles after the first exchange."
  },
  titleModel: {
    name: "Title generation model",
    desc: "Model used for auto-generating conversation titles.",
    auto: "Auto (Haiku)"
  },
  navMappings: {
    name: "Vim-style navigation mappings",
    desc: 'One mapping per line. Format: "map <key> <action>" (actions: scrollUp, scrollDown, focusInput).'
  },
  hotkeys: "Hotkeys",
  inlineEditHotkey: {
    name: "Inline edit hotkey",
    descNoKey: "No hotkey set. Click to configure.",
    descWithKey: "Current: {hotkey}",
    btnSet: "Set hotkey",
    btnChange: "Change"
  },
  openChatHotkey: {
    name: "Open chat hotkey",
    descNoKey: "No hotkey set. Click to configure.",
    descWithKey: "Current: {hotkey}",
    btnSet: "Set hotkey",
    btnChange: "Change"
  },
  newTabHotkey: {
    name: "New tab hotkey",
    descNoKey: "No hotkey set. Click to configure.",
    descWithKey: "Current: {hotkey}",
    btnSet: "Set hotkey",
    btnChange: "Change"
  },
  newSessionHotkey: {
    name: "New session hotkey",
    descNoKey: "No hotkey set. Click to configure.",
    descWithKey: "Current: {hotkey}",
    btnSet: "Set hotkey",
    btnChange: "Change"
  },
  closeTabHotkey: {
    name: "Close tab hotkey",
    descNoKey: "No hotkey set. Click to configure.",
    descWithKey: "Current: {hotkey}",
    btnSet: "Set hotkey",
    btnChange: "Change"
  },
  slashCommands: {
    name: "Slash Commands",
    desc: "Create custom prompt templates triggered by /command. Use $ARGUMENTS for all arguments, $1/$2 for positional args, @file for file content, and !`bash` for command output."
  },
  mcpServers: {
    name: "MCP Servers",
    desc: "Configure Model Context Protocol servers to extend Claude's capabilities with external tools and data sources. Servers with context-saving mode require @mention to activate."
  },
  plugins: {
    name: "Claude Code Plugins",
    desc: "Enable or disable Claude Code plugins discovered from ~/.claude/plugins. Enabled plugins are stored per vault."
  },
  safety: "Safety",
  loadUserSettings: {
    name: "Load user Claude settings",
    desc: "Load ~/.claude/settings.json. When enabled, user's Claude Code permission rules may bypass Safe mode."
  },
  enableBlocklist: {
    name: "Enable command blocklist",
    desc: "Block potentially dangerous bash commands"
  },
  blockedCommands: {
    name: "Blocked commands ({platform})",
    desc: "Patterns to block on {platform} (one per line). Supports regex.",
    unixName: "Blocked commands (Unix/Git Bash)",
    unixDesc: "Unix patterns also blocked on Windows because Git Bash can invoke them."
  },
  exportPaths: {
    name: "Allowed export paths",
    desc: "Paths outside the vault where files can be exported (one per line). Supports ~ for home directory."
  },
  environment: "Environment",
  customVariables: {
    name: "Custom variables",
    desc: "Environment variables for Claude SDK (KEY=VALUE format, one per line)"
  },
  envSnippets: {
    name: "Environment Snippets",
    addBtn: "Add snippet",
    editBtn: "Edit",
    deleteBtn: "Delete",
    useBtn: "Use",
    noSnippets: "No environment snippets saved yet.",
    modal: {
      title: "Environment Snippet",
      name: "Name",
      namePlaceholder: "e.g., Production API",
      description: "Description",
      descPlaceholder: "Optional description",
      envVars: "Environment Variables",
      envVarsPlaceholder: "ANTHROPIC_API_KEY=your-key\nANTHROPIC_BASE_URL=https://api.example.com",
      save: "Save",
      cancel: "Cancel"
    }
  },
  advanced: "Advanced",
  show1MModel: {
    name: "Enable Sonnet with 1M context window",
    desc: "Replace standard Sonnet with Sonnet (1M) in the model selector. Same pricing under 200k tokens. Requires Max subscription."
  },
  maxTabs: {
    name: "Maximum chat tabs",
    desc: "Maximum number of concurrent chat tabs (3-10). Each tab uses a separate Claude session.",
    warning: "More than 5 tabs may impact performance and memory usage.",
    range: "{min} - {max}"
  },
  cliPath: {
    name: "Claude CLI path",
    desc: "Custom path to Claude Code CLI. Leave empty for auto-detection.",
    descWindows: "For the native installer, use claude.exe. For npm/pnpm/yarn or other package manager installs, use the cli.js path (not claude.cmd).",
    descUnix: 'Paste the output of "which claude" \u2014 works for both native and npm/pnpm/yarn installs.',
    validation: {
      notExist: "Path does not exist",
      isDirectory: "Path is a directory, not a file"
    }
  },
  language: {
    name: "Language",
    desc: "Change the display language of the plugin interface",
    en: "English",
    "zh-CN": "\u7B80\u4F53\u4E2D\u6587",
    "zh-TW": "\u7E41\u9AD4\u4E2D\u6587",
    ja: "\u65E5\u672C\u8A9E",
    ko: "\uD55C\uAD6D\uC5B4",
    de: "Deutsch",
    fr: "Fran\xE7ais",
    es: "Espa\xF1ol",
    ru: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439",
    pt: "Portugu\xEAs"
  }
};
var en_default3 = {
  common: common2,
  settings: settings2
};

// src/i18n/locales/es.json
var es_exports = {};
__export(es_exports, {
  common: () => common3,
  default: () => es_default,
  settings: () => settings3
});
var common3 = {
  save: "Guardar",
  cancel: "Cancelar",
  delete: "Eliminar",
  edit: "Editar",
  add: "Agregar",
  remove: "Eliminar",
  clear: "Limpiar",
  clearAll: "Limpiar todo",
  loading: "Cargando",
  error: "Error",
  success: "\xC9xito",
  warning: "Advertencia",
  confirm: "Confirmar",
  settings: "Configuraci\xF3n",
  advanced: "Avanzado",
  enabled: "Habilitado",
  disabled: "Deshabilitado",
  platform: "Plataforma"
};
var settings3 = {
  title: "Configuraci\xF3n de Claudian",
  customization: "Personalizaci\xF3n",
  userName: {
    name: "\xBFC\xF3mo deber\xEDa Claudian llamarte?",
    desc: "Tu nombre para saludos personalizados (dejar vac\xEDo para saludos gen\xE9ricos)"
  },
  excludedTags: {
    name: "Etiquetas excluidas",
    desc: "Las notas con estas etiquetas no se cargar\xE1n autom\xE1ticamente como contexto (una por l\xEDnea, sin #)"
  },
  mediaFolder: {
    name: "Carpeta de medios",
    desc: "Carpeta que contiene archivos adjuntos/imagenes. Cuando las notas usan ![[image.jpg]], Claude buscar\xE1 aqu\xED. Dejar vac\xEDo para la ra\xEDz del dep\xF3sito."
  },
  systemPrompt: {
    name: "Prompt de sistema personalizado",
    desc: "Instrucciones adicionales a\xF1adidas al prompt de sistema por defecto"
  },
  autoTitle: {
    name: "Generar autom\xE1ticamente t\xEDtulos de conversaci\xF3n",
    desc: "Genera autom\xE1ticamente t\xEDtulos de conversaci\xF3n despu\xE9s del primer intercambio."
  },
  titleModel: {
    name: "Modelo de generaci\xF3n de t\xEDtulos",
    desc: "Modelo utilizado para generar autom\xE1ticamente t\xEDtulos de conversaci\xF3n.",
    auto: "Auto (Haiku)"
  },
  navMappings: {
    name: "Mapeos de navegaci\xF3n estilo Vim",
    desc: 'Un mapeo por l\xEDnea. Formato: "map <tecla> <acci\xF3n>" (acciones: scrollUp, scrollDown, focusInput).'
  },
  hotkeys: "Atajos de teclado",
  inlineEditHotkey: {
    name: "Atajo de edici\xF3n en l\xEDnea",
    descNoKey: "No hay atajo configurado. Clic para configurar.",
    descWithKey: "Actual: {hotkey}",
    btnSet: "Configurar atajo",
    btnChange: "Cambiar"
  },
  openChatHotkey: {
    name: "Atajo para abrir chat",
    descNoKey: "No hay atajo configurado. Clic para configurar.",
    descWithKey: "Actual: {hotkey}",
    btnSet: "Configurar atajo",
    btnChange: "Cambiar"
  },
  newTabHotkey: {
    name: "Atajo nueva pesta\xF1a",
    descNoKey: "No hay atajo configurado. Clic para configurar.",
    descWithKey: "Actual: {hotkey}",
    btnSet: "Configurar atajo",
    btnChange: "Cambiar"
  },
  newSessionHotkey: {
    name: "Atajo nueva sesi\xF3n",
    descNoKey: "No hay atajo configurado. Clic para configurar.",
    descWithKey: "Actual: {hotkey}",
    btnSet: "Configurar atajo",
    btnChange: "Cambiar"
  },
  closeTabHotkey: {
    name: "Atajo cerrar pesta\xF1a",
    descNoKey: "No hay atajo configurado. Clic para configurar.",
    descWithKey: "Actual: {hotkey}",
    btnSet: "Configurar atajo",
    btnChange: "Cambiar"
  },
  slashCommands: {
    name: "Comandos slash",
    desc: "Crea plantillas de prompts personalizadas activadas por /command. Usa $ARGUMENTS para todos los argumentos, $1/$2 para argumentos posicionales, @file para contenido de archivo y !`bash` para salida de comandos."
  },
  mcpServers: {
    name: "Servidores MCP",
    desc: "Configura servidores Model Context Protocol para extender las capacidades de Claude con herramientas y fuentes de datos externas. Los servidores con modo de guardado de contexto requieren @mention para activarse."
  },
  plugins: {
    name: "Plugins de Claude Code",
    desc: "Habilita o deshabilita plugins de Claude Code descubiertos desde ~/.claude/plugins. Los plugins habilitados se almacenan por b\xF3veda."
  },
  safety: "Seguridad",
  loadUserSettings: {
    name: "Cargar configuraci\xF3n de usuario Claude",
    desc: "Carga ~/.claude/settings.json. Cuando est\xE1 habilitado, las reglas de permisos del usuario pueden eludir el modo seguro."
  },
  enableBlocklist: {
    name: "Habilitar lista negra de comandos",
    desc: "Bloquea comandos bash potencialmente peligrosos"
  },
  blockedCommands: {
    name: "Comandos bloqueados ({platform})",
    desc: "Patrones a bloquear en {platform} (uno por l\xEDnea). Soporta expresiones regulares.",
    unixName: "Comandos bloqueados (Unix/Git Bash)",
    unixDesc: "Los patrones Unix tambi\xE9n se bloquean en Windows porque Git Bash puede invocarlos."
  },
  exportPaths: {
    name: "Rutas de exportaci\xF3n permitidas",
    desc: "Rutas fuera del dep\xF3sito donde se pueden exportar archivos (una por l\xEDnea). Soporta ~ para el directorio home."
  },
  environment: "Entorno",
  customVariables: {
    name: "Variables personalizadas",
    desc: "Variables de entorno para Claude SDK (formato KEY=VALUE, una por l\xEDnea)"
  },
  envSnippets: {
    name: "Fragmentos de entorno",
    addBtn: "A\xF1adir fragmento",
    editBtn: "Editar",
    deleteBtn: "Eliminar",
    useBtn: "Usar",
    noSnippets: "No hay fragmentos de entorno guardados.",
    modal: {
      title: "Fragmento de entorno",
      name: "Nombre",
      namePlaceholder: "ej: API de producci\xF3n",
      description: "Descripci\xF3n",
      descPlaceholder: "Descripci\xF3n opcional",
      envVars: "Variables de entorno",
      envVarsPlaceholder: "ANTHROPIC_API_KEY=your-key\nANTHROPIC_BASE_URL=https://api.example.com",
      save: "Guardar",
      cancel: "Cancelar"
    }
  },
  advanced: "Avanzado",
  show1MModel: {
    name: "Habilitar Sonnet con ventana de contexto de 1M",
    desc: "Reemplazar Sonnet est\xE1ndar con Sonnet (1M) en el selector de modelos. Mismo precio bajo 200k tokens. Requiere suscripci\xF3n Max."
  },
  maxTabs: {
    name: "M\xE1ximo de pesta\xF1as de chat",
    desc: "N\xFAmero m\xE1ximo de pesta\xF1as de chat simult\xE1neas (3-10). Cada pesta\xF1a usa una sesi\xF3n de Claude separada.",
    warning: "M\xE1s de 5 pesta\xF1as puede afectar el rendimiento y el uso de memoria.",
    range: "{min} - {max}"
  },
  cliPath: {
    name: "Ruta CLI Claude",
    desc: "Ruta personalizada a Claude Code CLI. Dejar vac\xEDo para detecci\xF3n autom\xE1tica.",
    descWindows: "Para el instalador nativo, use claude.exe. Para instalaciones con npm/pnpm/yarn u otros gestores de paquetes, use la ruta cli.js (no claude.cmd).",
    descUnix: 'Pegue la salida de "which claude" \u2014 funciona tanto para instalaciones nativas como npm/pnpm/yarn.',
    validation: {
      notExist: "La ruta no existe",
      isDirectory: "La ruta es un directorio, no un archivo"
    }
  },
  language: {
    name: "Idioma",
    desc: "Cambiar el idioma de visualizaci\xF3n de la interfaz del plugin",
    en: "English",
    "zh-CN": "\u7B80\u4F53\u4E2D\u6587",
    "zh-TW": "\u7E41\u9AD4\u4E2D\u6587",
    ja: "\u65E5\u672C\u8A9E",
    ko: "\uD55C\uAD6D\uC5B4",
    de: "Deutsch",
    fr: "Fran\xE7ais",
    es: "Espa\xF1ol",
    ru: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439",
    pt: "Portugu\xEAs"
  }
};
var es_default = {
  common: common3,
  settings: settings3
};

// src/i18n/locales/fr.json
var fr_exports = {};
__export(fr_exports, {
  common: () => common4,
  default: () => fr_default,
  settings: () => settings4
});
var common4 = {
  save: "Enregistrer",
  cancel: "Annuler",
  delete: "Supprimer",
  edit: "Modifier",
  add: "Ajouter",
  remove: "Supprimer",
  clear: "Effacer",
  clearAll: "Tout effacer",
  loading: "Chargement",
  error: "Erreur",
  success: "Succ\xE8s",
  warning: "Avertissement",
  confirm: "Confirmer",
  settings: "Param\xE8tres",
  advanced: "Avanc\xE9",
  enabled: "Activ\xE9",
  disabled: "D\xE9sactiv\xE9",
  platform: "Plateforme"
};
var settings4 = {
  title: "Param\xE8tres Claudian",
  customization: "Personnalisation",
  userName: {
    name: "Comment Claudian doit-il vous appeler ?",
    desc: "Votre nom pour les salutations personnalis\xE9es (laisser vide pour les salutations g\xE9n\xE9riques)"
  },
  excludedTags: {
    name: "Tags exclus",
    desc: "Les notes avec ces tags ne seront pas charg\xE9es automatiquement comme contexte (un par ligne, sans #)"
  },
  mediaFolder: {
    name: "Dossier des m\xE9dias",
    desc: "Dossier contenant les pi\xE8ces jointes/images. Lorsque les notes utilisent ![[image.jpg]], Claude cherchera ici. Laisser vide pour la racine du coffre."
  },
  systemPrompt: {
    name: "Prompt syst\xE8me personnalis\xE9",
    desc: "Instructions suppl\xE9mentaires ajout\xE9es au prompt syst\xE8me par d\xE9faut"
  },
  autoTitle: {
    name: "G\xE9n\xE9rer automatiquement les titres de conversation",
    desc: "G\xE9n\xE8re automatiquement les titres de conversation apr\xE8s le premier \xE9change."
  },
  titleModel: {
    name: "Mod\xE8le de g\xE9n\xE9ration de titre",
    desc: "Mod\xE8le utilis\xE9 pour g\xE9n\xE9rer automatiquement les titres de conversation.",
    auto: "Auto (Haiku)"
  },
  navMappings: {
    name: "Mappages de navigation style Vim",
    desc: 'Un mappage par ligne. Format : "map <touche> <action>" (actions : scrollUp, scrollDown, focusInput).'
  },
  hotkeys: "Raccourcis clavier",
  inlineEditHotkey: {
    name: "Raccourci d'\xE9dition en ligne",
    descNoKey: "Aucun raccourci d\xE9fini. Cliquez pour configurer.",
    descWithKey: "Actuel : {hotkey}",
    btnSet: "D\xE9finir le raccourci",
    btnChange: "Changer"
  },
  openChatHotkey: {
    name: "Raccourci d'ouverture du chat",
    descNoKey: "Aucun raccourci d\xE9fini. Cliquez pour configurer.",
    descWithKey: "Actuel : {hotkey}",
    btnSet: "D\xE9finir le raccourci",
    btnChange: "Changer"
  },
  newTabHotkey: {
    name: "Raccourci nouvel onglet",
    descNoKey: "Aucun raccourci d\xE9fini. Cliquez pour configurer.",
    descWithKey: "Actuel : {hotkey}",
    btnSet: "D\xE9finir le raccourci",
    btnChange: "Changer"
  },
  newSessionHotkey: {
    name: "Raccourci nouvelle session",
    descNoKey: "Aucun raccourci d\xE9fini. Cliquez pour configurer.",
    descWithKey: "Actuel : {hotkey}",
    btnSet: "D\xE9finir le raccourci",
    btnChange: "Changer"
  },
  closeTabHotkey: {
    name: "Raccourci fermer l'onglet",
    descNoKey: "Aucun raccourci d\xE9fini. Cliquez pour configurer.",
    descWithKey: "Actuel : {hotkey}",
    btnSet: "D\xE9finir le raccourci",
    btnChange: "Changer"
  },
  slashCommands: {
    name: "Commandes slash",
    desc: "Cr\xE9ez des mod\xE8les de prompts personnalis\xE9s d\xE9clench\xE9s par /command. Utilisez $ARGUMENTS pour tous les arguments, $1/$2 pour les arguments positionnels, @file pour le contenu du fichier et !`bash` pour la sortie de commande."
  },
  mcpServers: {
    name: "Serveurs MCP",
    desc: "Configurez les serveurs Model Context Protocol pour \xE9tendre les capacit\xE9s de Claude avec des outils et sources de donn\xE9es externes. Les serveurs avec mode de sauvegarde de contexte n\xE9cessitent une @mention pour s'activer."
  },
  plugins: {
    name: "Plugins Claude Code",
    desc: "Activez ou d\xE9sactivez les plugins Claude Code d\xE9couverts dans ~/.claude/plugins. Les plugins activ\xE9s sont stock\xE9s par coffre."
  },
  safety: "S\xE9curit\xE9",
  loadUserSettings: {
    name: "Charger les param\xE8tres utilisateur Claude",
    desc: "Charge ~/.claude/settings.json. Lorsqu'activ\xE9, les r\xE8gles de permission de l'utilisateur peuvent contourner le mode s\xE9curis\xE9."
  },
  enableBlocklist: {
    name: "Activer la liste noire de commandes",
    desc: "Bloque les commandes bash potentiellement dangereuses"
  },
  blockedCommands: {
    name: "Commandes bloqu\xE9es ({platform})",
    desc: "Mod\xE8les \xE0 bloquer sur {platform} (un par ligne). Supporte les expressions r\xE9guli\xE8res.",
    unixName: "Commandes bloqu\xE9es (Unix/Git Bash)",
    unixDesc: "Les mod\xE8les Unix sont \xE9galement bloqu\xE9s sur Windows car Git Bash peut les appeler."
  },
  exportPaths: {
    name: "Chemins d'exportation autoris\xE9s",
    desc: "Chemins en dehors du coffre o\xF9 les fichiers peuvent \xEAtre export\xE9s (un par ligne). Supporte ~ pour le r\xE9pertoire home."
  },
  environment: "Environnement",
  customVariables: {
    name: "Variables personnalis\xE9es",
    desc: "Variables d'environnement pour Claude SDK (format KEY=VALUE, une par ligne)"
  },
  envSnippets: {
    name: "Extraits d'environnement",
    addBtn: "Ajouter un extrait",
    editBtn: "\xC9diter",
    deleteBtn: "Supprimer",
    useBtn: "Utiliser",
    noSnippets: "Aucun extrait d'environnement enregistr\xE9.",
    modal: {
      title: "Extrait d'environnement",
      name: "Nom",
      namePlaceholder: "ex : API de production",
      description: "Description",
      descPlaceholder: "Description optionnelle",
      envVars: "Variables d'environnement",
      envVarsPlaceholder: "ANTHROPIC_API_KEY=your-key\nANTHROPIC_BASE_URL=https://api.example.com",
      save: "Enregistrer",
      cancel: "Annuler"
    }
  },
  advanced: "Avanc\xE9",
  show1MModel: {
    name: "Activer Sonnet avec fen\xEAtre de contexte de 1M",
    desc: "Remplacer Sonnet standard par Sonnet (1M) dans le s\xE9lecteur de mod\xE8les. M\xEAme tarif sous 200k tokens. N\xE9cessite un abonnement Max."
  },
  maxTabs: {
    name: "Maximum d'onglets de chat",
    desc: "Nombre maximum d'onglets de chat simultan\xE9s (3-10). Chaque onglet utilise une session Claude s\xE9par\xE9e.",
    warning: "Plus de 5 onglets peut affecter les performances et l'utilisation de la m\xE9moire.",
    range: "{min} - {max}"
  },
  cliPath: {
    name: "Chemin CLI Claude",
    desc: "Chemin personnalis\xE9 vers Claude Code CLI. Laisser vide pour la d\xE9tection automatique.",
    descWindows: "Pour l'installateur natif, utilisez claude.exe. Pour les installations npm/pnpm/yarn ou autres gestionnaires de paquets, utilisez le chemin cli.js (pas claude.cmd).",
    descUnix: 'Collez la sortie de "which claude" \u2014 fonctionne pour les installations natives et npm/pnpm/yarn.',
    validation: {
      notExist: "Le chemin n'existe pas",
      isDirectory: "Le chemin est un r\xE9pertoire, pas un fichier"
    }
  },
  language: {
    name: "Langue",
    desc: "Changer la langue d'affichage de l'interface du plugin",
    en: "English",
    "zh-CN": "\u7B80\u4F53\u4E2D\u6587",
    "zh-TW": "\u7E41\u9AD4\u4E2D\u6587",
    ja: "\u65E5\u672C\u8A9E",
    ko: "\uD55C\uAD6D\uC5B4",
    de: "Deutsch",
    fr: "Fran\xE7ais",
    es: "Espa\xF1ol",
    ru: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439",
    pt: "Portugu\xEAs"
  }
};
var fr_default = {
  common: common4,
  settings: settings4
};

// src/i18n/locales/ja.json
var ja_exports = {};
__export(ja_exports, {
  common: () => common5,
  default: () => ja_default,
  settings: () => settings5
});
var common5 = {
  save: "\u4FDD\u5B58",
  cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB",
  delete: "\u524A\u9664",
  edit: "\u7DE8\u96C6",
  add: "\u8FFD\u52A0",
  remove: "\u524A\u9664",
  clear: "\u30AF\u30EA\u30A2",
  clearAll: "\u3059\u3079\u3066\u30AF\u30EA\u30A2",
  loading: "\u8AAD\u307F\u8FBC\u307F\u4E2D",
  error: "\u30A8\u30E9\u30FC",
  success: "\u6210\u529F",
  warning: "\u8B66\u544A",
  confirm: "\u78BA\u8A8D",
  settings: "\u8A2D\u5B9A",
  advanced: "\u8A73\u7D30",
  enabled: "\u6709\u52B9",
  disabled: "\u7121\u52B9",
  platform: "\u30D7\u30E9\u30C3\u30C8\u30D5\u30A9\u30FC\u30E0"
};
var settings5 = {
  title: "Claudian \u8A2D\u5B9A",
  customization: "\u30AB\u30B9\u30BF\u30DE\u30A4\u30BA",
  userName: {
    name: "Claudian \u306F\u3069\u306E\u3088\u3046\u306B\u547C\u3073\u307E\u3059\u304B\uFF1F",
    desc: "\u30D1\u30FC\u30BD\u30CA\u30E9\u30A4\u30BA\u3055\u308C\u305F\u6328\u62F6\u306B\u4F7F\u7528\u3059\u308B\u540D\u524D\uFF08\u7A7A\u6B04\u3067\u4E00\u822C\u306E\u6328\u62F6\uFF09"
  },
  excludedTags: {
    name: "\u9664\u5916\u30BF\u30B0",
    desc: "\u3053\u308C\u3089\u306E\u30BF\u30B0\u3092\u542B\u3080\u30CE\u30FC\u30C8\u306F\u81EA\u52D5\u7684\u306B\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u3068\u3057\u3066\u8AAD\u307F\u8FBC\u307E\u308C\u307E\u305B\u3093\uFF081\u884C\u306B1\u3064\u3001#\u306A\u3057\uFF09"
  },
  mediaFolder: {
    name: "\u30E1\u30C7\u30A3\u30A2\u30D5\u30A9\u30EB\u30C0",
    desc: "\u6DFB\u4ED8\u30D5\u30A1\u30A4\u30EB/\u753B\u50CF\u3092\u683C\u7D0D\u3059\u308B\u30D5\u30A9\u30EB\u30C0\u3002\u30CE\u30FC\u30C8\u304C ![[image.jpg]] \u3092\u4F7F\u7528\u3059\u308B\u5834\u5408\u3001Claude \u306F\u3053\u3053\u3067\u63A2\u3057\u307E\u3059\u3002\u7A7A\u6B04\u3067\u30EA\u30DD\u30B8\u30C8\u30EA\u306E\u30EB\u30FC\u30C8\u3092\u4F7F\u7528\u3002"
  },
  systemPrompt: {
    name: "\u30AB\u30B9\u30BF\u30E0\u30B7\u30B9\u30C6\u30E0\u30D7\u30ED\u30F3\u30D7\u30C8",
    desc: "\u30C7\u30D5\u30A9\u30EB\u30C8\u306E\u30B7\u30B9\u30C6\u30E0\u30D7\u30ED\u30F3\u30D7\u30C8\u306B\u8FFD\u52A0\u3055\u308C\u308B\u8FFD\u52A0\u6307\u793A"
  },
  autoTitle: {
    name: "\u4F1A\u8A71\u30BF\u30A4\u30C8\u30EB\u3092\u81EA\u52D5\u751F\u6210",
    desc: "\u6700\u521D\u306E\u3084\u308A\u53D6\u308A\u5F8C\u306B\u4F1A\u8A71\u30BF\u30A4\u30C8\u30EB\u3092\u81EA\u52D5\u7684\u306B\u751F\u6210\u3057\u307E\u3059\u3002"
  },
  titleModel: {
    name: "\u30BF\u30A4\u30C8\u30EB\u751F\u6210\u30E2\u30C7\u30EB",
    desc: "\u4F1A\u8A71\u30BF\u30A4\u30C8\u30EB\u3092\u81EA\u52D5\u751F\u6210\u3059\u308B\u305F\u3081\u306B\u4F7F\u7528\u3055\u308C\u308B\u30E2\u30C7\u30EB\u3002",
    auto: "\u81EA\u52D5 (Haiku)"
  },
  navMappings: {
    name: "Vim\u30B9\u30BF\u30A4\u30EB\u30CA\u30D3\u30B2\u30FC\u30B7\u30E7\u30F3\u30DE\u30C3\u30D4\u30F3\u30B0",
    desc: '1\u884C\u306B1\u3064\u306E\u30DE\u30C3\u30D4\u30F3\u30B0\u3002\u5F62\u5F0F\uFF1A"map <\u30AD\u30FC> <\u30A2\u30AF\u30B7\u30E7\u30F3>"\uFF08\u30A2\u30AF\u30B7\u30E7\u30F3\uFF1AscrollUp, scrollDown, focusInput\uFF09\u3002'
  },
  hotkeys: "\u30DB\u30C3\u30C8\u30AD\u30FC",
  inlineEditHotkey: {
    name: "\u30A4\u30F3\u30E9\u30A4\u30F3\u7DE8\u96C6\u30DB\u30C3\u30C8\u30AD\u30FC",
    descNoKey: "\u30DB\u30C3\u30C8\u30AD\u30FC\u304C\u8A2D\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u8A2D\u5B9A\u3057\u307E\u3059\u3002",
    descWithKey: "\u73FE\u5728\uFF1A{hotkey}",
    btnSet: "\u30DB\u30C3\u30C8\u30AD\u30FC\u3092\u8A2D\u5B9A",
    btnChange: "\u5909\u66F4"
  },
  openChatHotkey: {
    name: "\u30C1\u30E3\u30C3\u30C8\u3092\u958B\u304F\u30DB\u30C3\u30C8\u30AD\u30FC",
    descNoKey: "\u30DB\u30C3\u30C8\u30AD\u30FC\u304C\u8A2D\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u8A2D\u5B9A\u3057\u307E\u3059\u3002",
    descWithKey: "\u73FE\u5728\uFF1A{hotkey}",
    btnSet: "\u30DB\u30C3\u30C8\u30AD\u30FC\u3092\u8A2D\u5B9A",
    btnChange: "\u5909\u66F4"
  },
  newTabHotkey: {
    name: "\u65B0\u3057\u3044\u30BF\u30D6\u306E\u30DB\u30C3\u30C8\u30AD\u30FC",
    descNoKey: "\u30DB\u30C3\u30C8\u30AD\u30FC\u304C\u8A2D\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u8A2D\u5B9A\u3057\u307E\u3059\u3002",
    descWithKey: "\u73FE\u5728\uFF1A{hotkey}",
    btnSet: "\u30DB\u30C3\u30C8\u30AD\u30FC\u3092\u8A2D\u5B9A",
    btnChange: "\u5909\u66F4"
  },
  newSessionHotkey: {
    name: "\u65B0\u3057\u3044\u30BB\u30C3\u30B7\u30E7\u30F3\u306E\u30DB\u30C3\u30C8\u30AD\u30FC",
    descNoKey: "\u30DB\u30C3\u30C8\u30AD\u30FC\u304C\u8A2D\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u8A2D\u5B9A\u3057\u307E\u3059\u3002",
    descWithKey: "\u73FE\u5728\uFF1A{hotkey}",
    btnSet: "\u30DB\u30C3\u30C8\u30AD\u30FC\u3092\u8A2D\u5B9A",
    btnChange: "\u5909\u66F4"
  },
  closeTabHotkey: {
    name: "\u30BF\u30D6\u3092\u9589\u3058\u308B\u30DB\u30C3\u30C8\u30AD\u30FC",
    descNoKey: "\u30DB\u30C3\u30C8\u30AD\u30FC\u304C\u8A2D\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u8A2D\u5B9A\u3057\u307E\u3059\u3002",
    descWithKey: "\u73FE\u5728\uFF1A{hotkey}",
    btnSet: "\u30DB\u30C3\u30C8\u30AD\u30FC\u3092\u8A2D\u5B9A",
    btnChange: "\u5909\u66F4"
  },
  slashCommands: {
    name: "\u30B9\u30E9\u30C3\u30B7\u30E5\u30B3\u30DE\u30F3\u30C9",
    desc: "/command \u3067\u30C8\u30EA\u30AC\u30FC\u3055\u308C\u308B\u30AB\u30B9\u30BF\u30E0\u30D7\u30ED\u30F3\u30D7\u30C8\u30C6\u30F3\u30D7\u30EC\u30FC\u30C8\u3092\u4F5C\u6210\u3057\u307E\u3059\u3002$ARGUMENTS \u3067\u3059\u3079\u3066\u306E\u5F15\u6570\u3001$1/$2 \u3067\u4F4D\u7F6E\u5F15\u6570\u3001@file \u3067\u30D5\u30A1\u30A4\u30EB\u5185\u5BB9\u3001!`bash` \u3067\u30B3\u30DE\u30F3\u30C9\u51FA\u529B\u3092\u53D6\u5F97\u3067\u304D\u307E\u3059\u3002"
  },
  mcpServers: {
    name: "MCP \u30B5\u30FC\u30D0\u30FC",
    desc: "\u30E2\u30C7\u30EB\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u30D7\u30ED\u30C8\u30B3\u30EB\u30B5\u30FC\u30D0\u30FC\u3092\u8A2D\u5B9A\u3057\u3001\u5916\u90E8\u30C4\u30FC\u30EB\u3084\u30C7\u30FC\u30BF\u30BD\u30FC\u30B9\u3067 Claude \u306E\u6A5F\u80FD\u3092\u62E1\u5F35\u3057\u307E\u3059\u3002\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u4FDD\u5B58\u30E2\u30FC\u30C9\u306E\u30B5\u30FC\u30D0\u30FC\u306F @mention \u3067\u30A2\u30AF\u30C6\u30A3\u30D6\u306B\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002"
  },
  plugins: {
    name: "Claude Code \u30D7\u30E9\u30B0\u30A4\u30F3",
    desc: "~/.claude/plugins \u304B\u3089\u691C\u51FA\u3055\u308C\u305F Claude Code \u30D7\u30E9\u30B0\u30A4\u30F3\u3092\u6709\u52B9\u5316\u307E\u305F\u306F\u7121\u52B9\u5316\u3057\u307E\u3059\u3002\u6709\u52B9\u5316\u3055\u308C\u305F\u30D7\u30E9\u30B0\u30A4\u30F3\u306F\u4FDD\u7BA1\u5EAB\u3054\u3068\u306B\u4FDD\u5B58\u3055\u308C\u307E\u3059\u3002"
  },
  safety: "\u30BB\u30AD\u30E5\u30EA\u30C6\u30A3",
  loadUserSettings: {
    name: "\u30E6\u30FC\u30B6\u30FCClaude\u8A2D\u5B9A\u3092\u8AAD\u307F\u8FBC\u3080",
    desc: "~/.claude/settings.json \u3092\u8AAD\u307F\u8FBC\u307F\u307E\u3059\u3002\u6709\u52B9\u306B\u3059\u308B\u3068\u3001\u30E6\u30FC\u30B6\u30FC\u306E Claude Code \u8A31\u53EF\u30EB\u30FC\u30EB\u304C\u30BB\u30AD\u30E5\u30EA\u30C6\u30A3\u30E2\u30FC\u30C9\u3092\u30D0\u30A4\u30D1\u30B9\u3059\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059\u3002"
  },
  enableBlocklist: {
    name: "\u30B3\u30DE\u30F3\u30C9\u30D6\u30E9\u30C3\u30AF\u30EA\u30B9\u30C8\u3092\u6709\u52B9\u5316",
    desc: "\u6F5C\u5728\u7684\u306B\u5371\u967A\u306Abash\u30B3\u30DE\u30F3\u30C9\u3092\u30D6\u30ED\u30C3\u30AF"
  },
  blockedCommands: {
    name: "\u30D6\u30ED\u30C3\u30AF\u3055\u308C\u305F\u30B3\u30DE\u30F3\u30C9 ({platform})",
    desc: "{platform} \u3067\u30D6\u30ED\u30C3\u30AF\u3059\u308B\u30D1\u30BF\u30FC\u30F3\uFF081\u884C\u306B1\u3064\uFF09\u3002\u6B63\u898F\u8868\u73FE\u3092\u30B5\u30DD\u30FC\u30C8\u3002",
    unixName: "\u30D6\u30ED\u30C3\u30AF\u3055\u308C\u305F\u30B3\u30DE\u30F3\u30C9 (Unix/Git Bash)",
    unixDesc: "Git Bash\u304C\u547C\u3073\u51FA\u305B\u308B\u305F\u3081\u3001Unix\u30D1\u30BF\u30FC\u30F3\u3082Windows\u4E0A\u3067\u30D6\u30ED\u30C3\u30AF\u3055\u308C\u307E\u3059\u3002"
  },
  exportPaths: {
    name: "\u8A31\u53EF\u3055\u308C\u305F\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u30D1\u30B9",
    desc: "\u30D5\u30A1\u30A4\u30EB\u3092\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3067\u304D\u308B\u30EA\u30DD\u30B8\u30C8\u30EA\u5916\u306E\u30D1\u30B9\uFF081\u884C\u306B1\u3064\uFF09\u3002~ \u3067\u30DB\u30FC\u30E0\u30C7\u30A3\u30EC\u30AF\u30C8\u30EA\u3092\u30B5\u30DD\u30FC\u30C8\u3002"
  },
  environment: "\u74B0\u5883",
  customVariables: {
    name: "\u30AB\u30B9\u30BF\u30E0\u5909\u6570",
    desc: "Claude SDK\u306E\u74B0\u5883\u5909\u6570\uFF08KEY=VALUE\u5F62\u5F0F\u30011\u884C\u306B1\u3064\uFF09"
  },
  envSnippets: {
    name: "\u74B0\u5883\u5909\u6570\u30B9\u30CB\u30DA\u30C3\u30C8",
    addBtn: "\u30B9\u30CB\u30DA\u30C3\u30C8\u3092\u8FFD\u52A0",
    editBtn: "\u7DE8\u96C6",
    deleteBtn: "\u524A\u9664",
    useBtn: "\u4F7F\u7528",
    noSnippets: "\u4FDD\u5B58\u3055\u308C\u305F\u74B0\u5883\u5909\u6570\u30B9\u30CB\u30DA\u30C3\u30C8\u306F\u3042\u308A\u307E\u305B\u3093\u3002",
    modal: {
      title: "\u74B0\u5883\u5909\u6570\u30B9\u30CB\u30DA\u30C3\u30C8",
      name: "\u540D\u524D",
      namePlaceholder: "\u4F8B\uFF1A\u672C\u756AAPI",
      description: "\u8AAC\u660E",
      descPlaceholder: "\u4EFB\u610F\u306E\u8AAC\u660E",
      envVars: "\u74B0\u5883\u5909\u6570",
      envVarsPlaceholder: "ANTHROPIC_API_KEY=your-key\nANTHROPIC_BASE_URL=https://api.example.com",
      save: "\u4FDD\u5B58",
      cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB"
    }
  },
  advanced: "\u8A73\u7D30\u8A2D\u5B9A",
  show1MModel: {
    name: "1M\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u30A6\u30A3\u30F3\u30C9\u30A6\u3092\u6301\u3064Sonnet\u3092\u6709\u52B9\u5316",
    desc: "\u30E2\u30C7\u30EB\u30BB\u30EC\u30AF\u30BF\u30FC\u3067\u6A19\u6E96Sonnet\u3092 Sonnet (1M) \u306B\u7F6E\u304D\u63DB\u3048\u307E\u3059\u3002200k\u30C8\u30FC\u30AF\u30F3\u672A\u6E80\u3067\u306F\u540C\u3058\u4FA1\u683C\u3002Max\u30B5\u30D6\u30B9\u30AF\u30EA\u30D7\u30B7\u30E7\u30F3\u304C\u5FC5\u8981\u3067\u3059\u3002"
  },
  maxTabs: {
    name: "\u6700\u5927\u30C1\u30E3\u30C3\u30C8\u30BF\u30D6\u6570",
    desc: "\u540C\u6642\u306B\u958B\u3051\u308B\u6700\u5927\u30C1\u30E3\u30C3\u30C8\u30BF\u30D6\u6570\uFF083-10\uFF09\u3002\u5404\u30BF\u30D6\u306F\u500B\u5225\u306E Claude \u30BB\u30C3\u30B7\u30E7\u30F3\u3092\u4F7F\u7528\u3057\u307E\u3059\u3002",
    warning: "5 \u30BF\u30D6\u3092\u8D85\u3048\u308B\u3068\u30D1\u30D5\u30A9\u30FC\u30DE\u30F3\u30B9\u3084\u30E1\u30E2\u30EA\u4F7F\u7528\u91CF\u306B\u5F71\u97FF\u3059\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059\u3002",
    range: "{min} - {max}"
  },
  cliPath: {
    name: "Claude CLI \u30D1\u30B9",
    desc: "Claude Code CLI \u306E\u30AB\u30B9\u30BF\u30E0\u30D1\u30B9\u3002\u7A7A\u6B04\u3067\u81EA\u52D5\u691C\u51FA\u3092\u4F7F\u7528\u3002",
    descWindows: "\u30CD\u30A4\u30C6\u30A3\u30D6\u30A4\u30F3\u30B9\u30C8\u30FC\u30E9\u30FC\u306E\u5834\u5408\u306F claude.exe \u3092\u4F7F\u7528\u3002npm/pnpm/yarn \u3084\u305D\u306E\u4ED6\u306E\u30D1\u30C3\u30B1\u30FC\u30B8\u30DE\u30CD\u30FC\u30B8\u30E3\u30FC\u3067\u306E\u30A4\u30F3\u30B9\u30C8\u30FC\u30EB\u306E\u5834\u5408\u306F cli.js \u30D1\u30B9\u3092\u4F7F\u7528\uFF08claude.cmd \u3067\u306F\u306A\u3044\uFF09\u3002",
    descUnix: '"which claude" \u306E\u51FA\u529B\u3092\u8CBC\u308A\u4ED8\u3051\u3066\u304F\u3060\u3055\u3044 - \u30CD\u30A4\u30C6\u30A3\u30D6\u3068 npm/pnpm/yarn \u30A4\u30F3\u30B9\u30C8\u30FC\u30EB\u306E\u4E21\u65B9\u3067\u52D5\u4F5C\u3057\u307E\u3059\u3002',
    validation: {
      notExist: "\u30D1\u30B9\u304C\u5B58\u5728\u3057\u307E\u305B\u3093",
      isDirectory: "\u30D1\u30B9\u306F\u30C7\u30A3\u30EC\u30AF\u30C8\u30EA\u3067\u30D5\u30A1\u30A4\u30EB\u3067\u306F\u3042\u308A\u307E\u305B\u3093"
    }
  },
  language: {
    name: "\u8A00\u8A9E",
    desc: "\u30D7\u30E9\u30B0\u30A4\u30F3\u30A4\u30F3\u30BF\u30FC\u30D5\u30A7\u30FC\u30B9\u306E\u8868\u793A\u8A00\u8A9E\u3092\u5909\u66F4",
    en: "English",
    "zh-CN": "\u7B80\u4F53\u4E2D\u6587",
    "zh-TW": "\u7E41\u9AD4\u4E2D\u6587",
    ja: "\u65E5\u672C\u8A9E",
    ko: "\uD55C\uAD6D\uC5B4",
    de: "Deutsch",
    fr: "Fran\xE7ais",
    es: "Espa\xF1ol",
    ru: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439",
    pt: "Portugu\xEAs"
  }
};
var ja_default = {
  common: common5,
  settings: settings5
};

// src/i18n/locales/ko.json
var ko_exports = {};
__export(ko_exports, {
  common: () => common6,
  default: () => ko_default,
  settings: () => settings6
});
var common6 = {
  save: "\uC800\uC7A5",
  cancel: "\uCDE8\uC18C",
  delete: "\uC0AD\uC81C",
  edit: "\uD3B8\uC9D1",
  add: "\uCD94\uAC00",
  remove: "\uC81C\uAC70",
  clear: "\uC9C0\uC6B0\uAE30",
  clearAll: "\uBAA8\uB450 \uC9C0\uC6B0\uAE30",
  loading: "\uB85C\uB529 \uC911",
  error: "\uC624\uB958",
  success: "\uC131\uACF5",
  warning: "\uACBD\uACE0",
  confirm: "\uD655\uC778",
  settings: "\uC124\uC815",
  advanced: "\uACE0\uAE09",
  enabled: "\uD65C\uC131\uD654",
  disabled: "\uBE44\uD65C\uC131\uD654",
  platform: "\uD50C\uB7AB\uD3FC"
};
var settings6 = {
  title: "Claudian \uC124\uC815",
  customization: "\uC0AC\uC6A9\uC790 \uC815\uC758",
  userName: {
    name: "Claudian\uC774 \uB2F9\uC2E0\uC744 \uC5B4\uB5BB\uAC8C \uBD88\uB7EC\uC57C \uD569\uB2C8\uAE4C?",
    desc: "\uAC1C\uC778\uD654\uB41C \uC778\uC0AC\uC5D0 \uC0AC\uC6A9\uD560 \uC774\uB984 (\uBE44\uC6CC\uB450\uBA74 \uC77C\uBC18 \uC778\uC0AC)"
  },
  excludedTags: {
    name: "\uC81C\uC678 \uD0DC\uADF8",
    desc: "\uC774 \uD0DC\uADF8\uAC00 \uD3EC\uD568\uB41C \uB178\uD2B8\uB294 \uC790\uB3D9\uC73C\uB85C \uCEE8\uD14D\uC2A4\uD2B8\uB85C \uB85C\uB4DC\uB418\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4 (\uD55C \uC904\uC5D0 \uD558\uB098, # \uC81C\uC678)"
  },
  mediaFolder: {
    name: "\uBBF8\uB514\uC5B4 \uD3F4\uB354",
    desc: "\uCCA8\uBD80 \uD30C\uC77C/\uC774\uBBF8\uC9C0\uB97C \uC800\uC7A5\uD560 \uD3F4\uB354. \uB178\uD2B8\uAC00 ![[image.jpg]]\uB97C \uC0AC\uC6A9\uD560 \uB54C Claude\uAC00 \uC5EC\uAE30\uC11C \uCC3E\uC2B5\uB2C8\uB2E4. \uBE44\uC6CC\uB450\uBA74 \uC800\uC7A5\uC18C \uB8E8\uD2B8 \uC0AC\uC6A9."
  },
  systemPrompt: {
    name: "\uCEE4\uC2A4\uD140 \uC2DC\uC2A4\uD15C \uD504\uB86C\uD504\uD2B8",
    desc: "\uAE30\uBCF8 \uC2DC\uC2A4\uD15C \uD504\uB86C\uD504\uD2B8\uC5D0 \uCD94\uAC00\uB418\uB294 \uCD94\uAC00 \uC9C0\uCE68"
  },
  autoTitle: {
    name: "\uB300\uD654 \uC81C\uBAA9 \uC790\uB3D9 \uC0DD\uC131",
    desc: "\uCCAB \uBC88\uC9F8 \uAD50\uD658 \uD6C4 \uC790\uB3D9\uC73C\uB85C \uB300\uD654 \uC81C\uBAA9\uC744 \uC0DD\uC131\uD569\uB2C8\uB2E4."
  },
  titleModel: {
    name: "\uC81C\uBAA9 \uC0DD\uC131 \uBAA8\uB378",
    desc: "\uB300\uD654 \uC81C\uBAA9\uC744 \uC790\uB3D9 \uC0DD\uC131\uD558\uB294 \uB370 \uC0AC\uC6A9\uB418\uB294 \uBAA8\uB378.",
    auto: "\uC790\uB3D9 (Haiku)"
  },
  navMappings: {
    name: "Vim \uC2A4\uD0C0\uC77C \uB124\uBE44\uAC8C\uC774\uC158 \uB9E4\uD551",
    desc: '\uD55C \uC904\uC5D0 \uD558\uB098\uC758 \uB9E4\uD551. \uD615\uC2DD: "map <\uD0A4> <\uB3D9\uC791>" (\uB3D9\uC791: scrollUp, scrollDown, focusInput).'
  },
  hotkeys: "\uB2E8\uCD95\uD0A4",
  inlineEditHotkey: {
    name: "\uC778\uB77C\uC778 \uD3B8\uC9D1 \uB2E8\uCD95\uD0A4",
    descNoKey: "\uB2E8\uCD95\uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. \uD074\uB9AD\uD558\uC5EC \uC124\uC815\uD558\uC138\uC694.",
    descWithKey: "\uD604\uC7AC: {hotkey}",
    btnSet: "\uB2E8\uCD95\uD0A4 \uC124\uC815",
    btnChange: "\uBCC0\uACBD"
  },
  openChatHotkey: {
    name: "\uCC44\uD305 \uC5F4\uAE30 \uB2E8\uCD95\uD0A4",
    descNoKey: "\uB2E8\uCD95\uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. \uD074\uB9AD\uD558\uC5EC \uC124\uC815\uD558\uC138\uC694.",
    descWithKey: "\uD604\uC7AC: {hotkey}",
    btnSet: "\uB2E8\uCD95\uD0A4 \uC124\uC815",
    btnChange: "\uBCC0\uACBD"
  },
  newTabHotkey: {
    name: "\uC0C8 \uD0ED \uB2E8\uCD95\uD0A4",
    descNoKey: "\uB2E8\uCD95\uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. \uD074\uB9AD\uD558\uC5EC \uC124\uC815\uD558\uC138\uC694.",
    descWithKey: "\uD604\uC7AC: {hotkey}",
    btnSet: "\uB2E8\uCD95\uD0A4 \uC124\uC815",
    btnChange: "\uBCC0\uACBD"
  },
  newSessionHotkey: {
    name: "\uC0C8 \uC138\uC158 \uB2E8\uCD95\uD0A4",
    descNoKey: "\uB2E8\uCD95\uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. \uD074\uB9AD\uD558\uC5EC \uC124\uC815\uD558\uC138\uC694.",
    descWithKey: "\uD604\uC7AC: {hotkey}",
    btnSet: "\uB2E8\uCD95\uD0A4 \uC124\uC815",
    btnChange: "\uBCC0\uACBD"
  },
  closeTabHotkey: {
    name: "\uD0ED \uB2EB\uAE30 \uB2E8\uCD95\uD0A4",
    descNoKey: "\uB2E8\uCD95\uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. \uD074\uB9AD\uD558\uC5EC \uC124\uC815\uD558\uC138\uC694.",
    descWithKey: "\uD604\uC7AC: {hotkey}",
    btnSet: "\uB2E8\uCD95\uD0A4 \uC124\uC815",
    btnChange: "\uBCC0\uACBD"
  },
  slashCommands: {
    name: "\uC2AC\uB798\uC2DC \uBA85\uB839\uC5B4",
    desc: "/command\uB85C \uD2B8\uB9AC\uAC70\uB418\uB294 \uCEE4\uC2A4\uD140 \uD504\uB86C\uD504\uD2B8 \uD15C\uD50C\uB9BF\uC744 \uC0DD\uC131\uD569\uB2C8\uB2E4. $ARGUMENTS\uB85C \uBAA8\uB4E0 \uC778\uC790, $1/$2\uB85C \uC704\uCE58 \uC778\uC790, @file\uB85C \uD30C\uC77C \uB0B4\uC6A9, !`bash`\uB85C \uBA85\uB839\uC5B4 \uCD9C\uB825\uC744 \uAC00\uC838\uC62C \uC218 \uC788\uC2B5\uB2C8\uB2E4."
  },
  mcpServers: {
    name: "MCP \uC11C\uBC84",
    desc: "\uBAA8\uB378 \uCEE8\uD14D\uC2A4\uD2B8 \uD504\uB85C\uD1A0\uCF5C \uC11C\uBC84\uB97C \uC124\uC815\uD558\uC5EC \uC678\uBD80 \uB3C4\uAD6C\uC640 \uB370\uC774\uD130 \uC18C\uC2A4\uB85C Claude\uC758 \uAE30\uB2A5\uC744 \uD655\uC7A5\uD569\uB2C8\uB2E4. \uCEE8\uD14D\uC2A4\uD2B8 \uC800\uC7A5 \uBAA8\uB4DC \uC11C\uBC84\uB294 @mention\uC73C\uB85C \uD65C\uC131\uD654\uD574\uC57C \uD569\uB2C8\uB2E4."
  },
  plugins: {
    name: "Claude Code \uD50C\uB7EC\uADF8\uC778",
    desc: "~/.claude/plugins\uC5D0\uC11C \uBC1C\uACAC\uB41C Claude Code \uD50C\uB7EC\uADF8\uC778\uC744 \uD65C\uC131\uD654 \uB610\uB294 \uBE44\uD65C\uC131\uD654\uD569\uB2C8\uB2E4. \uD65C\uC131\uD654\uB41C \uD50C\uB7EC\uADF8\uC778\uC740 \uBCFC\uD2B8\uBCC4\uB85C \uC800\uC7A5\uB429\uB2C8\uB2E4."
  },
  safety: "\uBCF4\uC548",
  loadUserSettings: {
    name: "\uC0AC\uC6A9\uC790 Claude \uC124\uC815 \uB85C\uB4DC",
    desc: "~/.claude/settings.json\uC744 \uB85C\uB4DC\uD569\uB2C8\uB2E4. \uD65C\uC131\uD654\uD558\uBA74 \uC0AC\uC6A9\uC790\uC758 Claude Code \uD5C8\uC6A9 \uADDC\uCE59\uC774 \uBCF4\uC548 \uBAA8\uB4DC\uB97C \uC6B0\uD68C\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4."
  },
  enableBlocklist: {
    name: "\uBA85\uB839\uC5B4 \uBE14\uB799\uB9AC\uC2A4\uD2B8 \uD65C\uC131\uD654",
    desc: "\uC7A0\uC7AC\uC801\uC73C\uB85C \uC704\uD5D8\uD55C bash \uBA85\uB839\uC5B4 \uCC28\uB2E8"
  },
  blockedCommands: {
    name: "\uCC28\uB2E8\uB41C \uBA85\uB839\uC5B4 ({platform})",
    desc: "{platform}\uC5D0\uC11C \uCC28\uB2E8\uD560 \uD328\uD134 (\uD55C \uC904\uC5D0 \uD558\uB098). \uC815\uADDC\uC2DD \uC9C0\uC6D0.",
    unixName: "\uCC28\uB2E8\uB41C \uBA85\uB839\uC5B4 (Unix/Git Bash)",
    unixDesc: "Git Bash\uAC00 \uD638\uCD9C\uD560 \uC218 \uC788\uC73C\uBBC0\uB85C Unix \uD328\uD134\uB3C4 Windows\uC5D0\uC11C \uCC28\uB2E8\uB429\uB2C8\uB2E4."
  },
  exportPaths: {
    name: "\uD5C8\uC6A9\uB41C \uB0B4\uBCF4\uB0B4\uAE30 \uACBD\uB85C",
    desc: "\uD30C\uC77C\uC744 \uB0B4\uBCF4\uB0BC \uC218 \uC788\uB294 \uC800\uC7A5\uC18C \uC678\uBD80 \uACBD\uB85C (\uD55C \uC904\uC5D0 \uD558\uB098). ~\uB85C \uD648 \uB514\uB809\uD1A0\uB9AC \uC9C0\uC6D0."
  },
  environment: "\uD658\uACBD",
  customVariables: {
    name: "\uCEE4\uC2A4\uD140 \uBCC0\uC218",
    desc: "Claude SDK \uD658\uACBD \uBCC0\uC218 (KEY=VALUE \uD615\uC2DD, \uD55C \uC904\uC5D0 \uD558\uB098)"
  },
  envSnippets: {
    name: "\uD658\uACBD \uBCC0\uC218 \uC2A4\uB2C8\uD3AB",
    addBtn: "\uC2A4\uB2C8\uD3AB \uCD94\uAC00",
    editBtn: "\uD3B8\uC9D1",
    deleteBtn: "\uC0AD\uC81C",
    useBtn: "\uC0AC\uC6A9",
    noSnippets: "\uC800\uC7A5\uB41C \uD658\uACBD \uBCC0\uC218 \uC2A4\uB2C8\uD3AB\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.",
    modal: {
      title: "\uD658\uACBD \uBCC0\uC218 \uC2A4\uB2C8\uD3AB",
      name: "\uC774\uB984",
      namePlaceholder: "\uC608: \uD504\uB85C\uB355\uC158 API",
      description: "\uC124\uBA85",
      descPlaceholder: "\uC120\uD0DD\uC801 \uC124\uBA85",
      envVars: "\uD658\uACBD \uBCC0\uC218",
      envVarsPlaceholder: "ANTHROPIC_API_KEY=your-key\nANTHROPIC_BASE_URL=https://api.example.com",
      save: "\uC800\uC7A5",
      cancel: "\uCDE8\uC18C"
    }
  },
  advanced: "\uACE0\uAE09",
  show1MModel: {
    name: "1M \uCEE8\uD14D\uC2A4\uD2B8 \uCC3D\uC744 \uAC00\uC9C4 Sonnet \uD65C\uC131\uD654",
    desc: "\uBAA8\uB378 \uC120\uD0DD\uAE30\uC5D0\uC11C \uD45C\uC900 Sonnet\uC744 Sonnet (1M)\uC73C\uB85C \uAD50\uCCB4\uD569\uB2C8\uB2E4. 200k \uD1A0\uD070 \uBBF8\uB9CC\uC5D0\uC11C\uB294 \uB3D9\uC77C\uD55C \uAC00\uACA9. Max \uAD6C\uB3C5\uC774 \uD544\uC694\uD569\uB2C8\uB2E4."
  },
  maxTabs: {
    name: "\uCD5C\uB300 \uCC44\uD305 \uD0ED \uC218",
    desc: "\uB3D9\uC2DC\uC5D0 \uC5F4 \uC218 \uC788\uB294 \uCD5C\uB300 \uCC44\uD305 \uD0ED \uC218(3-10). \uAC01 \uD0ED\uC740 \uBCC4\uB3C4\uC758 Claude \uC138\uC158\uC744 \uC0AC\uC6A9\uD569\uB2C8\uB2E4.",
    warning: "5\uAC1C \uD0ED\uC744 \uCD08\uACFC\uD558\uBA74 \uC131\uB2A5 \uBC0F \uBA54\uBAA8\uB9AC \uC0AC\uC6A9\uB7C9\uC5D0 \uC601\uD5A5\uC744 \uC904 \uC218 \uC788\uC2B5\uB2C8\uB2E4.",
    range: "{min} - {max}"
  },
  cliPath: {
    name: "Claude CLI \uACBD\uB85C",
    desc: "Claude Code CLI\uC758 \uC0AC\uC6A9\uC790 \uC815\uC758 \uACBD\uB85C. \uBE44\uC6CC\uB450\uBA74 \uC790\uB3D9 \uAC10\uC9C0 \uC0AC\uC6A9.",
    descWindows: "\uB124\uC774\uD2F0\uBE0C \uC124\uCE58 \uD504\uB85C\uADF8\uB7A8\uC758 \uACBD\uC6B0 claude.exe\uB97C \uC0AC\uC6A9\uD558\uC138\uC694. npm/pnpm/yarn \uB610\uB294 \uAE30\uD0C0 \uD328\uD0A4\uC9C0 \uAD00\uB9AC\uC790 \uC124\uCE58\uC758 \uACBD\uC6B0 cli.js \uACBD\uB85C\uB97C \uC0AC\uC6A9\uD558\uC138\uC694 (claude.cmd\uAC00 \uC544\uB2D8).",
    descUnix: '"which claude"\uC758 \uCD9C\uB825\uC744 \uBD99\uC5EC\uB123\uC73C\uC138\uC694 - \uB124\uC774\uD2F0\uBE0C \uBC0F npm/pnpm/yarn \uC124\uCE58 \uBAA8\uB450\uC5D0\uC11C \uC791\uB3D9\uD569\uB2C8\uB2E4.',
    validation: {
      notExist: "\uACBD\uB85C\uAC00 \uC874\uC7AC\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4",
      isDirectory: "\uACBD\uB85C\uAC00 \uB514\uB809\uD1A0\uB9AC\uC785\uB2C8\uB2E4 \uD30C\uC77C\uC774 \uC544\uB2D9\uB2C8\uB2E4"
    }
  },
  language: {
    name: "\uC5B8\uC5B4",
    desc: "\uD50C\uB7EC\uADF8\uC778 \uC778\uD130\uD398\uC774\uC2A4\uC758 \uD45C\uC2DC \uC5B8\uC5B4 \uBCC0\uACBD",
    en: "English",
    "zh-CN": "\u7B80\u4F53\u4E2D\u6587",
    "zh-TW": "\u7E41\u9AD4\u4E2D\u6587",
    ja: "\u65E5\u672C\u8A9E",
    ko: "\uD55C\uAD6D\uC5B4",
    de: "Deutsch",
    fr: "Fran\xE7ais",
    es: "Espa\xF1ol",
    ru: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439",
    pt: "Portugu\xEAs"
  }
};
var ko_default = {
  common: common6,
  settings: settings6
};

// src/i18n/locales/pt.json
var pt_exports = {};
__export(pt_exports, {
  common: () => common7,
  default: () => pt_default,
  settings: () => settings7
});
var common7 = {
  save: "Salvar",
  cancel: "Cancelar",
  delete: "Excluir",
  edit: "Editar",
  add: "Adicionar",
  remove: "Remover",
  clear: "Limpar",
  clearAll: "Limpar tudo",
  loading: "Carregando",
  error: "Erro",
  success: "Sucesso",
  warning: "Aviso",
  confirm: "Confirmar",
  settings: "Configura\xE7\xF5es",
  advanced: "Avan\xE7ado",
  enabled: "Ativado",
  disabled: "Desativado",
  platform: "Plataforma"
};
var settings7 = {
  title: "Configura\xE7\xF5es do Claudian",
  customization: "Personaliza\xE7\xE3o",
  userName: {
    name: "Como o Claudian deve cham\xE1-lo?",
    desc: "Seu nome para sauda\xE7\xF5es personalizadas (deixe vazio para sauda\xE7\xF5es gen\xE9ricas)"
  },
  excludedTags: {
    name: "Tags exclu\xEDdas",
    desc: "Notas com estas tags n\xE3o ser\xE3o carregadas automaticamente como contexto (uma por linha, sem #)"
  },
  mediaFolder: {
    name: "Pasta de m\xEDdia",
    desc: "Pasta contendo anexos/imagens. Quando notas usam ![[image.jpg]], Claude procurar\xE1 aqui. Deixe vazio para a raiz do reposit\xF3rio."
  },
  systemPrompt: {
    name: "Prompt de sistema personalizado",
    desc: "Instru\xE7\xF5es adicionais anexadas ao prompt de sistema padr\xE3o"
  },
  autoTitle: {
    name: "Gerar automaticamente t\xEDtulos de conversa",
    desc: "Gera automaticamente t\xEDtulos de conversa ap\xF3s o primeiro interc\xE2mbio."
  },
  titleModel: {
    name: "Modelo de gera\xE7\xE3o de t\xEDtulo",
    desc: "Modelo usado para gerar automaticamente t\xEDtulos de conversa.",
    auto: "Auto (Haiku)"
  },
  navMappings: {
    name: "Mapeamentos de navega\xE7\xE3o estilo Vim",
    desc: 'Um mapeamento por linha. Formato: "map <tecla> <a\xE7\xE3o>" (a\xE7\xF5es: scrollUp, scrollDown, focusInput).'
  },
  hotkeys: "Atalhos",
  inlineEditHotkey: {
    name: "Atalho de edi\xE7\xE3o em linha",
    descNoKey: "Nenhum atalho definido. Clique para configurar.",
    descWithKey: "Atual: {hotkey}",
    btnSet: "Definir atalho",
    btnChange: "Alterar"
  },
  openChatHotkey: {
    name: "Atalho para abrir chat",
    descNoKey: "Nenhum atalho definido. Clique para configurar.",
    descWithKey: "Atual: {hotkey}",
    btnSet: "Definir atalho",
    btnChange: "Alterar"
  },
  newTabHotkey: {
    name: "Atalho nova aba",
    descNoKey: "Nenhum atalho definido. Clique para configurar.",
    descWithKey: "Atual: {hotkey}",
    btnSet: "Definir atalho",
    btnChange: "Alterar"
  },
  newSessionHotkey: {
    name: "Atalho nova sess\xE3o",
    descNoKey: "Nenhum atalho definido. Clique para configurar.",
    descWithKey: "Atual: {hotkey}",
    btnSet: "Definir atalho",
    btnChange: "Alterar"
  },
  closeTabHotkey: {
    name: "Atalho fechar aba",
    descNoKey: "Nenhum atalho definido. Clique para configurar.",
    descWithKey: "Atual: {hotkey}",
    btnSet: "Definir atalho",
    btnChange: "Alterar"
  },
  slashCommands: {
    name: "Comandos slash",
    desc: "Crie modelos de prompts personalizados acionados por /command. Use $ARGUMENTS para todos os argumentos, $1/$2 para argumentos posicionais, @file para conte\xFAdo de arquivo e !`bash` para sa\xEDda de comando."
  },
  mcpServers: {
    name: "Servidores MCP",
    desc: "Configure servidores Model Context Protocol para estender as capacidades do Claude com ferramentas e fontes de dados externas. Servidores com modo de salvamento de contexto exigem @mention para ativar."
  },
  plugins: {
    name: "Plugins do Claude Code",
    desc: "Ative ou desative plugins do Claude Code descobertos em ~/.claude/plugins. Plugins ativados s\xE3o armazenados por cofre."
  },
  safety: "Seguran\xE7a",
  loadUserSettings: {
    name: "Carregar configura\xE7\xF5es do usu\xE1rio Claude",
    desc: "Carrega ~/.claude/settings.json. Quando habilitado, as regras de permiss\xE3o do usu\xE1rio podem ignorar o modo seguro."
  },
  enableBlocklist: {
    name: "Habilitar lista negra de comandos",
    desc: "Bloqueia comandos bash potencialmente perigosos"
  },
  blockedCommands: {
    name: "Comandos bloqueados ({platform})",
    desc: "Padr\xF5es para bloquear em {platform} (um por linha). Suporta express\xF5es regulares.",
    unixName: "Comandos bloqueados (Unix/Git Bash)",
    unixDesc: "Padr\xF5es Unix tamb\xE9m bloqueados no Windows porque Git Bash pode invoc\xE1-los."
  },
  exportPaths: {
    name: "Caminhos de exporta\xE7\xE3o permitidos",
    desc: "Caminhos fora do reposit\xF3rio onde arquivos podem ser exportados (um por linha). Suporta ~ para diret\xF3rio home."
  },
  environment: "Ambiente",
  customVariables: {
    name: "Vari\xE1veis personalizadas",
    desc: "Vari\xE1veis de ambiente para Claude SDK (formato KEY=VALUE, uma por linha)"
  },
  envSnippets: {
    name: "Snippets de ambiente",
    addBtn: "Adicionar snippet",
    editBtn: "Editar",
    deleteBtn: "Excluir",
    useBtn: "Usar",
    noSnippets: "Nenhum snippet de ambiente salvo.",
    modal: {
      title: "Snippet de ambiente",
      name: "Nome",
      namePlaceholder: "ex: API de Produ\xE7\xE3o",
      description: "Descri\xE7\xE3o",
      descPlaceholder: "Descri\xE7\xE3o opcional",
      envVars: "Vari\xE1veis de ambiente",
      envVarsPlaceholder: "ANTHROPIC_API_KEY=your-key\nANTHROPIC_BASE_URL=https://api.example.com",
      save: "Salvar",
      cancel: "Cancelar"
    }
  },
  advanced: "Avan\xE7ado",
  show1MModel: {
    name: "Habilitar Sonnet com janela de contexto de 1M",
    desc: "Substituir Sonnet padr\xE3o por Sonnet (1M) no seletor de modelos. Mesmo pre\xE7o abaixo de 200k tokens. Requer assinatura Max."
  },
  maxTabs: {
    name: "M\xE1ximo de abas de chat",
    desc: "N\xFAmero m\xE1ximo de abas de chat simult\xE2neas (3-10). Cada aba usa uma sess\xE3o Claude separada.",
    warning: "Mais de 5 abas pode afetar o desempenho e o uso de mem\xF3ria.",
    range: "{min} - {max}"
  },
  cliPath: {
    name: "Caminho CLI Claude",
    desc: "Caminho personalizado para Claude Code CLI. Deixe vazio para detec\xE7\xE3o autom\xE1tica.",
    descWindows: "Para o instalador nativo, use claude.exe. Para instala\xE7\xF5es com npm/pnpm/yarn ou outros gerenciadores de pacotes, use o caminho cli.js (n\xE3o claude.cmd).",
    descUnix: 'Cole a sa\xEDda de "which claude" \u2014 funciona tanto para instala\xE7\xF5es nativas quanto npm/pnpm/yarn.',
    validation: {
      notExist: "Caminho n\xE3o existe",
      isDirectory: "Caminho \xE9 um diret\xF3rio, n\xE3o um arquivo"
    }
  },
  language: {
    name: "Idioma",
    desc: "Alterar o idioma de exibi\xE7\xE3o da interface do plugin",
    en: "English",
    "zh-CN": "\u7B80\u4F53\u4E2D\u6587",
    "zh-TW": "\u7E41\u9AD4\u4E2D\u6587",
    ja: "\u65E5\u672C\u8A9E",
    ko: "\uD55C\uAD6D\uC5B4",
    de: "Deutsch",
    fr: "Fran\xE7ais",
    es: "Espa\xF1ol",
    ru: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439",
    pt: "Portugu\xEAs"
  }
};
var pt_default = {
  common: common7,
  settings: settings7
};

// src/i18n/locales/ru.json
var ru_exports = {};
__export(ru_exports, {
  common: () => common8,
  default: () => ru_default,
  settings: () => settings8
});
var common8 = {
  save: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C",
  cancel: "\u041E\u0442\u043C\u0435\u043D\u0430",
  delete: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C",
  edit: "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C",
  add: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C",
  remove: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C",
  clear: "\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u044C",
  clearAll: "\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u044C \u0432\u0441\u0451",
  loading: "\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430",
  error: "\u041E\u0448\u0438\u0431\u043A\u0430",
  success: "\u0423\u0441\u043F\u0435\u0445",
  warning: "\u041F\u0440\u0435\u0434\u0443\u043F\u0440\u0435\u0436\u0434\u0435\u043D\u0438\u0435",
  confirm: "\u041F\u043E\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u044C",
  settings: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438",
  advanced: "\u0414\u043E\u043F\u043E\u043B\u043D\u0438\u0442\u0435\u043B\u044C\u043D\u043E",
  enabled: "\u0412\u043A\u043B\u044E\u0447\u0435\u043D\u043E",
  disabled: "\u041E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u043E",
  platform: "\u041F\u043B\u0430\u0442\u0444\u043E\u0440\u043C\u0430"
};
var settings8 = {
  title: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 Claudian",
  customization: "\u041F\u0435\u0440\u0441\u043E\u043D\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F",
  userName: {
    name: "\u041A\u0430\u043A Claudian \u0434\u043E\u043B\u0436\u0435\u043D \u043E\u0431\u0440\u0430\u0449\u0430\u0442\u044C\u0441\u044F \u043A \u0432\u0430\u043C?",
    desc: "\u0412\u0430\u0448\u0435 \u0438\u043C\u044F \u0434\u043B\u044F \u043F\u0435\u0440\u0441\u043E\u043D\u0430\u043B\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0445 \u043F\u0440\u0438\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0439 (\u043E\u0441\u0442\u0430\u0432\u044C\u0442\u0435 \u043F\u0443\u0441\u0442\u044B\u043C \u0434\u043B\u044F \u043E\u0431\u0449\u0438\u0445 \u043F\u0440\u0438\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0439)"
  },
  excludedTags: {
    name: "\u0418\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044B\u0435 \u0442\u0435\u0433\u0438",
    desc: "\u0417\u0430\u043C\u0435\u0442\u043A\u0438 \u0441 \u044D\u0442\u0438\u043C\u0438 \u0442\u0435\u0433\u0430\u043C\u0438 \u043D\u0435 \u0431\u0443\u0434\u0443\u0442 \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u0437\u0430\u0433\u0440\u0443\u0436\u0430\u0442\u044C\u0441\u044F \u043A\u0430\u043A \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442 (\u043F\u043E \u043E\u0434\u043D\u043E\u043C\u0443 \u0432 \u0441\u0442\u0440\u043E\u043A\u0435, \u0431\u0435\u0437 #)"
  },
  mediaFolder: {
    name: "\u041F\u0430\u043F\u043A\u0430 \u043C\u0435\u0434\u0438\u0430\u0444\u0430\u0439\u043B\u043E\u0432",
    desc: "\u041F\u0430\u043F\u043A\u0430 \u0441 \u0432\u043B\u043E\u0436\u0435\u043D\u0438\u044F\u043C\u0438/\u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F\u043C\u0438. \u041A\u043E\u0433\u0434\u0430 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u044E\u0442 ![[image.jpg]], Claude \u0431\u0443\u0434\u0435\u0442 \u0438\u0441\u043A\u0430\u0442\u044C \u0437\u0434\u0435\u0441\u044C. \u041E\u0441\u0442\u0430\u0432\u044C\u0442\u0435 \u043F\u0443\u0441\u0442\u044B\u043C \u0434\u043B\u044F \u043A\u043E\u0440\u043D\u044F \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430."
  },
  systemPrompt: {
    name: "\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0439 \u0441\u0438\u0441\u0442\u0435\u043C\u043D\u044B\u0439 \u043F\u0440\u043E\u043C\u043F\u0442",
    desc: "\u0414\u043E\u043F\u043E\u043B\u043D\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0435 \u0438\u043D\u0441\u0442\u0440\u0443\u043A\u0446\u0438\u0438, \u0434\u043E\u0431\u0430\u0432\u043B\u044F\u0435\u043C\u044B\u0435 \u043A \u0441\u0438\u0441\u0442\u0435\u043C\u043D\u043E\u043C\u0443 \u043F\u0440\u043E\u043C\u043F\u0442\u0443 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E"
  },
  autoTitle: {
    name: "\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u0433\u0435\u043D\u0435\u0440\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u0438 \u0431\u0435\u0441\u0435\u0434",
    desc: "\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u0433\u0435\u043D\u0435\u0440\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u0438 \u0431\u0435\u0441\u0435\u0434 \u043F\u043E\u0441\u043B\u0435 \u043F\u0435\u0440\u0432\u043E\u0433\u043E \u043E\u0431\u043C\u0435\u043D\u0430 \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u044F\u043C\u0438."
  },
  titleModel: {
    name: "\u041C\u043E\u0434\u0435\u043B\u044C \u0433\u0435\u043D\u0435\u0440\u0430\u0446\u0438\u0438 \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u043E\u0432",
    desc: "\u041C\u043E\u0434\u0435\u043B\u044C, \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u043C\u0430\u044F \u0434\u043B\u044F \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u043E\u0439 \u0433\u0435\u043D\u0435\u0440\u0430\u0446\u0438\u0438 \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u043E\u0432 \u0431\u0435\u0441\u0435\u0434.",
    auto: "\u0410\u0432\u0442\u043E (Haiku)"
  },
  navMappings: {
    name: "\u0421\u043E\u043F\u043E\u0441\u0442\u0430\u0432\u043B\u0435\u043D\u0438\u044F \u043D\u0430\u0432\u0438\u0433\u0430\u0446\u0438\u0438 \u0432 \u0441\u0442\u0438\u043B\u0435 Vim",
    desc: '\u041F\u043E \u043E\u0434\u043D\u043E\u043C\u0443 \u0441\u043E\u043F\u043E\u0441\u0442\u0430\u0432\u043B\u0435\u043D\u0438\u044E \u0432 \u0441\u0442\u0440\u043E\u043A\u0435. \u0424\u043E\u0440\u043C\u0430\u0442: "map <\u043A\u043B\u044E\u0447> <\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435>" (\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F: scrollUp, scrollDown, focusInput).'
  },
  hotkeys: "\u0413\u043E\u0440\u044F\u0447\u0438\u0435 \u043A\u043B\u0430\u0432\u0438\u0448\u0438",
  inlineEditHotkey: {
    name: "\u0413\u043E\u0440\u044F\u0447\u0430\u044F \u043A\u043B\u0430\u0432\u0438\u0448\u0430 \u0434\u043B\u044F \u0432\u0441\u0442\u0440\u043E\u0435\u043D\u043D\u043E\u0433\u043E \u0440\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F",
    descNoKey: "\u0413\u043E\u0440\u044F\u0447\u0430\u044F \u043A\u043B\u0430\u0432\u0438\u0448\u0430 \u043D\u0435 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u0430. \u041D\u0430\u0436\u043C\u0438\u0442\u0435 \u0434\u043B\u044F \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438.",
    descWithKey: "\u0422\u0435\u043A\u0443\u0449\u0430\u044F: {hotkey}",
    btnSet: "\u0423\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u0433\u043E\u0440\u044F\u0447\u0443\u044E \u043A\u043B\u0430\u0432\u0438\u0448\u0443",
    btnChange: "\u0418\u0437\u043C\u0435\u043D\u0438\u0442\u044C"
  },
  openChatHotkey: {
    name: "\u0413\u043E\u0440\u044F\u0447\u0430\u044F \u043A\u043B\u0430\u0432\u0438\u0448\u0430 \u0434\u043B\u044F \u043E\u0442\u043A\u0440\u044B\u0442\u0438\u044F \u0447\u0430\u0442\u0430",
    descNoKey: "\u0413\u043E\u0440\u044F\u0447\u0430\u044F \u043A\u043B\u0430\u0432\u0438\u0448\u0430 \u043D\u0435 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u0430. \u041D\u0430\u0436\u043C\u0438\u0442\u0435 \u0434\u043B\u044F \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438.",
    descWithKey: "\u0422\u0435\u043A\u0443\u0449\u0430\u044F: {hotkey}",
    btnSet: "\u0423\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u0433\u043E\u0440\u044F\u0447\u0443\u044E \u043A\u043B\u0430\u0432\u0438\u0448\u0443",
    btnChange: "\u0418\u0437\u043C\u0435\u043D\u0438\u0442\u044C"
  },
  newTabHotkey: {
    name: "\u0413\u043E\u0440\u044F\u0447\u0430\u044F \u043A\u043B\u0430\u0432\u0438\u0448\u0430 \u0434\u043B\u044F \u043D\u043E\u0432\u043E\u0439 \u0432\u043A\u043B\u0430\u0434\u043A\u0438",
    descNoKey: "\u0413\u043E\u0440\u044F\u0447\u0430\u044F \u043A\u043B\u0430\u0432\u0438\u0448\u0430 \u043D\u0435 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u0430. \u041D\u0430\u0436\u043C\u0438\u0442\u0435 \u0434\u043B\u044F \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438.",
    descWithKey: "\u0422\u0435\u043A\u0443\u0449\u0430\u044F: {hotkey}",
    btnSet: "\u0423\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u0433\u043E\u0440\u044F\u0447\u0443\u044E \u043A\u043B\u0430\u0432\u0438\u0448\u0443",
    btnChange: "\u0418\u0437\u043C\u0435\u043D\u0438\u0442\u044C"
  },
  newSessionHotkey: {
    name: "\u0413\u043E\u0440\u044F\u0447\u0430\u044F \u043A\u043B\u0430\u0432\u0438\u0448\u0430 \u0434\u043B\u044F \u043D\u043E\u0432\u043E\u0439 \u0441\u0435\u0441\u0441\u0438\u0438",
    descNoKey: "\u0413\u043E\u0440\u044F\u0447\u0430\u044F \u043A\u043B\u0430\u0432\u0438\u0448\u0430 \u043D\u0435 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u0430. \u041D\u0430\u0436\u043C\u0438\u0442\u0435 \u0434\u043B\u044F \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438.",
    descWithKey: "\u0422\u0435\u043A\u0443\u0449\u0430\u044F: {hotkey}",
    btnSet: "\u0423\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u0433\u043E\u0440\u044F\u0447\u0443\u044E \u043A\u043B\u0430\u0432\u0438\u0448\u0443",
    btnChange: "\u0418\u0437\u043C\u0435\u043D\u0438\u0442\u044C"
  },
  closeTabHotkey: {
    name: "\u0413\u043E\u0440\u044F\u0447\u0430\u044F \u043A\u043B\u0430\u0432\u0438\u0448\u0430 \u0434\u043B\u044F \u0437\u0430\u043A\u0440\u044B\u0442\u0438\u044F \u0432\u043A\u043B\u0430\u0434\u043A\u0438",
    descNoKey: "\u0413\u043E\u0440\u044F\u0447\u0430\u044F \u043A\u043B\u0430\u0432\u0438\u0448\u0430 \u043D\u0435 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u0430. \u041D\u0430\u0436\u043C\u0438\u0442\u0435 \u0434\u043B\u044F \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438.",
    descWithKey: "\u0422\u0435\u043A\u0443\u0449\u0430\u044F: {hotkey}",
    btnSet: "\u0423\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u0433\u043E\u0440\u044F\u0447\u0443\u044E \u043A\u043B\u0430\u0432\u0438\u0448\u0443",
    btnChange: "\u0418\u0437\u043C\u0435\u043D\u0438\u0442\u044C"
  },
  slashCommands: {
    name: "\u041A\u043E\u043C\u0430\u043D\u0434\u044B \u0441\u043E \u0441\u043B\u044D\u0448\u0435\u043C",
    desc: "\u0421\u043E\u0437\u0434\u0430\u0432\u0430\u0439\u0442\u0435 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0435 \u0448\u0430\u0431\u043B\u043E\u043D\u044B \u043F\u0440\u043E\u043C\u043F\u0442\u043E\u0432, \u0437\u0430\u043F\u0443\u0441\u043A\u0430\u0435\u043C\u044B\u0435 \u0447\u0435\u0440\u0435\u0437 /command. \u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435 $ARGUMENTS \u0434\u043B\u044F \u0432\u0441\u0435\u0445 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442\u043E\u0432, $1/$2 \u0434\u043B\u044F \u043F\u043E\u0437\u0438\u0446\u0438\u043E\u043D\u043D\u044B\u0445 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442\u043E\u0432, @file \u0434\u043B\u044F \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u043E\u0433\u043E \u0444\u0430\u0439\u043B\u0430 \u0438 !`bash` \u0434\u043B\u044F \u0432\u044B\u0432\u043E\u0434\u0430 \u043A\u043E\u043C\u0430\u043D\u0434\u044B."
  },
  mcpServers: {
    name: "MCP \u0441\u0435\u0440\u0432\u0435\u0440\u044B",
    desc: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u0442\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u044B Model Context Protocol \u0434\u043B\u044F \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043D\u0438\u044F \u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E\u0441\u0442\u0435\u0439 Claude \u0441 \u043F\u043E\u043C\u043E\u0449\u044C\u044E \u0432\u043D\u0435\u0448\u043D\u0438\u0445 \u0438\u043D\u0441\u0442\u0440\u0443\u043C\u0435\u043D\u0442\u043E\u0432 \u0438 \u0438\u0441\u0442\u043E\u0447\u043D\u0438\u043A\u043E\u0432 \u0434\u0430\u043D\u043D\u044B\u0445. \u0421\u0435\u0440\u0432\u0435\u0440\u044B \u0441 \u0440\u0435\u0436\u0438\u043C\u043E\u043C \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u044F \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u0430 \u0442\u0440\u0435\u0431\u0443\u044E\u0442 @mention \u0434\u043B\u044F \u0430\u043A\u0442\u0438\u0432\u0430\u0446\u0438\u0438."
  },
  plugins: {
    name: "\u041F\u043B\u0430\u0433\u0438\u043D\u044B Claude Code",
    desc: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u0435 \u0438\u043B\u0438 \u043E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u0435 \u043F\u043B\u0430\u0433\u0438\u043D\u044B Claude Code \u0438\u0437 ~/.claude/plugins. \u0412\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044B\u0435 \u043F\u043B\u0430\u0433\u0438\u043D\u044B \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u044E\u0442\u0441\u044F \u0434\u043B\u044F \u043A\u0430\u0436\u0434\u043E\u0433\u043E \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430."
  },
  safety: "\u0411\u0435\u0437\u043E\u043F\u0430\u0441\u043D\u043E\u0441\u0442\u044C",
  loadUserSettings: {
    name: "\u0417\u0430\u0433\u0440\u0443\u0436\u0430\u0442\u044C \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 Claude",
    desc: "\u0417\u0430\u0433\u0440\u0443\u0436\u0430\u0435\u0442 ~/.claude/settings.json. \u041F\u0440\u0438 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0438 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0435 \u043F\u0440\u0430\u0432\u0438\u043B\u0430 \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043D\u0438\u0439 Claude Code \u043C\u043E\u0433\u0443\u0442 \u043E\u0431\u0445\u043E\u0434\u0438\u0442\u044C \u0431\u0435\u0437\u043E\u043F\u0430\u0441\u043D\u044B\u0439 \u0440\u0435\u0436\u0438\u043C."
  },
  enableBlocklist: {
    name: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0447\u0435\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A \u043A\u043E\u043C\u0430\u043D\u0434",
    desc: "\u0411\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u043E\u0442\u0435\u043D\u0446\u0438\u0430\u043B\u044C\u043D\u043E \u043E\u043F\u0430\u0441\u043D\u044B\u0435 bash \u043A\u043E\u043C\u0430\u043D\u0434\u044B"
  },
  blockedCommands: {
    name: "\u0417\u0430\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0435 \u043A\u043E\u043C\u0430\u043D\u0434\u044B ({platform})",
    desc: "\u0428\u0430\u0431\u043B\u043E\u043D\u044B \u0434\u043B\u044F \u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u043A\u0438 \u043D\u0430 {platform} (\u043F\u043E \u043E\u0434\u043D\u043E\u043C\u0443 \u0432 \u0441\u0442\u0440\u043E\u043A\u0435). \u041F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u044E\u0442\u0441\u044F \u0440\u0435\u0433\u0443\u043B\u044F\u0440\u043D\u044B\u0435 \u0432\u044B\u0440\u0430\u0436\u0435\u043D\u0438\u044F.",
    unixName: "\u0417\u0430\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0435 \u043A\u043E\u043C\u0430\u043D\u0434\u044B (Unix/Git Bash)",
    unixDesc: "Unix \u0448\u0430\u0431\u043B\u043E\u043D\u044B \u0442\u0430\u043A\u0436\u0435 \u0431\u043B\u043E\u043A\u0438\u0440\u0443\u044E\u0442\u0441\u044F \u043D\u0430 Windows, \u0442\u0430\u043A \u043A\u0430\u043A Git Bash \u043C\u043E\u0436\u0435\u0442 \u0438\u0445 \u0432\u044B\u0437\u044B\u0432\u0430\u0442\u044C."
  },
  exportPaths: {
    name: "\u0420\u0430\u0437\u0440\u0435\u0448\u0435\u043D\u043D\u044B\u0435 \u043F\u0443\u0442\u0438 \u044D\u043A\u0441\u043F\u043E\u0440\u0442\u0430",
    desc: "\u041F\u0443\u0442\u0438 \u0432\u043D\u0435 \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430, \u043A\u0443\u0434\u0430 \u043C\u043E\u0436\u043D\u043E \u044D\u043A\u0441\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0444\u0430\u0439\u043B\u044B (\u043F\u043E \u043E\u0434\u043D\u043E\u043C\u0443 \u0432 \u0441\u0442\u0440\u043E\u043A\u0435). \u041F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442 ~ \u0434\u043B\u044F \u0434\u043E\u043C\u0430\u0448\u043D\u0435\u0433\u043E \u043A\u0430\u0442\u0430\u043B\u043E\u0433\u0430."
  },
  environment: "\u041E\u043A\u0440\u0443\u0436\u0435\u043D\u0438\u0435",
  customVariables: {
    name: "\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0435 \u043F\u0435\u0440\u0435\u043C\u0435\u043D\u043D\u044B\u0435",
    desc: "\u041F\u0435\u0440\u0435\u043C\u0435\u043D\u043D\u044B\u0435 \u043E\u043A\u0440\u0443\u0436\u0435\u043D\u0438\u044F \u0434\u043B\u044F Claude SDK (\u0444\u043E\u0440\u043C\u0430\u0442 KEY=VALUE, \u043F\u043E \u043E\u0434\u043D\u043E\u0439 \u0432 \u0441\u0442\u0440\u043E\u043A\u0435)"
  },
  envSnippets: {
    name: "\u0421\u043D\u0438\u043F\u043F\u0435\u0442\u044B \u043E\u043A\u0440\u0443\u0436\u0435\u043D\u0438\u044F",
    addBtn: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0441\u043D\u0438\u043F\u043F\u0435\u0442",
    editBtn: "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C",
    deleteBtn: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C",
    useBtn: "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C",
    noSnippets: "\u041D\u0435\u0442 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u043D\u044B\u0445 \u0441\u043D\u0438\u043F\u043F\u0435\u0442\u043E\u0432 \u043E\u043A\u0440\u0443\u0436\u0435\u043D\u0438\u044F.",
    modal: {
      title: "\u0421\u043D\u0438\u043F\u043F\u0435\u0442 \u043E\u043A\u0440\u0443\u0436\u0435\u043D\u0438\u044F",
      name: "\u0418\u043C\u044F",
      namePlaceholder: "\u043D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: Production API",
      description: "\u041E\u043F\u0438\u0441\u0430\u043D\u0438\u0435",
      descPlaceholder: "\u041E\u043F\u0446\u0438\u043E\u043D\u0430\u043B\u044C\u043D\u043E\u0435 \u043E\u043F\u0438\u0441\u0430\u043D\u0438\u0435",
      envVars: "\u041F\u0435\u0440\u0435\u043C\u0435\u043D\u043D\u044B\u0435 \u043E\u043A\u0440\u0443\u0436\u0435\u043D\u0438\u044F",
      envVarsPlaceholder: "ANTHROPIC_API_KEY=your-key\nANTHROPIC_BASE_URL=https://api.example.com",
      save: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C",
      cancel: "\u041E\u0442\u043C\u0435\u043D\u0430"
    }
  },
  advanced: "\u0414\u043E\u043F\u043E\u043B\u043D\u0438\u0442\u0435\u043B\u044C\u043D\u043E",
  show1MModel: {
    name: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C Sonnet \u0441 \u043E\u043A\u043D\u043E\u043C \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u0430 1M",
    desc: "\u0417\u0430\u043C\u0435\u043D\u0438\u0442\u044C \u0441\u0442\u0430\u043D\u0434\u0430\u0440\u0442\u043D\u044B\u0439 Sonnet \u043D\u0430 Sonnet (1M) \u0432 \u0432\u044B\u0431\u043E\u0440\u0435 \u043C\u043E\u0434\u0435\u043B\u0435\u0439. \u0422\u0430 \u0436\u0435 \u0446\u0435\u043D\u0430 \u0434\u043E 200k \u0442\u043E\u043A\u0435\u043D\u043E\u0432. \u0422\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044F \u043F\u043E\u0434\u043F\u0438\u0441\u043A\u0430 Max."
  },
  maxTabs: {
    name: "\u041C\u0430\u043A\u0441\u0438\u043C\u0443\u043C \u0432\u043A\u043B\u0430\u0434\u043E\u043A \u0447\u0430\u0442\u0430",
    desc: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u043E\u0434\u043D\u043E\u0432\u0440\u0435\u043C\u0435\u043D\u043D\u044B\u0445 \u0432\u043A\u043B\u0430\u0434\u043E\u043A \u0447\u0430\u0442\u0430 (3-10). \u041A\u0430\u0436\u0434\u0430\u044F \u0432\u043A\u043B\u0430\u0434\u043A\u0430 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442 \u043E\u0442\u0434\u0435\u043B\u044C\u043D\u0443\u044E \u0441\u0435\u0441\u0441\u0438\u044E Claude.",
    warning: "\u0411\u043E\u043B\u0435\u0435 5 \u0432\u043A\u043B\u0430\u0434\u043E\u043A \u043C\u043E\u0436\u0435\u0442 \u043F\u043E\u0432\u043B\u0438\u044F\u0442\u044C \u043D\u0430 \u043F\u0440\u043E\u0438\u0437\u0432\u043E\u0434\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C \u0438 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0435 \u043F\u0430\u043C\u044F\u0442\u0438.",
    range: "{min} - {max}"
  },
  cliPath: {
    name: "\u041F\u0443\u0442\u044C \u043A CLI Claude",
    desc: "\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0439 \u043F\u0443\u0442\u044C \u043A Claude Code CLI. \u041E\u0441\u0442\u0430\u0432\u044C\u0442\u0435 \u043F\u0443\u0441\u0442\u044B\u043C \u0434\u043B\u044F \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u043E\u0433\u043E \u043E\u043F\u0440\u0435\u0434\u0435\u043B\u0435\u043D\u0438\u044F.",
    descWindows: "\u0414\u043B\u044F \u043D\u0430\u0442\u0438\u0432\u043D\u043E\u0433\u043E \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u0449\u0438\u043A\u0430 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435 claude.exe. \u0414\u043B\u044F \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043E\u043A \u0447\u0435\u0440\u0435\u0437 npm/pnpm/yarn \u0438\u043B\u0438 \u0434\u0440\u0443\u0433\u0438\u0435 \u043C\u0435\u043D\u0435\u0434\u0436\u0435\u0440\u044B \u043F\u0430\u043A\u0435\u0442\u043E\u0432 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435 \u043F\u0443\u0442\u044C \u043A cli.js (\u043D\u0435 claude.cmd).",
    descUnix: '\u0412\u0441\u0442\u0430\u0432\u044C\u0442\u0435 \u0432\u044B\u0432\u043E\u0434 \u043A\u043E\u043C\u0430\u043D\u0434\u044B "which claude" \u2014 \u0440\u0430\u0431\u043E\u0442\u0430\u0435\u0442 \u043A\u0430\u043A \u0434\u043B\u044F \u043D\u0430\u0442\u0438\u0432\u043D\u044B\u0445 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043E\u043A, \u0442\u0430\u043A \u0438 \u0434\u043B\u044F npm/pnpm/yarn.',
    validation: {
      notExist: "\u041F\u0443\u0442\u044C \u043D\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442",
      isDirectory: "\u041F\u0443\u0442\u044C \u044F\u0432\u043B\u044F\u0435\u0442\u0441\u044F \u0434\u0438\u0440\u0435\u043A\u0442\u043E\u0440\u0438\u0435\u0439, \u0430 \u043D\u0435 \u0444\u0430\u0439\u043B\u043E\u043C"
    }
  },
  language: {
    name: "\u042F\u0437\u044B\u043A",
    desc: "\u0418\u0437\u043C\u0435\u043D\u0438\u0442\u044C \u044F\u0437\u044B\u043A \u0438\u043D\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430 \u043F\u043B\u0430\u0433\u0438\u043D\u0430",
    en: "English",
    "zh-CN": "\u7B80\u4F53\u4E2D\u6587",
    "zh-TW": "\u7E41\u9AD4\u4E2D\u6587",
    ja: "\u65E5\u672C\u8A9E",
    ko: "\uD55C\uAD6D\uC5B4",
    de: "Deutsch",
    fr: "Fran\xE7ais",
    es: "Espa\xF1ol",
    ru: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439",
    pt: "Portugu\xEAs"
  }
};
var ru_default = {
  common: common8,
  settings: settings8
};

// src/i18n/locales/zh-CN.json
var zh_CN_exports = {};
__export(zh_CN_exports, {
  common: () => common9,
  default: () => zh_CN_default,
  settings: () => settings9
});
var common9 = {
  save: "\u4FDD\u5B58",
  cancel: "\u53D6\u6D88",
  delete: "\u5220\u9664",
  edit: "\u7F16\u8F91",
  add: "\u6DFB\u52A0",
  remove: "\u79FB\u9664",
  clear: "\u6E05\u9664",
  clearAll: "\u6E05\u9664\u5168\u90E8",
  loading: "\u52A0\u8F7D\u4E2D",
  error: "\u9519\u8BEF",
  success: "\u6210\u529F",
  warning: "\u8B66\u544A",
  confirm: "\u786E\u8BA4",
  settings: "\u8BBE\u7F6E",
  advanced: "\u9AD8\u7EA7",
  enabled: "\u5DF2\u542F\u7528",
  disabled: "\u5DF2\u7981\u7528",
  platform: "\u5E73\u53F0"
};
var settings9 = {
  title: "Claudian \u8BBE\u7F6E",
  customization: "\u4E2A\u6027\u5316\u8BBE\u7F6E",
  userName: {
    name: "Claudian \u5E94\u8BE5\u5982\u4F55\u79F0\u547C\u4F60\uFF1F",
    desc: "\u7528\u4E8E\u4E2A\u6027\u5316\u95EE\u5019\u7684\u7528\u6237\u540D\uFF08\u7559\u7A7A\u4F7F\u7528\u901A\u7528\u95EE\u5019\uFF09"
  },
  excludedTags: {
    name: "\u6392\u9664\u7684\u6807\u7B7E",
    desc: "\u5305\u542B\u8FD9\u4E9B\u6807\u7B7E\u7684\u7B14\u8BB0\u4E0D\u4F1A\u81EA\u52A8\u52A0\u8F7D\u4E3A\u4E0A\u4E0B\u6587\uFF08\u6BCF\u884C\u4E00\u4E2A\uFF0C\u4E0D\u5E26 #\uFF09"
  },
  mediaFolder: {
    name: "\u5A92\u4F53\u6587\u4EF6\u5939",
    desc: "\u5B58\u653E\u9644\u4EF6/\u56FE\u7247\u7684\u6587\u4EF6\u5939\u3002\u5F53\u7B14\u8BB0\u4F7F\u7528 ![[image.jpg]] \u65F6\uFF0CClaude \u4F1A\u5728\u6B64\u67E5\u627E\u3002\u7559\u7A7A\u4F7F\u7528\u4ED3\u5E93\u6839\u76EE\u5F55\u3002"
  },
  systemPrompt: {
    name: "\u81EA\u5B9A\u4E49\u7CFB\u7EDF\u63D0\u793A\u8BCD",
    desc: "\u9644\u52A0\u5230\u9ED8\u8BA4\u7CFB\u7EDF\u63D0\u793A\u8BCD\u7684\u989D\u5916\u6307\u4EE4"
  },
  autoTitle: {
    name: "\u81EA\u52A8\u751F\u6210\u5BF9\u8BDD\u6807\u9898",
    desc: "\u5728\u9996\u6B21\u5BF9\u8BDD\u540E\u81EA\u52A8\u751F\u6210\u5BF9\u8BDD\u6807\u9898\u3002"
  },
  titleModel: {
    name: "\u6807\u9898\u751F\u6210\u6A21\u578B",
    desc: "\u7528\u4E8E\u81EA\u52A8\u751F\u6210\u5BF9\u8BDD\u6807\u9898\u7684\u6A21\u578B\u3002",
    auto: "\u81EA\u52A8 (Haiku)"
  },
  navMappings: {
    name: "Vim \u98CE\u683C\u5BFC\u822A\u6620\u5C04",
    desc: '\u6BCF\u884C\u4E00\u4E2A\u6620\u5C04\u3002\u683C\u5F0F\uFF1A"map <\u952E> <\u52A8\u4F5C>"\uFF08\u52A8\u4F5C\uFF1AscrollUp, scrollDown, focusInput\uFF09\u3002'
  },
  hotkeys: "\u5FEB\u6377\u952E",
  inlineEditHotkey: {
    name: "\u5185\u8054\u7F16\u8F91\u5FEB\u6377\u952E",
    descNoKey: "\u672A\u8BBE\u7F6E\u5FEB\u6377\u952E\u3002\u70B9\u51FB\u914D\u7F6E\u3002",
    descWithKey: "\u5F53\u524D\uFF1A{hotkey}",
    btnSet: "\u8BBE\u7F6E\u5FEB\u6377\u952E",
    btnChange: "\u66F4\u6539"
  },
  openChatHotkey: {
    name: "\u6253\u5F00\u804A\u5929\u5FEB\u6377\u952E",
    descNoKey: "\u672A\u8BBE\u7F6E\u5FEB\u6377\u952E\u3002\u70B9\u51FB\u914D\u7F6E\u3002",
    descWithKey: "\u5F53\u524D\uFF1A{hotkey}",
    btnSet: "\u8BBE\u7F6E\u5FEB\u6377\u952E",
    btnChange: "\u66F4\u6539"
  },
  newTabHotkey: {
    name: "\u65B0\u5EFA\u6807\u7B7E\u9875\u5FEB\u6377\u952E",
    descNoKey: "\u672A\u8BBE\u7F6E\u5FEB\u6377\u952E\u3002\u70B9\u51FB\u914D\u7F6E\u3002",
    descWithKey: "\u5F53\u524D\uFF1A{hotkey}",
    btnSet: "\u8BBE\u7F6E\u5FEB\u6377\u952E",
    btnChange: "\u66F4\u6539"
  },
  newSessionHotkey: {
    name: "\u65B0\u5EFA\u4F1A\u8BDD\u5FEB\u6377\u952E",
    descNoKey: "\u672A\u8BBE\u7F6E\u5FEB\u6377\u952E\u3002\u70B9\u51FB\u914D\u7F6E\u3002",
    descWithKey: "\u5F53\u524D\uFF1A{hotkey}",
    btnSet: "\u8BBE\u7F6E\u5FEB\u6377\u952E",
    btnChange: "\u66F4\u6539"
  },
  closeTabHotkey: {
    name: "\u5173\u95ED\u6807\u7B7E\u9875\u5FEB\u6377\u952E",
    descNoKey: "\u672A\u8BBE\u7F6E\u5FEB\u6377\u952E\u3002\u70B9\u51FB\u914D\u7F6E\u3002",
    descWithKey: "\u5F53\u524D\uFF1A{hotkey}",
    btnSet: "\u8BBE\u7F6E\u5FEB\u6377\u952E",
    btnChange: "\u66F4\u6539"
  },
  slashCommands: {
    name: "\u659C\u6760\u547D\u4EE4",
    desc: "\u521B\u5EFA\u7531 /command \u89E6\u53D1\u7684\u81EA\u5B9A\u4E49\u63D0\u793A\u6A21\u677F\u3002\u4F7F\u7528 $ARGUMENTS \u83B7\u53D6\u6240\u6709\u53C2\u6570\uFF0C$1/$2 \u83B7\u53D6\u4F4D\u7F6E\u53C2\u6570\uFF0C@file \u83B7\u53D6\u6587\u4EF6\u5185\u5BB9\uFF0C!`bash` \u83B7\u53D6\u547D\u4EE4\u8F93\u51FA\u3002"
  },
  mcpServers: {
    name: "MCP \u670D\u52A1\u5668",
    desc: "\u914D\u7F6E\u6A21\u578B\u4E0A\u4E0B\u6587\u534F\u8BAE\u670D\u52A1\u5668\uFF0C\u901A\u8FC7\u5916\u90E8\u5DE5\u5177\u548C\u6570\u636E\u6E90\u6269\u5C55 Claude \u7684\u80FD\u529B\u3002\u542F\u7528\u4E0A\u4E0B\u6587\u4FDD\u5B58\u6A21\u5F0F\u7684\u670D\u52A1\u5668\u9700\u8981 @ \u63D0\u53CA\u624D\u80FD\u6FC0\u6D3B\u3002"
  },
  plugins: {
    name: "Claude Code \u63D2\u4EF6",
    desc: "\u542F\u7528\u6216\u7981\u7528\u4ECE ~/.claude/plugins \u53D1\u73B0\u7684 Claude Code \u63D2\u4EF6\u3002\u542F\u7528\u7684\u63D2\u4EF6\u6309 Vault \u5B58\u50A8\u3002"
  },
  safety: "\u5B89\u5168",
  loadUserSettings: {
    name: "\u52A0\u8F7D\u7528\u6237 Claude \u8BBE\u7F6E",
    desc: "\u52A0\u8F7D ~/.claude/settings.json\u3002\u542F\u7528\u540E\uFF0C\u7528\u6237\u7684 Claude Code \u6743\u9650\u89C4\u5219\u53EF\u80FD\u7ED5\u8FC7\u5B89\u5168\u6A21\u5F0F\u3002"
  },
  enableBlocklist: {
    name: "\u542F\u7528\u547D\u4EE4\u9ED1\u540D\u5355",
    desc: "\u963B\u6B62\u6F5C\u5728\u5371\u9669\u7684 bash \u547D\u4EE4"
  },
  blockedCommands: {
    name: "\u963B\u6B62\u7684\u547D\u4EE4 ({platform})",
    desc: "\u5728 {platform} \u4E0A\u963B\u6B62\u7684\u6A21\u5F0F\uFF08\u6BCF\u884C\u4E00\u4E2A\uFF09\u3002\u652F\u6301\u6B63\u5219\u8868\u8FBE\u5F0F\u3002",
    unixName: "\u963B\u6B62\u7684\u547D\u4EE4 (Unix/Git Bash)",
    unixDesc: "Unix \u6A21\u5F0F\u5728 Windows \u4E0A\u4E5F\u4F1A\u88AB\u963B\u6B62\uFF0C\u56E0\u4E3A Git Bash \u53EF\u4EE5\u8C03\u7528\u5B83\u4EEC\u3002"
  },
  exportPaths: {
    name: "\u5141\u8BB8\u7684\u5BFC\u51FA\u8DEF\u5F84",
    desc: "\u5141\u8BB8\u5BFC\u51FA\u6587\u4EF6\u7684\u4ED3\u5E93\u5916\u90E8\u8DEF\u5F84\uFF08\u6BCF\u884C\u4E00\u4E2A\uFF09\u3002\u652F\u6301 ~ \u8868\u793A\u4E3B\u76EE\u5F55\u3002"
  },
  environment: "\u73AF\u5883",
  customVariables: {
    name: "\u81EA\u5B9A\u4E49\u53D8\u91CF",
    desc: "Claude SDK \u7684\u73AF\u5883\u53D8\u91CF\uFF08KEY=VALUE \u683C\u5F0F\uFF0C\u6BCF\u884C\u4E00\u4E2A\uFF09"
  },
  envSnippets: {
    name: "\u73AF\u5883\u53D8\u91CF\u7247\u6BB5",
    addBtn: "\u6DFB\u52A0\u7247\u6BB5",
    editBtn: "\u7F16\u8F91",
    deleteBtn: "\u5220\u9664",
    useBtn: "\u4F7F\u7528",
    noSnippets: "\u5C1A\u65E0\u4FDD\u5B58\u7684\u73AF\u5883\u53D8\u91CF\u7247\u6BB5\u3002",
    modal: {
      title: "\u73AF\u5883\u53D8\u91CF\u7247\u6BB5",
      name: "\u540D\u79F0",
      namePlaceholder: "\u4F8B\u5982\uFF1A\u751F\u4EA7\u73AF\u5883 API",
      description: "\u63CF\u8FF0",
      descPlaceholder: "\u53EF\u9009\u63CF\u8FF0",
      envVars: "\u73AF\u5883\u53D8\u91CF",
      envVarsPlaceholder: "ANTHROPIC_API_KEY=your-key\nANTHROPIC_BASE_URL=https://api.example.com",
      save: "\u4FDD\u5B58",
      cancel: "\u53D6\u6D88"
    }
  },
  advanced: "\u9AD8\u7EA7",
  show1MModel: {
    name: "\u542F\u7528\u5177\u6709 1M \u4E0A\u4E0B\u6587\u7A97\u53E3\u7684 Sonnet",
    desc: "\u5728\u6A21\u578B\u9009\u62E9\u5668\u4E2D\u5C06\u6807\u51C6 Sonnet \u66FF\u6362\u4E3A Sonnet (1M)\u3002\u5728 200k \u4EE4\u724C\u4EE5\u4E0B\u4EF7\u683C\u76F8\u540C\u3002\u9700\u8981 Max \u8BA2\u9605\u3002"
  },
  maxTabs: {
    name: "\u6700\u5927\u804A\u5929\u6807\u7B7E\u6570",
    desc: "\u540C\u65F6\u5F00\u542F\u7684\u6700\u5927\u804A\u5929\u6807\u7B7E\u6570\uFF083-10\uFF09\u3002\u6BCF\u4E2A\u6807\u7B7E\u4F7F\u7528\u72EC\u7ACB\u7684 Claude \u4F1A\u8BDD\u3002",
    warning: "\u8D85\u8FC7 5 \u4E2A\u6807\u7B7E\u53EF\u80FD\u4F1A\u5F71\u54CD\u6027\u80FD\u548C\u5185\u5B58\u4F7F\u7528\u3002",
    range: "{min} - {max}"
  },
  cliPath: {
    name: "Claude CLI \u8DEF\u5F84",
    desc: "Claude Code CLI \u7684\u81EA\u5B9A\u4E49\u8DEF\u5F84\u3002\u7559\u7A7A\u4F7F\u7528\u81EA\u52A8\u68C0\u6D4B\u3002",
    descWindows: "\u5BF9\u4E8E\u539F\u751F\u5B89\u88C5\u7A0B\u5E8F\uFF0C\u4F7F\u7528 claude.exe\u3002\u5BF9\u4E8E npm/pnpm/yarn \u6216\u5176\u4ED6\u5305\u7BA1\u7406\u5668\u5B89\u88C5\uFF0C\u4F7F\u7528 cli.js \u8DEF\u5F84\uFF08\u4E0D\u662F claude.cmd\uFF09\u3002",
    descUnix: '\u7C98\u8D34 "which claude" \u7684\u8F93\u51FA - \u9002\u7528\u4E8E\u539F\u751F\u5B89\u88C5\u548C npm/pnpm/yarn \u5B89\u88C5\u3002',
    validation: {
      notExist: "\u8DEF\u5F84\u4E0D\u5B58\u5728",
      isDirectory: "\u8DEF\u5F84\u662F\u76EE\u5F55\uFF0C\u4E0D\u662F\u6587\u4EF6"
    }
  },
  language: {
    name: "\u8BED\u8A00",
    desc: "\u66F4\u6539\u63D2\u4EF6\u754C\u9762\u7684\u663E\u793A\u8BED\u8A00",
    en: "English",
    "zh-CN": "\u7B80\u4F53\u4E2D\u6587",
    "zh-TW": "\u7E41\u9AD4\u4E2D\u6587",
    ja: "\u65E5\u672C\u8A9E",
    ko: "\uD55C\uAD6D\uC5B4",
    de: "Deutsch",
    fr: "Fran\xE7ais",
    es: "Espa\xF1ol",
    ru: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439",
    pt: "Portugu\xEAs"
  }
};
var zh_CN_default = {
  common: common9,
  settings: settings9
};

// src/i18n/locales/zh-TW.json
var zh_TW_exports = {};
__export(zh_TW_exports, {
  common: () => common10,
  default: () => zh_TW_default,
  settings: () => settings10
});
var common10 = {
  save: "\u4FDD\u5B58",
  cancel: "\u53D6\u6D88",
  delete: "\u522A\u9664",
  edit: "\u7DE8\u8F2F",
  add: "\u6DFB\u52A0",
  remove: "\u79FB\u9664",
  clear: "\u6E05\u9664",
  clearAll: "\u6E05\u9664\u5168\u90E8",
  loading: "\u52A0\u8F09\u4E2D",
  error: "\u932F\u8AA4",
  success: "\u6210\u529F",
  warning: "\u8B66\u544A",
  confirm: "\u78BA\u8A8D",
  settings: "\u8A2D\u7F6E",
  advanced: "\u9AD8\u7D1A",
  enabled: "\u5DF2\u555F\u7528",
  disabled: "\u5DF2\u7981\u7528",
  platform: "\u5E73\u53F0"
};
var settings10 = {
  title: "Claudian \u8A2D\u5B9A",
  customization: "\u500B\u4EBA\u5316\u8A2D\u5B9A",
  userName: {
    name: "Claudian \u61C9\u8A72\u5982\u4F55\u7A31\u547C\u60A8\uFF1F",
    desc: "\u7528\u65BC\u500B\u4EBA\u5316\u554F\u5019\u7684\u4F7F\u7528\u8005\u540D\u7A31\uFF08\u7559\u7A7A\u4F7F\u7528\u901A\u7528\u554F\u5019\uFF09"
  },
  excludedTags: {
    name: "\u6392\u9664\u7684\u6A19\u7C64",
    desc: "\u5305\u542B\u9019\u4E9B\u6A19\u7C64\u7684\u7B46\u8A18\u4E0D\u6703\u81EA\u52D5\u8F09\u5165\u70BA\u4E0A\u4E0B\u6587\uFF08\u6BCF\u884C\u4E00\u500B\uFF0C\u4E0D\u5E36 #\uFF09"
  },
  mediaFolder: {
    name: "\u5A92\u9AD4\u8CC7\u6599\u593E",
    desc: "\u5B58\u653E\u9644\u4EF6/\u5716\u7247\u7684\u8CC7\u6599\u593E\u3002\u7576\u7B46\u8A18\u4F7F\u7528 ![[image.jpg]] \u6642\uFF0CClaude \u6703\u5728\u6B64\u67E5\u627E\u3002\u7559\u7A7A\u4F7F\u7528\u5132\u5B58\u5EAB\u6839\u76EE\u9304\u3002"
  },
  systemPrompt: {
    name: "\u81EA\u8A02\u7CFB\u7D71\u63D0\u793A\u8A5E",
    desc: "\u9644\u52A0\u5230\u9810\u8A2D\u7CFB\u7D71\u63D0\u793A\u8A5E\u7684\u984D\u5916\u6307\u4EE4"
  },
  autoTitle: {
    name: "\u81EA\u52D5\u751F\u6210\u5C0D\u8A71\u6A19\u984C",
    desc: "\u5728\u9996\u6B21\u5C0D\u8A71\u5F8C\u81EA\u52D5\u751F\u6210\u5C0D\u8A71\u6A19\u984C\u3002"
  },
  titleModel: {
    name: "\u6A19\u984C\u751F\u6210\u6A21\u578B",
    desc: "\u7528\u65BC\u81EA\u52D5\u751F\u6210\u5C0D\u8A71\u6A19\u984C\u7684\u6A21\u578B\u3002",
    auto: "\u81EA\u52D5 (Haiku)"
  },
  navMappings: {
    name: "Vim \u98A8\u683C\u5C0E\u822A\u6620\u5C04",
    desc: '\u6BCF\u884C\u4E00\u500B\u6620\u5C04\u3002\u683C\u5F0F\uFF1A"map <\u9375> <\u52D5\u4F5C>"\uFF08\u52D5\u4F5C\uFF1AscrollUp, scrollDown, focusInput\uFF09\u3002'
  },
  hotkeys: "\u5FEB\u6377\u9375",
  inlineEditHotkey: {
    name: "\u5167\u806F\u7DE8\u8F2F\u5FEB\u6377\u9375",
    descNoKey: "\u672A\u8A2D\u5B9A\u5FEB\u6377\u9375\u3002\u9EDE\u64CA\u914D\u7F6E\u3002",
    descWithKey: "\u76EE\u524D\uFF1A{hotkey}",
    btnSet: "\u8A2D\u5B9A\u5FEB\u6377\u9375",
    btnChange: "\u66F4\u6539"
  },
  openChatHotkey: {
    name: "\u958B\u555F\u804A\u5929\u5FEB\u6377\u9375",
    descNoKey: "\u672A\u8A2D\u5B9A\u5FEB\u6377\u9375\u3002\u9EDE\u64CA\u914D\u7F6E\u3002",
    descWithKey: "\u76EE\u524D\uFF1A{hotkey}",
    btnSet: "\u8A2D\u5B9A\u5FEB\u6377\u9375",
    btnChange: "\u66F4\u6539"
  },
  newTabHotkey: {
    name: "\u65B0\u5EFA\u5206\u9801\u5FEB\u6377\u9375",
    descNoKey: "\u672A\u8A2D\u5B9A\u5FEB\u6377\u9375\u3002\u9EDE\u64CA\u914D\u7F6E\u3002",
    descWithKey: "\u76EE\u524D\uFF1A{hotkey}",
    btnSet: "\u8A2D\u5B9A\u5FEB\u6377\u9375",
    btnChange: "\u66F4\u6539"
  },
  newSessionHotkey: {
    name: "\u65B0\u5EFA\u5C0D\u8A71\u5FEB\u6377\u9375",
    descNoKey: "\u672A\u8A2D\u5B9A\u5FEB\u6377\u9375\u3002\u9EDE\u64CA\u914D\u7F6E\u3002",
    descWithKey: "\u76EE\u524D\uFF1A{hotkey}",
    btnSet: "\u8A2D\u5B9A\u5FEB\u6377\u9375",
    btnChange: "\u66F4\u6539"
  },
  closeTabHotkey: {
    name: "\u95DC\u9589\u5206\u9801\u5FEB\u6377\u9375",
    descNoKey: "\u672A\u8A2D\u5B9A\u5FEB\u6377\u9375\u3002\u9EDE\u64CA\u914D\u7F6E\u3002",
    descWithKey: "\u76EE\u524D\uFF1A{hotkey}",
    btnSet: "\u8A2D\u5B9A\u5FEB\u6377\u9375",
    btnChange: "\u66F4\u6539"
  },
  slashCommands: {
    name: "\u659C\u7DDA\u547D\u4EE4",
    desc: "\u5EFA\u7ACB\u7531 /command \u89F8\u767C\u7684\u81EA\u8A02\u63D0\u793A\u7BC4\u672C\u3002\u4F7F\u7528 $ARGUMENTS \u7372\u53D6\u6240\u6709\u53C3\u6578\uFF0C$1/$2 \u7372\u53D6\u4F4D\u7F6E\u53C3\u6578\uFF0C@file \u7372\u53D6\u6A94\u6848\u5167\u5BB9\uFF0C!`bash` \u7372\u53D6\u547D\u4EE4\u8F38\u51FA\u3002"
  },
  mcpServers: {
    name: "MCP \u4F3A\u670D\u5668",
    desc: "\u8A2D\u5B9A\u6A21\u578B\u4E0A\u4E0B\u6587\u5354\u5B9A\u4F3A\u670D\u5668\uFF0C\u900F\u904E\u5916\u90E8\u5DE5\u5177\u548C\u8CC7\u6599\u4F86\u6E90\u64F4\u5C55 Claude \u7684\u80FD\u529B\u3002\u555F\u7528\u4E0A\u4E0B\u6587\u4FDD\u5B58\u6A21\u5F0F\u7684\u4F3A\u670D\u5668\u9700\u8981 @ \u63D0\u53CA\u624D\u80FD\u555F\u7528\u3002"
  },
  plugins: {
    name: "Claude Code \u5916\u639B\u7A0B\u5F0F",
    desc: "\u555F\u7528\u6216\u505C\u7528\u5F9E ~/.claude/plugins \u767C\u73FE\u7684 Claude Code \u5916\u639B\u7A0B\u5F0F\u3002\u5DF2\u555F\u7528\u7684\u5916\u639B\u7A0B\u5F0F\u6309\u5132\u5B58\u5EAB\u5132\u5B58\u3002"
  },
  safety: "\u5B89\u5168",
  loadUserSettings: {
    name: "\u8F09\u5165\u4F7F\u7528\u8005 Claude \u8A2D\u5B9A",
    desc: "\u8F09\u5165 ~/.claude/settings.json\u3002\u555F\u7528\u5F8C\uFF0C\u4F7F\u7528\u8005\u7684 Claude Code \u6B0A\u9650\u898F\u5247\u53EF\u80FD\u7E5E\u904E\u5B89\u5168\u6A21\u5F0F\u3002"
  },
  enableBlocklist: {
    name: "\u555F\u7528\u547D\u4EE4\u9ED1\u540D\u55AE",
    desc: "\u963B\u6B62\u6F5B\u5728\u5371\u96AA\u7684 bash \u547D\u4EE4"
  },
  blockedCommands: {
    name: "\u963B\u6B62\u7684\u547D\u4EE4 ({platform})",
    desc: "\u5728 {platform} \u4E0A\u963B\u6B62\u7684\u6A21\u5F0F\uFF08\u6BCF\u884C\u4E00\u500B\uFF09\u3002\u652F\u63F4\u6B63\u5247\u8868\u793A\u5F0F\u3002",
    unixName: "\u963B\u6B62\u7684\u547D\u4EE4 (Unix/Git Bash)",
    unixDesc: "Unix \u6A21\u5F0F\u5728 Windows \u4E0A\u4E5F\u6703\u88AB\u963B\u6B62\uFF0C\u56E0\u70BA Git Bash \u53EF\u4EE5\u547C\u53EB\u5B83\u5011\u3002"
  },
  exportPaths: {
    name: "\u5141\u8A31\u7684\u532F\u51FA\u8DEF\u5F91",
    desc: "\u5141\u8A31\u532F\u51FA\u6A94\u6848\u7684\u5132\u5B58\u5EAB\u5916\u90E8\u8DEF\u5F91\uFF08\u6BCF\u884C\u4E00\u500B\uFF09\u3002\u652F\u63F4 ~ \u8868\u793A\u4E3B\u76EE\u9304\u3002"
  },
  environment: "\u74B0\u5883",
  customVariables: {
    name: "\u81EA\u8A02\u8B8A\u6578",
    desc: "Claude SDK \u7684\u74B0\u5883\u8B8A\u6578\uFF08KEY=VALUE \u683C\u5F0F\uFF0C\u6BCF\u884C\u4E00\u500B\uFF09"
  },
  envSnippets: {
    name: "\u74B0\u5883\u8B8A\u6578\u7247\u6BB5",
    addBtn: "\u65B0\u589E\u7247\u6BB5",
    editBtn: "\u7DE8\u8F2F",
    deleteBtn: "\u522A\u9664",
    useBtn: "\u4F7F\u7528",
    noSnippets: "\u5C1A\u7121\u4FDD\u5B58\u7684\u74B0\u5883\u8B8A\u6578\u7247\u6BB5\u3002",
    modal: {
      title: "\u74B0\u5883\u8B8A\u6578\u7247\u6BB5",
      name: "\u540D\u7A31",
      namePlaceholder: "\u4F8B\u5982\uFF1A\u751F\u7522\u74B0\u5883 API",
      description: "\u63CF\u8FF0",
      descPlaceholder: "\u53EF\u9078\u63CF\u8FF0",
      envVars: "\u74B0\u5883\u8B8A\u6578",
      envVarsPlaceholder: "ANTHROPIC_API_KEY=your-key\nANTHROPIC_BASE_URL=https://api.example.com",
      save: "\u4FDD\u5B58",
      cancel: "\u53D6\u6D88"
    }
  },
  advanced: "\u9032\u968E",
  show1MModel: {
    name: "\u555F\u7528\u5177\u6709 1M \u4E0A\u4E0B\u6587\u8996\u7A97\u7684 Sonnet",
    desc: "\u5728\u6A21\u578B\u9078\u64C7\u5668\u4E2D\u5C07\u6A19\u6E96 Sonnet \u66FF\u63DB\u70BA Sonnet (1M)\u3002\u5728 200k \u6B0A\u6756\u4EE5\u4E0B\u50F9\u683C\u76F8\u540C\u3002\u9700\u8981 Max \u8A02\u95B1\u3002"
  },
  maxTabs: {
    name: "\u6700\u5927\u804A\u5929\u6A19\u7C64\u6578",
    desc: "\u540C\u6642\u958B\u555F\u7684\u6700\u5927\u804A\u5929\u6A19\u7C64\u6578\uFF083-10\uFF09\u3002\u6BCF\u500B\u6A19\u7C64\u4F7F\u7528\u7368\u7ACB\u7684 Claude \u5C0D\u8A71\u3002",
    warning: "\u8D85\u904E 5 \u500B\u6A19\u7C64\u53EF\u80FD\u6703\u5F71\u97FF\u6548\u80FD\u548C\u8A18\u61B6\u9AD4\u4F7F\u7528\u3002",
    range: "{min} - {max}"
  },
  cliPath: {
    name: "Claude CLI \u8DEF\u5F91",
    desc: "Claude Code CLI \u7684\u81EA\u8A02\u8DEF\u5F91\u3002\u7559\u7A7A\u4F7F\u7528\u81EA\u52D5\u6AA2\u6E2C\u3002",
    descWindows: "\u5C0D\u65BC\u539F\u751F\u5B89\u88DD\u7A0B\u5F0F\uFF0C\u4F7F\u7528 claude.exe\u3002\u5C0D\u65BC npm/pnpm/yarn \u6216\u5176\u4ED6\u5957\u4EF6\u7BA1\u7406\u5668\u5B89\u88DD\uFF0C\u4F7F\u7528 cli.js \u8DEF\u5F91\uFF08\u4E0D\u662F claude.cmd\uFF09\u3002",
    descUnix: '\u8CBC\u4E0A "which claude" \u7684\u8F38\u51FA - \u9069\u7528\u65BC\u539F\u751F\u5B89\u88DD\u548C npm/pnpm/yarn \u5B89\u88DD\u3002',
    validation: {
      notExist: "\u8DEF\u5F91\u4E0D\u5B58\u5728",
      isDirectory: "\u8DEF\u5F91\u662F\u76EE\u9304\uFF0C\u4E0D\u662F\u6A94\u6848"
    }
  },
  language: {
    name: "\u8A9E\u8A00",
    desc: "\u66F4\u6539\u63D2\u4EF6\u4ECB\u9762\u7684\u986F\u793A\u8A9E\u8A00",
    en: "English",
    "zh-CN": "\u7B80\u4F53\u4E2D\u6587",
    "zh-TW": "\u7E41\u9AD4\u4E2D\u6587",
    ja: "\u65E5\u672C\u8A9E",
    ko: "\uD55C\uAD6D\uC5B4",
    de: "Deutsch",
    fr: "Fran\xE7ais",
    es: "Espa\xF1ol",
    ru: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439",
    pt: "Portugu\xEAs"
  }
};
var zh_TW_default = {
  common: common10,
  settings: settings10
};

// src/i18n/i18n.ts
var translations = {
  en: en_exports,
  "zh-CN": zh_CN_exports,
  "zh-TW": zh_TW_exports,
  ja: ja_exports,
  ko: ko_exports,
  de: de_exports,
  fr: fr_exports,
  es: es_exports,
  ru: ru_exports,
  pt: pt_exports
};
var DEFAULT_LOCALE = "en";
var currentLocale = DEFAULT_LOCALE;
function t(key, params) {
  const locale = currentLocale;
  const dict = translations[locale];
  const keys = key.split(".");
  let value = dict;
  for (const k of keys) {
    if (value && typeof value === "object" && k in value) {
      value = value[k];
    } else {
      if (locale !== DEFAULT_LOCALE) {
        return tFallback(key, params);
      }
      return key;
    }
  }
  if (typeof value !== "string") {
    return key;
  }
  if (params) {
    return value.replace(/\{(\w+)\}/g, (_, param) => {
      var _a, _b;
      return (_b = (_a = params[param]) == null ? void 0 : _a.toString()) != null ? _b : `{${param}}`;
    });
  }
  return value;
}
function tFallback(key, params) {
  const dict = translations[DEFAULT_LOCALE];
  const keys = key.split(".");
  let value = dict;
  for (const k of keys) {
    if (value && typeof value === "object" && k in value) {
      value = value[k];
    } else {
      return key;
    }
  }
  if (typeof value !== "string") {
    return key;
  }
  if (params) {
    return value.replace(/\{(\w+)\}/g, (_, param) => {
      var _a, _b;
      return (_b = (_a = params[param]) == null ? void 0 : _a.toString()) != null ? _b : `{${param}}`;
    });
  }
  return value;
}
function setLocale(locale) {
  if (!translations[locale]) {
    return false;
  }
  currentLocale = locale;
  return true;
}
function getAvailableLocales() {
  return Object.keys(translations);
}
function getLocaleDisplayName(locale) {
  const names = {
    "en": "English",
    "zh-CN": "\u7B80\u4F53\u4E2D\u6587",
    "zh-TW": "\u7E41\u9AD4\u4E2D\u6587",
    "ja": "\u65E5\u672C\u8A9E",
    "ko": "\uD55C\uAD6D\uC5B4",
    "de": "Deutsch",
    "fr": "Fran\xE7ais",
    "es": "Espa\xF1ol",
    "ru": "\u0420\u0443\u0441\u0441\u043A\u0438\u0439",
    "pt": "Portugu\xEAs"
  };
  return names[locale] || locale;
}

// src/features/settings/keyboardNavigation.ts
var NAV_ACTIONS = ["scrollUp", "scrollDown", "focusInput"];
var buildNavMappingText = (settings11) => {
  return [
    `map ${settings11.scrollUpKey} scrollUp`,
    `map ${settings11.scrollDownKey} scrollDown`,
    `map ${settings11.focusInputKey} focusInput`
  ].join("\n");
};
var parseNavMappings = (value) => {
  const parsed = {};
  const usedKeys = /* @__PURE__ */ new Map();
  const lines = value.split("\n");
  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line) continue;
    const parts = line.split(/\s+/);
    if (parts.length !== 3 || parts[0] !== "map") {
      return { error: 'Each line must follow "map <key> <action>"' };
    }
    const key = parts[1];
    const action = parts[2];
    if (!NAV_ACTIONS.includes(action)) {
      return { error: `Unknown action: ${parts[2]}` };
    }
    if (key.length !== 1) {
      return { error: `Key must be a single character for ${action}` };
    }
    const normalizedKey = key.toLowerCase();
    if (usedKeys.has(normalizedKey)) {
      return { error: "Navigation keys must be unique" };
    }
    if (parsed[action]) {
      return { error: `Duplicate mapping for ${action}` };
    }
    usedKeys.set(normalizedKey, action);
    parsed[action] = key;
  }
  const missing = NAV_ACTIONS.filter((action) => !parsed[action]);
  if (missing.length > 0) {
    return { error: `Missing mapping for ${missing.join(", ")}` };
  }
  return { settings: parsed };
};

// src/features/settings/ui/EnvSnippetManager.ts
var import_obsidian22 = require("obsidian");
var EnvSnippetModal = class extends import_obsidian22.Modal {
  constructor(app, plugin, snippet, onSave) {
    super(app);
    this.plugin = plugin;
    this.snippet = snippet;
    this.onSave = onSave;
  }
  onOpen() {
    const { contentEl } = this;
    this.setTitle(this.snippet ? "Edit snippet" : "Save snippet");
    this.modalEl.addClass("claudian-env-snippet-modal");
    let nameEl;
    let descEl;
    let envVarsEl;
    const handleKeyDown = (e) => {
      if (e.key === "Enter" && !e.isComposing) {
        e.preventDefault();
        saveSnippet();
      } else if (e.key === "Escape" && !e.isComposing) {
        e.preventDefault();
        this.close();
      }
    };
    const saveSnippet = () => {
      var _a;
      const name = nameEl.value.trim();
      if (!name) {
        new import_obsidian22.Notice("Please enter a name for the snippet");
        return;
      }
      const snippet = {
        id: ((_a = this.snippet) == null ? void 0 : _a.id) || `snippet-${Date.now()}`,
        name,
        description: descEl.value.trim(),
        envVars: envVarsEl.value
      };
      this.onSave(snippet);
      this.close();
    };
    new import_obsidian22.Setting(contentEl).setName("Name").setDesc("A descriptive name for this environment configuration").addText((text) => {
      var _a;
      nameEl = text.inputEl;
      text.setValue(((_a = this.snippet) == null ? void 0 : _a.name) || "");
      text.inputEl.addEventListener("keydown", handleKeyDown);
    });
    new import_obsidian22.Setting(contentEl).setName("Description").setDesc("Optional description").addText((text) => {
      var _a;
      descEl = text.inputEl;
      text.setValue(((_a = this.snippet) == null ? void 0 : _a.description) || "");
      text.inputEl.addEventListener("keydown", handleKeyDown);
    });
    const envVarsSetting = new import_obsidian22.Setting(contentEl).setName("Environment variables").setDesc("KEY=VALUE format, one per line").addTextArea((text) => {
      var _a, _b;
      envVarsEl = text.inputEl;
      const envVarsToShow = (_b = (_a = this.snippet) == null ? void 0 : _a.envVars) != null ? _b : this.plugin.settings.environmentVariables;
      text.setValue(envVarsToShow);
      text.inputEl.rows = 8;
    });
    envVarsSetting.settingEl.addClass("claudian-env-snippet-setting");
    envVarsSetting.controlEl.addClass("claudian-env-snippet-control");
    const buttonContainer = contentEl.createDiv({ cls: "claudian-snippet-buttons" });
    const cancelBtn = buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "claudian-cancel-btn"
    });
    cancelBtn.addEventListener("click", () => this.close());
    const saveBtn = buttonContainer.createEl("button", {
      text: this.snippet ? "Update" : "Save",
      cls: "claudian-save-btn"
    });
    saveBtn.addEventListener("click", () => saveSnippet());
    setTimeout(() => nameEl == null ? void 0 : nameEl.focus(), 50);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var EnvSnippetManager = class {
  constructor(containerEl, plugin) {
    this.containerEl = containerEl;
    this.plugin = plugin;
    this.render();
  }
  render() {
    this.containerEl.empty();
    const headerEl = this.containerEl.createDiv({ cls: "claudian-snippet-header" });
    headerEl.createSpan({ text: "Snippets", cls: "claudian-snippet-label" });
    const saveBtn = headerEl.createEl("button", {
      cls: "claudian-settings-action-btn",
      attr: { "aria-label": "Save current" }
    });
    (0, import_obsidian22.setIcon)(saveBtn, "plus");
    saveBtn.addEventListener("click", () => this.saveCurrentEnv());
    const snippets = this.plugin.settings.envSnippets;
    if (snippets.length === 0) {
      const emptyEl = this.containerEl.createDiv({ cls: "claudian-snippet-empty" });
      emptyEl.setText('No saved environment snippets yet. Click "Save Current" to save your current environment configuration.');
      return;
    }
    const sortedSnippets = snippets;
    const listEl = this.containerEl.createDiv({ cls: "claudian-snippet-list" });
    for (const snippet of sortedSnippets) {
      const itemEl = listEl.createDiv({ cls: "claudian-snippet-item" });
      const infoEl = itemEl.createDiv({ cls: "claudian-snippet-info" });
      const nameEl = infoEl.createDiv({ cls: "claudian-snippet-name" });
      nameEl.setText(snippet.name);
      if (snippet.description) {
        const descEl = infoEl.createDiv({ cls: "claudian-snippet-description" });
        descEl.setText(snippet.description);
      }
      const actionsEl = itemEl.createDiv({ cls: "claudian-snippet-actions" });
      const restoreBtn = actionsEl.createEl("button", {
        cls: "claudian-settings-action-btn",
        attr: { "aria-label": "Insert" }
      });
      (0, import_obsidian22.setIcon)(restoreBtn, "clipboard-paste");
      restoreBtn.addEventListener("click", async () => {
        try {
          await this.insertSnippet(snippet);
        } catch (e) {
          new import_obsidian22.Notice("Failed to insert snippet");
        }
      });
      const editBtn = actionsEl.createEl("button", {
        cls: "claudian-settings-action-btn",
        attr: { "aria-label": "Edit" }
      });
      (0, import_obsidian22.setIcon)(editBtn, "pencil");
      editBtn.addEventListener("click", () => {
        this.editSnippet(snippet);
      });
      const deleteBtn = actionsEl.createEl("button", {
        cls: "claudian-settings-action-btn claudian-settings-delete-btn",
        attr: { "aria-label": "Delete" }
      });
      (0, import_obsidian22.setIcon)(deleteBtn, "trash-2");
      deleteBtn.addEventListener("click", async () => {
        try {
          if (confirm(`Delete environment snippet "${snippet.name}"?`)) {
            await this.deleteSnippet(snippet);
          }
        } catch (e) {
          new import_obsidian22.Notice("Failed to delete snippet");
        }
      });
    }
  }
  async saveCurrentEnv() {
    const modal = new EnvSnippetModal(
      this.plugin.app,
      this.plugin,
      null,
      async (snippet) => {
        this.plugin.settings.envSnippets.push(snippet);
        await this.plugin.saveSettings();
        this.render();
        new import_obsidian22.Notice(`Environment snippet "${snippet.name}" saved`);
      }
    );
    modal.open();
  }
  async insertSnippet(snippet) {
    var _a, _b;
    const envTextarea = document.querySelector(".claudian-settings-env-textarea");
    if (envTextarea) {
      const snippetContent = snippet.envVars.trim();
      envTextarea.value = snippetContent;
      await this.plugin.applyEnvironmentVariables(snippetContent);
      const view = (_a = this.plugin.app.workspace.getLeavesOfType("claudian-view")[0]) == null ? void 0 : _a.view;
      view == null ? void 0 : view.refreshModelSelector();
    } else {
      await this.plugin.applyEnvironmentVariables(snippet.envVars);
      this.render();
      const view = (_b = this.plugin.app.workspace.getLeavesOfType("claudian-view")[0]) == null ? void 0 : _b.view;
      view == null ? void 0 : view.refreshModelSelector();
    }
  }
  editSnippet(snippet) {
    const modal = new EnvSnippetModal(
      this.plugin.app,
      this.plugin,
      snippet,
      async (updatedSnippet) => {
        const index = this.plugin.settings.envSnippets.findIndex((s) => s.id === snippet.id);
        if (index !== -1) {
          this.plugin.settings.envSnippets[index] = updatedSnippet;
          await this.plugin.saveSettings();
          this.render();
          new import_obsidian22.Notice(`Environment snippet "${updatedSnippet.name}" updated`);
        }
      }
    );
    modal.open();
  }
  async deleteSnippet(snippet) {
    this.plugin.settings.envSnippets = this.plugin.settings.envSnippets.filter((s) => s.id !== snippet.id);
    await this.plugin.saveSettings();
    this.render();
    new import_obsidian22.Notice(`Environment snippet "${snippet.name}" deleted`);
  }
  refresh() {
    this.render();
  }
};

// src/features/settings/ui/McpSettingsManager.ts
var import_obsidian25 = require("obsidian");

// src/features/settings/ui/McpServerModal.ts
var import_obsidian23 = require("obsidian");
var McpServerModal = class extends import_obsidian23.Modal {
  constructor(app, plugin, existingServer, onSave, initialType, prefillConfig) {
    super(app);
    // Form state
    this.serverName = "";
    this.serverType = "stdio";
    this.enabled = DEFAULT_MCP_SERVER.enabled;
    this.contextSaving = DEFAULT_MCP_SERVER.contextSaving;
    // Stdio fields
    this.command = "";
    // Full command including args
    this.env = "";
    // SSE/HTTP fields
    this.url = "";
    this.headers = "";
    // DOM references
    this.typeFieldsEl = null;
    this.nameInputEl = null;
    this.plugin = plugin;
    this.existingServer = existingServer;
    this.onSave = onSave;
    if (existingServer) {
      this.serverName = existingServer.name;
      this.serverType = getMcpServerType(existingServer.config);
      this.enabled = existingServer.enabled;
      this.contextSaving = existingServer.contextSaving;
      this.initFromConfig(existingServer.config);
    } else if (prefillConfig) {
      this.serverName = prefillConfig.name;
      this.serverType = getMcpServerType(prefillConfig.config);
      this.initFromConfig(prefillConfig.config);
    } else if (initialType) {
      this.serverType = initialType;
    }
  }
  /** Initialize form fields from a config object. */
  initFromConfig(config2) {
    const type = getMcpServerType(config2);
    if (type === "stdio") {
      const stdioConfig = config2;
      if (stdioConfig.args && stdioConfig.args.length > 0) {
        this.command = stdioConfig.command + " " + stdioConfig.args.join(" ");
      } else {
        this.command = stdioConfig.command;
      }
      this.env = this.envRecordToString(stdioConfig.env);
    } else {
      const urlConfig = config2;
      this.url = urlConfig.url;
      this.headers = this.envRecordToString(urlConfig.headers);
    }
  }
  onOpen() {
    this.setTitle(this.existingServer ? "Edit MCP Server" : "Add MCP Server");
    this.modalEl.addClass("claudian-mcp-modal");
    const { contentEl } = this;
    new import_obsidian23.Setting(contentEl).setName("Server name").setDesc("Unique identifier for this server").addText((text) => {
      this.nameInputEl = text.inputEl;
      text.setValue(this.serverName);
      text.setPlaceholder("my-mcp-server");
      text.onChange((value) => {
        this.serverName = value;
      });
      text.inputEl.addEventListener("keydown", (e) => this.handleKeyDown(e));
    });
    new import_obsidian23.Setting(contentEl).setName("Type").setDesc("Server connection type").addDropdown((dropdown) => {
      dropdown.addOption("stdio", "stdio (local command)");
      dropdown.addOption("sse", "sse (Server-Sent Events)");
      dropdown.addOption("http", "http (HTTP endpoint)");
      dropdown.setValue(this.serverType);
      dropdown.onChange((value) => {
        this.serverType = value;
        this.renderTypeFields();
      });
    });
    this.typeFieldsEl = contentEl.createDiv({ cls: "claudian-mcp-type-fields" });
    this.renderTypeFields();
    new import_obsidian23.Setting(contentEl).setName("Enabled").setDesc("Whether this server is active").addToggle((toggle) => {
      toggle.setValue(this.enabled);
      toggle.onChange((value) => {
        this.enabled = value;
      });
    });
    new import_obsidian23.Setting(contentEl).setName("Context-saving mode").setDesc("Hide tools from agent unless @-mentioned (saves context window)").addToggle((toggle) => {
      toggle.setValue(this.contextSaving);
      toggle.onChange((value) => {
        this.contextSaving = value;
      });
    });
    const buttonContainer = contentEl.createDiv({ cls: "claudian-mcp-buttons" });
    const cancelBtn = buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "claudian-cancel-btn"
    });
    cancelBtn.addEventListener("click", () => this.close());
    const saveBtn = buttonContainer.createEl("button", {
      text: this.existingServer ? "Update" : "Add",
      cls: "claudian-save-btn mod-cta"
    });
    saveBtn.addEventListener("click", () => this.save());
  }
  renderTypeFields() {
    if (!this.typeFieldsEl) return;
    this.typeFieldsEl.empty();
    if (this.serverType === "stdio") {
      this.renderStdioFields();
    } else {
      this.renderUrlFields();
    }
  }
  renderStdioFields() {
    if (!this.typeFieldsEl) return;
    const cmdSetting = new import_obsidian23.Setting(this.typeFieldsEl).setName("Command").setDesc("Full command with arguments");
    cmdSetting.settingEl.addClass("claudian-mcp-cmd-setting");
    const cmdTextarea = cmdSetting.controlEl.createEl("textarea", {
      cls: "claudian-mcp-cmd-textarea"
    });
    cmdTextarea.value = this.command;
    cmdTextarea.placeholder = "docker exec -i mcp-server python -m src.server";
    cmdTextarea.rows = 2;
    cmdTextarea.addEventListener("input", () => {
      this.command = cmdTextarea.value;
    });
    const envSetting = new import_obsidian23.Setting(this.typeFieldsEl).setName("Environment variables").setDesc("KEY=VALUE per line (optional)");
    envSetting.settingEl.addClass("claudian-mcp-env-setting");
    const envTextarea = envSetting.controlEl.createEl("textarea", {
      cls: "claudian-mcp-env-textarea"
    });
    envTextarea.value = this.env;
    envTextarea.placeholder = "API_KEY=your-key";
    envTextarea.rows = 2;
    envTextarea.addEventListener("input", () => {
      this.env = envTextarea.value;
    });
  }
  renderUrlFields() {
    if (!this.typeFieldsEl) return;
    new import_obsidian23.Setting(this.typeFieldsEl).setName("URL").setDesc(this.serverType === "sse" ? "SSE endpoint URL" : "HTTP endpoint URL").addText((text) => {
      text.setValue(this.url);
      text.setPlaceholder("http://localhost:3000/sse");
      text.onChange((value) => {
        this.url = value;
      });
      text.inputEl.addEventListener("keydown", (e) => this.handleKeyDown(e));
    });
    const headersSetting = new import_obsidian23.Setting(this.typeFieldsEl).setName("Headers").setDesc("HTTP headers (KEY=VALUE per line)");
    headersSetting.settingEl.addClass("claudian-mcp-env-setting");
    const headersTextarea = headersSetting.controlEl.createEl("textarea", {
      cls: "claudian-mcp-env-textarea"
    });
    headersTextarea.value = this.headers;
    headersTextarea.placeholder = "Authorization=Bearer token\nContent-Type=application/json";
    headersTextarea.rows = 3;
    headersTextarea.addEventListener("input", () => {
      this.headers = headersTextarea.value;
    });
  }
  handleKeyDown(e) {
    if (e.key === "Enter" && !e.shiftKey && !e.isComposing) {
      e.preventDefault();
      this.save();
    } else if (e.key === "Escape" && !e.isComposing) {
      e.preventDefault();
      this.close();
    }
  }
  save() {
    var _a, _b, _c;
    const name = this.serverName.trim();
    if (!name) {
      new import_obsidian23.Notice("Please enter a server name");
      (_a = this.nameInputEl) == null ? void 0 : _a.focus();
      return;
    }
    if (!/^[a-zA-Z0-9._-]+$/.test(name)) {
      new import_obsidian23.Notice("Server name can only contain letters, numbers, dots, hyphens, and underscores");
      (_b = this.nameInputEl) == null ? void 0 : _b.focus();
      return;
    }
    let config2;
    if (this.serverType === "stdio") {
      const fullCommand = this.command.trim();
      if (!fullCommand) {
        new import_obsidian23.Notice("Please enter a command");
        return;
      }
      const { cmd, args } = parseCommand(fullCommand);
      const stdioConfig = { command: cmd };
      if (args.length > 0) {
        stdioConfig.args = args;
      }
      const env = this.parseEnvString(this.env);
      if (Object.keys(env).length > 0) {
        stdioConfig.env = env;
      }
      config2 = stdioConfig;
    } else {
      const url = this.url.trim();
      if (!url) {
        new import_obsidian23.Notice("Please enter a URL");
        return;
      }
      if (this.serverType === "sse") {
        const sseConfig = { type: "sse", url };
        const headers = this.parseEnvString(this.headers);
        if (Object.keys(headers).length > 0) {
          sseConfig.headers = headers;
        }
        config2 = sseConfig;
      } else {
        const httpConfig = { type: "http", url };
        const headers = this.parseEnvString(this.headers);
        if (Object.keys(headers).length > 0) {
          httpConfig.headers = headers;
        }
        config2 = httpConfig;
      }
    }
    const server = {
      name,
      config: config2,
      enabled: this.enabled,
      contextSaving: this.contextSaving,
      disabledTools: (_c = this.existingServer) == null ? void 0 : _c.disabledTools
    };
    this.onSave(server);
    this.close();
  }
  parseEnvString(envStr) {
    const result = {};
    if (!envStr.trim()) return result;
    for (const line of envStr.split("\n")) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith("#")) continue;
      const eqIndex = trimmed.indexOf("=");
      if (eqIndex === -1) continue;
      const key = trimmed.substring(0, eqIndex).trim();
      const value = trimmed.substring(eqIndex + 1).trim();
      if (key) {
        result[key] = value;
      }
    }
    return result;
  }
  envRecordToString(env) {
    if (!env) return "";
    return Object.entries(env).map(([key, value]) => `${key}=${value}`).join("\n");
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/features/settings/ui/McpTestModal.ts
var import_obsidian24 = require("obsidian");
function formatToggleError(error2) {
  if (!(error2 instanceof Error)) return "Failed to update tool setting";
  const msg = error2.message.toLowerCase();
  if (msg.includes("permission") || msg.includes("eacces")) {
    return "Permission denied. Check .claude/ folder permissions.";
  }
  if (msg.includes("enospc") || msg.includes("disk full") || msg.includes("no space")) {
    return "Disk full. Free up space and try again.";
  }
  if (msg.includes("json") || msg.includes("syntax")) {
    return "Config file corrupted. Check .claude/mcp.json";
  }
  return error2.message || "Failed to update tool setting";
}
var McpTestModal = class extends import_obsidian24.Modal {
  constructor(app, serverName, initialDisabledTools, onToolToggle, onBulkToggle) {
    super(app);
    this.result = null;
    this.loading = true;
    this.contentEl_ = null;
    this.toolToggles = /* @__PURE__ */ new Map();
    this.toolElements = /* @__PURE__ */ new Map();
    this.toggleAllBtn = null;
    this.pendingToggle = false;
    this.serverName = serverName;
    this.disabledTools = new Set(
      (initialDisabledTools != null ? initialDisabledTools : []).map((tool) => tool.trim()).filter((tool) => tool.length > 0)
    );
    this.onToolToggle = onToolToggle;
    this.onBulkToggle = onBulkToggle;
  }
  onOpen() {
    this.setTitle(`Verify: ${this.serverName}`);
    this.modalEl.addClass("claudian-mcp-test-modal");
    this.contentEl_ = this.contentEl;
    this.renderLoading();
  }
  /** Set the test result and update the display. */
  setResult(result) {
    this.result = result;
    this.loading = false;
    this.render();
  }
  /** Set error state. */
  setError(error2) {
    this.result = { success: false, tools: [], error: error2 };
    this.loading = false;
    this.render();
  }
  renderLoading() {
    if (!this.contentEl_) return;
    this.contentEl_.empty();
    const loadingEl = this.contentEl_.createDiv({ cls: "claudian-mcp-test-loading" });
    const spinnerEl = loadingEl.createDiv({ cls: "claudian-mcp-test-spinner" });
    spinnerEl.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/>
    </svg>`;
    loadingEl.createSpan({ text: "Connecting to MCP server..." });
  }
  render() {
    if (!this.contentEl_) return;
    this.contentEl_.empty();
    if (!this.result) {
      this.renderLoading();
      return;
    }
    const statusEl = this.contentEl_.createDiv({ cls: "claudian-mcp-test-status" });
    const iconEl = statusEl.createSpan({ cls: "claudian-mcp-test-icon" });
    if (this.result.success) {
      (0, import_obsidian24.setIcon)(iconEl, "check-circle");
      iconEl.addClass("success");
    } else {
      (0, import_obsidian24.setIcon)(iconEl, "x-circle");
      iconEl.addClass("error");
    }
    const textEl = statusEl.createSpan({ cls: "claudian-mcp-test-text" });
    if (this.result.success) {
      let statusText = "Connected successfully";
      if (this.result.serverName) {
        statusText += ` to ${this.result.serverName}`;
        if (this.result.serverVersion) {
          statusText += ` v${this.result.serverVersion}`;
        }
      }
      textEl.setText(statusText);
    } else {
      textEl.setText("Connection failed");
    }
    if (this.result.error) {
      const errorEl = this.contentEl_.createDiv({ cls: "claudian-mcp-test-error" });
      errorEl.setText(this.result.error);
    }
    this.toolToggles.clear();
    this.toolElements.clear();
    if (this.result.tools.length > 0) {
      const toolsSection = this.contentEl_.createDiv({ cls: "claudian-mcp-test-tools" });
      const toolsHeader = toolsSection.createDiv({ cls: "claudian-mcp-test-tools-header" });
      toolsHeader.setText(`Available Tools (${this.result.tools.length})`);
      const toolsList = toolsSection.createDiv({ cls: "claudian-mcp-test-tools-list" });
      for (const tool of this.result.tools) {
        this.renderTool(toolsList, tool);
      }
    } else if (this.result.success) {
      const noToolsEl = this.contentEl_.createDiv({ cls: "claudian-mcp-test-no-tools" });
      noToolsEl.setText("No tools information available. Tools will be loaded when used in chat.");
    }
    const buttonContainer = this.contentEl_.createDiv({ cls: "claudian-mcp-test-buttons" });
    if (this.result.tools.length > 0 && this.onToolToggle) {
      this.toggleAllBtn = buttonContainer.createEl("button", {
        cls: "claudian-mcp-toggle-all-btn"
      });
      this.updateToggleAllButton();
      this.toggleAllBtn.addEventListener("click", () => this.handleToggleAll());
    }
    const closeBtn = buttonContainer.createEl("button", {
      text: "Close",
      cls: "mod-cta"
    });
    closeBtn.addEventListener("click", () => this.close());
  }
  renderTool(container, tool) {
    const toolEl = container.createDiv({ cls: "claudian-mcp-test-tool" });
    const headerEl = toolEl.createDiv({ cls: "claudian-mcp-test-tool-header" });
    const iconEl = headerEl.createSpan({ cls: "claudian-mcp-test-tool-icon" });
    (0, import_obsidian24.setIcon)(iconEl, "wrench");
    const nameEl = headerEl.createSpan({ cls: "claudian-mcp-test-tool-name" });
    nameEl.setText(tool.name);
    const toggleEl = headerEl.createDiv({ cls: "claudian-mcp-test-tool-toggle" });
    const toggleContainer = toggleEl.createDiv({ cls: "checkbox-container" });
    const checkbox = toggleContainer.createEl("input", {
      type: "checkbox",
      attr: { tabindex: "0" }
    });
    const isEnabled = !this.disabledTools.has(tool.name);
    checkbox.checked = isEnabled;
    toggleContainer.toggleClass("is-enabled", isEnabled);
    this.updateToolState(toolEl, isEnabled);
    this.toolToggles.set(tool.name, { checkbox, container: toggleContainer });
    this.toolElements.set(tool.name, toolEl);
    if (!this.onToolToggle) {
      checkbox.disabled = true;
    } else {
      toggleContainer.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (checkbox.disabled) return;
        checkbox.checked = !checkbox.checked;
        this.handleToolToggle(tool.name, checkbox, toggleContainer);
      });
    }
    if (tool.description) {
      const descEl = toolEl.createDiv({ cls: "claudian-mcp-test-tool-desc" });
      descEl.setText(tool.description);
    }
  }
  async handleToolToggle(toolName, checkbox, container) {
    var _a;
    const toolEl = this.toolElements.get(toolName);
    if (!toolEl) return;
    const wasDisabled = this.disabledTools.has(toolName);
    const nextDisabled = !checkbox.checked;
    if (nextDisabled) {
      this.disabledTools.add(toolName);
    } else {
      this.disabledTools.delete(toolName);
    }
    container.toggleClass("is-enabled", !nextDisabled);
    this.updateToolState(toolEl, !nextDisabled);
    this.updateToggleAllButton();
    checkbox.disabled = true;
    try {
      await ((_a = this.onToolToggle) == null ? void 0 : _a.call(this, toolName, !nextDisabled));
    } catch (error2) {
      if (nextDisabled) {
        this.disabledTools.delete(toolName);
      } else {
        this.disabledTools.add(toolName);
      }
      checkbox.checked = !wasDisabled;
      container.toggleClass("is-enabled", !wasDisabled);
      this.updateToolState(toolEl, !wasDisabled);
      this.updateToggleAllButton();
      new import_obsidian24.Notice(formatToggleError(error2));
    } finally {
      checkbox.disabled = false;
    }
  }
  updateToolState(toolEl, enabled) {
    toolEl.toggleClass("claudian-mcp-test-tool-disabled", !enabled);
  }
  updateToggleAllButton() {
    if (!this.toggleAllBtn || !this.result) return;
    const allEnabled = this.disabledTools.size === 0;
    const allDisabled = this.disabledTools.size === this.result.tools.length;
    if (allEnabled) {
      this.toggleAllBtn.setText("Disable All");
      this.toggleAllBtn.toggleClass("is-destructive", true);
    } else {
      this.toggleAllBtn.setText(allDisabled ? "Enable All" : "Enable All");
      this.toggleAllBtn.toggleClass("is-destructive", false);
    }
  }
  async handleToggleAll() {
    if (!this.result || this.pendingToggle || !this.onBulkToggle) return;
    const allEnabled = this.disabledTools.size === 0;
    const previousDisabled = new Set(this.disabledTools);
    const newDisabledTools = allEnabled ? this.result.tools.map((t2) => t2.name) : [];
    this.pendingToggle = true;
    if (this.toggleAllBtn) this.toggleAllBtn.disabled = true;
    for (const { checkbox } of this.toolToggles.values()) {
      checkbox.disabled = true;
    }
    this.disabledTools = new Set(newDisabledTools);
    for (const tool of this.result.tools) {
      const toggle = this.toolToggles.get(tool.name);
      const toolEl = this.toolElements.get(tool.name);
      if (!toggle || !toolEl) continue;
      const isEnabled = !this.disabledTools.has(tool.name);
      toggle.checkbox.checked = isEnabled;
      toggle.container.toggleClass("is-enabled", isEnabled);
      this.updateToolState(toolEl, isEnabled);
    }
    this.updateToggleAllButton();
    try {
      await this.onBulkToggle(newDisabledTools);
    } catch (error2) {
      this.disabledTools = previousDisabled;
      for (const tool of this.result.tools) {
        const toggle = this.toolToggles.get(tool.name);
        const toolEl = this.toolElements.get(tool.name);
        if (!toggle || !toolEl) continue;
        const isEnabled = !this.disabledTools.has(tool.name);
        toggle.checkbox.checked = isEnabled;
        toggle.container.toggleClass("is-enabled", isEnabled);
        this.updateToolState(toolEl, isEnabled);
      }
      this.updateToggleAllButton();
      new import_obsidian24.Notice(formatToggleError(error2));
    }
    for (const { checkbox } of this.toolToggles.values()) {
      checkbox.disabled = false;
    }
    this.pendingToggle = false;
    if (this.toggleAllBtn) this.toggleAllBtn.disabled = false;
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/features/settings/ui/McpSettingsManager.ts
var McpSettingsManager = class {
  constructor(containerEl, plugin) {
    this.servers = [];
    this.containerEl = containerEl;
    this.plugin = plugin;
    this.loadAndRender();
  }
  /**
   * Broadcasts MCP reload to all open Claudian views.
   * With multiple views open (split workspace), each view's tabs need to reload MCP config.
   */
  async broadcastMcpReloadToAllViews() {
    var _a;
    const views = this.plugin.getAllViews();
    for (const view of views) {
      await ((_a = view.getTabManager()) == null ? void 0 : _a.broadcastToAllTabs(
        (service) => service.reloadMcpServers()
      ));
    }
  }
  async loadAndRender() {
    this.servers = await this.plugin.storage.mcp.load();
    this.render();
  }
  render() {
    this.containerEl.empty();
    const headerEl = this.containerEl.createDiv({ cls: "claudian-mcp-header" });
    headerEl.createSpan({ text: "MCP Servers", cls: "claudian-mcp-label" });
    const addContainer = headerEl.createDiv({ cls: "claudian-mcp-add-container" });
    const addBtn = addContainer.createEl("button", {
      cls: "claudian-settings-action-btn",
      attr: { "aria-label": "Add" }
    });
    (0, import_obsidian25.setIcon)(addBtn, "plus");
    const dropdown = addContainer.createDiv({ cls: "claudian-mcp-add-dropdown" });
    const stdioOption = dropdown.createDiv({ cls: "claudian-mcp-add-option" });
    (0, import_obsidian25.setIcon)(stdioOption.createSpan({ cls: "claudian-mcp-add-option-icon" }), "terminal");
    stdioOption.createSpan({ text: "stdio (local command)" });
    stdioOption.addEventListener("click", () => {
      dropdown.removeClass("is-visible");
      this.openModal(null, "stdio");
    });
    const httpOption = dropdown.createDiv({ cls: "claudian-mcp-add-option" });
    (0, import_obsidian25.setIcon)(httpOption.createSpan({ cls: "claudian-mcp-add-option-icon" }), "globe");
    httpOption.createSpan({ text: "http / sse (remote)" });
    httpOption.addEventListener("click", () => {
      dropdown.removeClass("is-visible");
      this.openModal(null, "http");
    });
    const importOption = dropdown.createDiv({ cls: "claudian-mcp-add-option" });
    (0, import_obsidian25.setIcon)(importOption.createSpan({ cls: "claudian-mcp-add-option-icon" }), "clipboard-paste");
    importOption.createSpan({ text: "Import from clipboard" });
    importOption.addEventListener("click", () => {
      dropdown.removeClass("is-visible");
      this.importFromClipboard();
    });
    addBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      dropdown.toggleClass("is-visible", !dropdown.hasClass("is-visible"));
    });
    document.addEventListener("click", () => {
      dropdown.removeClass("is-visible");
    });
    if (this.servers.length === 0) {
      const emptyEl = this.containerEl.createDiv({ cls: "claudian-mcp-empty" });
      emptyEl.setText('No MCP servers configured. Click "Add" to add one.');
      return;
    }
    const listEl = this.containerEl.createDiv({ cls: "claudian-mcp-list" });
    for (const server of this.servers) {
      this.renderServerItem(listEl, server);
    }
  }
  renderServerItem(listEl, server) {
    const itemEl = listEl.createDiv({ cls: "claudian-mcp-item" });
    if (!server.enabled) {
      itemEl.addClass("claudian-mcp-item-disabled");
    }
    const statusEl = itemEl.createDiv({ cls: "claudian-mcp-status" });
    statusEl.addClass(
      server.enabled ? "claudian-mcp-status-enabled" : "claudian-mcp-status-disabled"
    );
    const infoEl = itemEl.createDiv({ cls: "claudian-mcp-info" });
    const nameRow = infoEl.createDiv({ cls: "claudian-mcp-name-row" });
    const nameEl = nameRow.createSpan({ cls: "claudian-mcp-name" });
    nameEl.setText(server.name);
    const serverType = getMcpServerType(server.config);
    const typeEl = nameRow.createSpan({ cls: "claudian-mcp-type-badge" });
    typeEl.setText(serverType);
    if (server.contextSaving) {
      const csEl = nameRow.createSpan({ cls: "claudian-mcp-context-saving-badge" });
      csEl.setText("@");
      csEl.setAttribute("title", "Context-saving: mention with @" + server.name + " to enable");
    }
    const previewEl = infoEl.createDiv({ cls: "claudian-mcp-preview" });
    if (server.description) {
      previewEl.setText(server.description);
    } else {
      previewEl.setText(this.getServerPreview(server, serverType));
    }
    const actionsEl = itemEl.createDiv({ cls: "claudian-mcp-actions" });
    const testBtn = actionsEl.createEl("button", {
      cls: "claudian-mcp-action-btn",
      attr: { "aria-label": "Verify (show tools)" }
    });
    (0, import_obsidian25.setIcon)(testBtn, "zap");
    testBtn.addEventListener("click", () => this.testServer(server));
    const toggleBtn = actionsEl.createEl("button", {
      cls: "claudian-mcp-action-btn",
      attr: { "aria-label": server.enabled ? "Disable" : "Enable" }
    });
    (0, import_obsidian25.setIcon)(toggleBtn, server.enabled ? "toggle-right" : "toggle-left");
    toggleBtn.addEventListener("click", () => this.toggleServer(server));
    const editBtn = actionsEl.createEl("button", {
      cls: "claudian-mcp-action-btn",
      attr: { "aria-label": "Edit" }
    });
    (0, import_obsidian25.setIcon)(editBtn, "pencil");
    editBtn.addEventListener("click", () => this.openModal(server));
    const deleteBtn = actionsEl.createEl("button", {
      cls: "claudian-mcp-action-btn claudian-mcp-delete-btn",
      attr: { "aria-label": "Delete" }
    });
    (0, import_obsidian25.setIcon)(deleteBtn, "trash-2");
    deleteBtn.addEventListener("click", () => this.deleteServer(server));
  }
  async testServer(server) {
    const modal = new McpTestModal(
      this.plugin.app,
      server.name,
      server.disabledTools,
      async (toolName, enabled) => {
        await this.updateDisabledTool(server, toolName, enabled);
      },
      async (disabledTools) => {
        await this.updateAllDisabledTools(server, disabledTools);
      }
    );
    modal.open();
    try {
      const result = await testMcpServer(server);
      modal.setResult(result);
    } catch (error2) {
      modal.setError(error2 instanceof Error ? error2.message : "Verification failed");
    }
  }
  /**
   * Helper to update server.disabledTools with save and reload.
   * Rolls back on save failure; warns on reload failure (since save succeeded).
   */
  async updateServerDisabledTools(server, newDisabledTools) {
    const previous = server.disabledTools ? [...server.disabledTools] : void 0;
    server.disabledTools = newDisabledTools;
    try {
      await this.plugin.storage.mcp.save(this.servers);
    } catch (error2) {
      server.disabledTools = previous;
      throw error2;
    }
    try {
      await this.broadcastMcpReloadToAllViews();
    } catch (e) {
      new import_obsidian25.Notice("Setting saved but reload failed. Changes will apply on next session.");
    }
  }
  async updateDisabledTool(server, toolName, enabled) {
    var _a;
    const disabledTools = new Set((_a = server.disabledTools) != null ? _a : []);
    if (enabled) {
      disabledTools.delete(toolName);
    } else {
      disabledTools.add(toolName);
    }
    await this.updateServerDisabledTools(
      server,
      disabledTools.size > 0 ? Array.from(disabledTools) : void 0
    );
  }
  async updateAllDisabledTools(server, disabledTools) {
    await this.updateServerDisabledTools(
      server,
      disabledTools.length > 0 ? disabledTools : void 0
    );
  }
  getServerPreview(server, type) {
    var _a;
    if (type === "stdio") {
      const config2 = server.config;
      const args = ((_a = config2.args) == null ? void 0 : _a.join(" ")) || "";
      return args ? `${config2.command} ${args}` : config2.command;
    } else {
      const config2 = server.config;
      return config2.url;
    }
  }
  openModal(existing, initialType) {
    const modal = new McpServerModal(
      this.plugin.app,
      this.plugin,
      existing,
      async (server) => {
        await this.saveServer(server, existing);
      },
      initialType
    );
    modal.open();
  }
  async importFromClipboard() {
    try {
      const text = await navigator.clipboard.readText();
      if (!text.trim()) {
        new import_obsidian25.Notice("Clipboard is empty");
        return;
      }
      const parsed = McpStorage.tryParseClipboardConfig(text);
      if (!parsed || parsed.servers.length === 0) {
        new import_obsidian25.Notice("No valid MCP configuration found in clipboard");
        return;
      }
      if (parsed.needsName || parsed.servers.length === 1) {
        const server = parsed.servers[0];
        const type = getMcpServerType(server.config);
        const modal = new McpServerModal(
          this.plugin.app,
          this.plugin,
          null,
          async (savedServer) => {
            await this.saveServer(savedServer, null);
          },
          type,
          server
          // Pre-fill with parsed config
        );
        modal.open();
        if (parsed.needsName) {
          new import_obsidian25.Notice("Enter a name for the server");
        }
        return;
      }
      await this.importServers(parsed.servers);
    } catch (e) {
      new import_obsidian25.Notice("Failed to read clipboard");
    }
  }
  async saveServer(server, existing) {
    if (existing) {
      const index = this.servers.findIndex((s) => s.name === existing.name);
      if (index !== -1) {
        if (server.name !== existing.name) {
          const conflict = this.servers.find((s) => s.name === server.name);
          if (conflict) {
            new import_obsidian25.Notice(`Server "${server.name}" already exists`);
            return;
          }
        }
        this.servers[index] = server;
      }
    } else {
      const conflict = this.servers.find((s) => s.name === server.name);
      if (conflict) {
        new import_obsidian25.Notice(`Server "${server.name}" already exists`);
        return;
      }
      this.servers.push(server);
    }
    await this.plugin.storage.mcp.save(this.servers);
    await this.broadcastMcpReloadToAllViews();
    this.render();
    new import_obsidian25.Notice(existing ? `MCP server "${server.name}" updated` : `MCP server "${server.name}" added`);
  }
  async importServers(servers) {
    const added = [];
    const skipped = [];
    for (const server of servers) {
      const name = server.name.trim();
      if (!name || !/^[a-zA-Z0-9._-]+$/.test(name)) {
        skipped.push(server.name || "<unnamed>");
        continue;
      }
      const conflict = this.servers.find((s) => s.name === name);
      if (conflict) {
        skipped.push(name);
        continue;
      }
      this.servers.push({
        name,
        config: server.config,
        enabled: DEFAULT_MCP_SERVER.enabled,
        contextSaving: DEFAULT_MCP_SERVER.contextSaving
      });
      added.push(name);
    }
    if (added.length === 0) {
      new import_obsidian25.Notice("No new MCP servers imported");
      return;
    }
    await this.plugin.storage.mcp.save(this.servers);
    await this.broadcastMcpReloadToAllViews();
    this.render();
    let message = `Imported ${added.length} MCP server${added.length > 1 ? "s" : ""}`;
    if (skipped.length > 0) {
      message += ` (${skipped.length} skipped)`;
    }
    new import_obsidian25.Notice(message);
  }
  async toggleServer(server) {
    server.enabled = !server.enabled;
    await this.plugin.storage.mcp.save(this.servers);
    await this.broadcastMcpReloadToAllViews();
    this.render();
    new import_obsidian25.Notice(`MCP server "${server.name}" ${server.enabled ? "enabled" : "disabled"}`);
  }
  async deleteServer(server) {
    if (!confirm(`Delete MCP server "${server.name}"?`)) {
      return;
    }
    this.servers = this.servers.filter((s) => s.name !== server.name);
    await this.plugin.storage.mcp.save(this.servers);
    await this.broadcastMcpReloadToAllViews();
    this.render();
    new import_obsidian25.Notice(`MCP server "${server.name}" deleted`);
  }
  /** Refresh the server list (call after external changes). */
  refresh() {
    this.loadAndRender();
  }
};

// src/features/settings/ui/PluginSettingsManager.ts
var import_obsidian26 = require("obsidian");
var PluginSettingsManager = class {
  constructor(containerEl, plugin) {
    this.containerEl = containerEl;
    this.plugin = plugin;
    this.render();
  }
  render() {
    this.containerEl.empty();
    const headerEl = this.containerEl.createDiv({ cls: "claudian-plugin-header" });
    headerEl.createSpan({ text: "Claude Code Plugins", cls: "claudian-plugin-label" });
    const refreshBtn = headerEl.createEl("button", {
      cls: "claudian-settings-action-btn",
      attr: { "aria-label": "Refresh" }
    });
    (0, import_obsidian26.setIcon)(refreshBtn, "refresh-cw");
    refreshBtn.addEventListener("click", () => this.refreshPlugins());
    const plugins = this.plugin.pluginManager.getPlugins();
    if (plugins.length === 0) {
      const emptyEl = this.containerEl.createDiv({ cls: "claudian-plugin-empty" });
      emptyEl.setText("No Claude Code plugins installed. Install plugins via the Claude CLI.");
      return;
    }
    const projectLocalPlugins = plugins.filter((p) => p.scope === "project" || p.scope === "local");
    const userPlugins = plugins.filter((p) => p.scope === "user");
    const listEl = this.containerEl.createDiv({ cls: "claudian-plugin-list" });
    if (projectLocalPlugins.length > 0) {
      const sectionHeader = listEl.createDiv({ cls: "claudian-plugin-section-header" });
      sectionHeader.setText("Project Plugins");
      for (const plugin of projectLocalPlugins) {
        this.renderPluginItem(listEl, plugin);
      }
    }
    if (userPlugins.length > 0) {
      const sectionHeader = listEl.createDiv({ cls: "claudian-plugin-section-header" });
      sectionHeader.setText("User Plugins");
      for (const plugin of userPlugins) {
        this.renderPluginItem(listEl, plugin);
      }
    }
  }
  renderPluginItem(listEl, plugin) {
    const itemEl = listEl.createDiv({ cls: "claudian-plugin-item" });
    if (!plugin.enabled) {
      itemEl.addClass("claudian-plugin-item-disabled");
    }
    if (plugin.status !== "available") {
      itemEl.addClass("claudian-plugin-item-error");
    }
    const statusEl = itemEl.createDiv({ cls: "claudian-plugin-status" });
    if (plugin.status !== "available") {
      statusEl.addClass("claudian-plugin-status-error");
    } else if (plugin.enabled) {
      statusEl.addClass("claudian-plugin-status-enabled");
    } else {
      statusEl.addClass("claudian-plugin-status-disabled");
    }
    const infoEl = itemEl.createDiv({ cls: "claudian-plugin-info" });
    const nameRow = infoEl.createDiv({ cls: "claudian-plugin-name-row" });
    const nameEl = nameRow.createSpan({ cls: "claudian-plugin-name" });
    nameEl.setText(plugin.name);
    const scopeEl = nameRow.createSpan({ cls: "claudian-plugin-scope-badge" });
    scopeEl.setText(this.getScopeLabel(plugin.scope));
    if (plugin.status !== "available") {
      const errorEl = nameRow.createSpan({ cls: "claudian-plugin-error-badge" });
      errorEl.setText(plugin.status === "unavailable" ? "Unavailable" : "Invalid");
    }
    const previewEl = infoEl.createDiv({ cls: "claudian-plugin-preview" });
    if (plugin.error) {
      previewEl.setText(plugin.error);
      previewEl.addClass("claudian-plugin-preview-error");
    } else if (plugin.description) {
      previewEl.setText(plugin.description);
    } else {
      previewEl.setText(plugin.id);
    }
    const actionsEl = itemEl.createDiv({ cls: "claudian-plugin-actions" });
    if (plugin.status === "available") {
      const toggleBtn = actionsEl.createEl("button", {
        cls: "claudian-plugin-action-btn",
        attr: { "aria-label": plugin.enabled ? "Disable" : "Enable" }
      });
      (0, import_obsidian26.setIcon)(toggleBtn, plugin.enabled ? "toggle-right" : "toggle-left");
      toggleBtn.addEventListener("click", () => this.togglePlugin(plugin.id));
    }
  }
  getScopeLabel(scope) {
    switch (scope) {
      case "user":
        return "User";
      case "project":
        return "Project";
      case "local":
        return "Local";
    }
  }
  async togglePlugin(pluginId) {
    var _a;
    const plugin = this.plugin.pluginManager.getPlugins().find((p) => p.id === pluginId);
    const wasEnabled = (_a = plugin == null ? void 0 : plugin.enabled) != null ? _a : false;
    try {
      const newEnabledIds = this.plugin.pluginManager.togglePlugin(pluginId);
      this.plugin.settings.enabledPlugins = newEnabledIds;
      await this.plugin.saveSettings();
      this.plugin.loadPluginSlashCommands();
      const view = this.plugin.getView();
      const tabManager = view == null ? void 0 : view.getTabManager();
      if (tabManager) {
        try {
          await tabManager.broadcastToAllTabs(
            async (service) => {
              await service.ensureReady({ force: true });
            }
          );
        } catch (e) {
          new import_obsidian26.Notice("Plugin toggled, but some tabs failed to restart.");
        }
      }
      if (plugin) {
        new import_obsidian26.Notice(`Plugin "${plugin.name}" ${wasEnabled ? "disabled" : "enabled"}`);
      }
    } catch (err) {
      this.plugin.pluginManager.togglePlugin(pluginId);
      const message = err instanceof Error ? err.message : "Unknown error";
      new import_obsidian26.Notice(`Failed to toggle plugin: ${message}`);
    } finally {
      this.render();
    }
  }
  async refreshPlugins() {
    try {
      await this.plugin.pluginManager.loadPlugins();
      this.plugin.loadPluginSlashCommands();
      const view = this.plugin.getView();
      const tabManager = view == null ? void 0 : view.getTabManager();
      if (tabManager) {
        try {
          await tabManager.broadcastToAllTabs(
            async (service) => {
              await service.ensureReady({ force: true });
            }
          );
        } catch (e) {
          new import_obsidian26.Notice("Plugins refreshed, but some tabs failed to restart.");
          return;
        }
      }
      new import_obsidian26.Notice("Plugin list refreshed");
    } catch (err) {
      const message = err instanceof Error ? err.message : "Unknown error";
      new import_obsidian26.Notice(`Failed to refresh plugins: ${message}`);
    } finally {
      this.render();
    }
  }
  /** Refresh the plugin list (call after external changes). */
  refresh() {
    this.render();
  }
};

// src/features/settings/ui/SlashCommandSettings.ts
var import_obsidian27 = require("obsidian");
function isUserCommand(cmd) {
  return !cmd.id.startsWith("plugin-");
}
var SlashCommandModal = class extends import_obsidian27.Modal {
  constructor(app, plugin, existingCmd, onSave) {
    super(app);
    this.plugin = plugin;
    this.existingCmd = existingCmd;
    this.onSave = onSave;
  }
  onOpen() {
    this.setTitle(this.existingCmd ? "Edit Slash Command" : "Add Slash Command");
    this.modalEl.addClass("claudian-slash-modal");
    const { contentEl } = this;
    let nameInput;
    let descInput;
    let hintInput;
    let modelInput;
    let toolsInput;
    new import_obsidian27.Setting(contentEl).setName("Command name").setDesc('The name used after / (e.g., "review" for /review)').addText((text) => {
      var _a;
      nameInput = text.inputEl;
      text.setValue(((_a = this.existingCmd) == null ? void 0 : _a.name) || "").setPlaceholder("review-code");
    });
    new import_obsidian27.Setting(contentEl).setName("Description").setDesc("Optional description shown in dropdown").addText((text) => {
      var _a;
      descInput = text.inputEl;
      text.setValue(((_a = this.existingCmd) == null ? void 0 : _a.description) || "");
    });
    new import_obsidian27.Setting(contentEl).setName("Argument hint").setDesc('Placeholder text for arguments (e.g., "[file] [focus]")').addText((text) => {
      var _a;
      hintInput = text.inputEl;
      text.setValue(((_a = this.existingCmd) == null ? void 0 : _a.argumentHint) || "");
    });
    new import_obsidian27.Setting(contentEl).setName("Model override").setDesc("Optional model to use for this command").addText((text) => {
      var _a;
      modelInput = text.inputEl;
      text.setValue(((_a = this.existingCmd) == null ? void 0 : _a.model) || "").setPlaceholder("claude-sonnet-4-5");
    });
    new import_obsidian27.Setting(contentEl).setName("Allowed tools").setDesc("Comma-separated list of tools to allow (empty = all)").addText((text) => {
      var _a, _b;
      toolsInput = text.inputEl;
      text.setValue(((_b = (_a = this.existingCmd) == null ? void 0 : _a.allowedTools) == null ? void 0 : _b.join(", ")) || "");
    });
    new import_obsidian27.Setting(contentEl).setName("Prompt template").setDesc("Use $ARGUMENTS, $1, $2, @file, !`bash`");
    const contentArea = contentEl.createEl("textarea", {
      cls: "claudian-slash-content-area",
      attr: {
        rows: "10",
        placeholder: "Review this code for:\n$ARGUMENTS\n\n@$1"
      }
    });
    const initialContent = this.existingCmd ? parseSlashCommandContent(this.existingCmd.content).promptContent : "";
    contentArea.value = initialContent;
    const buttonContainer = contentEl.createDiv({ cls: "claudian-slash-modal-buttons" });
    const cancelBtn = buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "claudian-cancel-btn"
    });
    cancelBtn.addEventListener("click", () => this.close());
    const saveBtn = buttonContainer.createEl("button", {
      text: "Save",
      cls: "claudian-save-btn"
    });
    saveBtn.addEventListener("click", async () => {
      var _a;
      const name = nameInput.value.trim();
      if (!name) {
        new import_obsidian27.Notice("Command name is required");
        return;
      }
      const content = contentArea.value;
      if (!content.trim()) {
        new import_obsidian27.Notice("Prompt template is required");
        return;
      }
      if (!/^[a-zA-Z0-9_/-]+$/.test(name)) {
        new import_obsidian27.Notice("Command name can only contain letters, numbers, hyphens, underscores, and slashes");
        return;
      }
      const existing = this.plugin.settings.slashCommands.find(
        (c) => {
          var _a2;
          return c.name.toLowerCase() === name.toLowerCase() && c.id !== ((_a2 = this.existingCmd) == null ? void 0 : _a2.id);
        }
      );
      if (existing) {
        new import_obsidian27.Notice(`A command named "/${name}" already exists`);
        return;
      }
      const parsed = parseSlashCommandContent(content);
      const promptContent = parsed.promptContent;
      const cmd = {
        id: ((_a = this.existingCmd) == null ? void 0 : _a.id) || `cmd-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
        name,
        description: descInput.value.trim() || parsed.description || void 0,
        argumentHint: hintInput.value.trim() || parsed.argumentHint || void 0,
        model: modelInput.value.trim() || parsed.model || void 0,
        allowedTools: toolsInput.value.trim() ? toolsInput.value.split(",").map((s) => s.trim()).filter(Boolean) : parsed.allowedTools && parsed.allowedTools.length > 0 ? parsed.allowedTools : void 0,
        content: promptContent
      };
      this.onSave(cmd);
      this.close();
    });
    const handleKeyDown = (e) => {
      if (e.key === "Escape") {
        e.preventDefault();
        this.close();
      }
    };
    contentEl.addEventListener("keydown", handleKeyDown);
  }
  onClose() {
    this.contentEl.empty();
  }
};
var SlashCommandSettings = class {
  constructor(containerEl, plugin) {
    this.containerEl = containerEl;
    this.plugin = plugin;
    this.render();
  }
  render() {
    this.containerEl.empty();
    const headerEl = this.containerEl.createDiv({ cls: "claudian-slash-header" });
    headerEl.createSpan({ text: "Slash Commands", cls: "claudian-slash-label" });
    const actionsEl = headerEl.createDiv({ cls: "claudian-slash-header-actions" });
    const importBtn = actionsEl.createEl("button", {
      cls: "claudian-settings-action-btn",
      attr: { "aria-label": "Import" }
    });
    (0, import_obsidian27.setIcon)(importBtn, "download");
    importBtn.addEventListener("click", () => this.importCommands());
    const exportBtn = actionsEl.createEl("button", {
      cls: "claudian-settings-action-btn",
      attr: { "aria-label": "Export" }
    });
    (0, import_obsidian27.setIcon)(exportBtn, "upload");
    exportBtn.addEventListener("click", () => this.exportCommands());
    const addBtn = actionsEl.createEl("button", {
      cls: "claudian-settings-action-btn",
      attr: { "aria-label": "Add" }
    });
    (0, import_obsidian27.setIcon)(addBtn, "plus");
    addBtn.addEventListener("click", () => this.openCommandModal(null));
    const commands = this.plugin.settings.slashCommands.filter(isUserCommand);
    if (commands.length === 0) {
      const emptyEl = this.containerEl.createDiv({ cls: "claudian-slash-empty-state" });
      emptyEl.setText('No slash commands configured. Click "Add" to create one.');
      return;
    }
    const listEl = this.containerEl.createDiv({ cls: "claudian-slash-list" });
    for (const cmd of commands) {
      this.renderCommandItem(listEl, cmd);
    }
  }
  renderCommandItem(listEl, cmd) {
    const itemEl = listEl.createDiv({ cls: "claudian-slash-item-settings" });
    const infoEl = itemEl.createDiv({ cls: "claudian-slash-info" });
    const headerRow = infoEl.createDiv({ cls: "claudian-slash-item-header" });
    const nameEl = headerRow.createSpan({ cls: "claudian-slash-item-name" });
    nameEl.setText(`/${cmd.name}`);
    if (cmd.argumentHint) {
      const hintEl = headerRow.createSpan({ cls: "claudian-slash-item-hint" });
      hintEl.setText(cmd.argumentHint);
    }
    if (cmd.description) {
      const descEl = infoEl.createDiv({ cls: "claudian-slash-item-desc" });
      descEl.setText(cmd.description);
    }
    const actionsEl = itemEl.createDiv({ cls: "claudian-slash-item-actions" });
    const editBtn = actionsEl.createEl("button", {
      cls: "claudian-settings-action-btn",
      attr: { "aria-label": "Edit" }
    });
    (0, import_obsidian27.setIcon)(editBtn, "pencil");
    editBtn.addEventListener("click", () => this.openCommandModal(cmd));
    const deleteBtn = actionsEl.createEl("button", {
      cls: "claudian-settings-action-btn claudian-settings-delete-btn",
      attr: { "aria-label": "Delete" }
    });
    (0, import_obsidian27.setIcon)(deleteBtn, "trash-2");
    deleteBtn.addEventListener("click", async () => {
      try {
        await this.deleteCommand(cmd);
      } catch (e) {
        new import_obsidian27.Notice("Failed to delete slash command");
      }
    });
  }
  openCommandModal(existingCmd) {
    const modal = new SlashCommandModal(
      this.plugin.app,
      this.plugin,
      existingCmd,
      async (cmd) => {
        await this.saveCommand(cmd, existingCmd);
      }
    );
    modal.open();
  }
  async saveCommand(cmd, existing) {
    await this.plugin.storage.commands.save(cmd);
    if (existing && existing.name !== cmd.name) {
      await this.plugin.storage.commands.delete(existing.id);
    }
    await this.reloadCommands();
    this.render();
    new import_obsidian27.Notice(`Slash command "/${cmd.name}" ${existing ? "updated" : "created"}`);
  }
  async deleteCommand(cmd) {
    await this.plugin.storage.commands.delete(cmd.id);
    await this.reloadCommands();
    this.render();
    new import_obsidian27.Notice(`Slash command "/${cmd.name}" deleted`);
  }
  /** Reload commands from storage and update in-memory settings. */
  async reloadCommands() {
    const commands = await this.plugin.storage.commands.loadAll();
    this.plugin.settings.slashCommands = commands;
  }
  exportCommands() {
    const commands = this.plugin.settings.slashCommands.filter(isUserCommand);
    if (commands.length === 0) {
      new import_obsidian27.Notice("No slash commands to export");
      return;
    }
    const json = JSON.stringify(commands, null, 2);
    const blob = new Blob([json], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "claudian-slash-commands.json";
    a.click();
    URL.revokeObjectURL(url);
    new import_obsidian27.Notice(`Exported ${commands.length} slash command(s)`);
  }
  importCommands() {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".json";
    input.addEventListener("change", async (e) => {
      var _a;
      const file = (_a = e.target.files) == null ? void 0 : _a[0];
      if (!file) return;
      try {
        const text = await file.text();
        const commands = JSON.parse(text);
        if (!Array.isArray(commands)) {
          throw new Error("Invalid format: expected an array");
        }
        const existingCommands = await this.plugin.storage.commands.loadAll();
        const existingNames = new Set(existingCommands.map((c) => c.name.toLowerCase()));
        let imported = 0;
        for (const cmd of commands) {
          if (!cmd.name || !cmd.content) {
            continue;
          }
          if (typeof cmd.name !== "string" || typeof cmd.content !== "string") {
            continue;
          }
          if (!/^[a-zA-Z0-9_/:-]+$/.test(cmd.name)) {
            continue;
          }
          cmd.id = `cmd-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
          if (cmd.allowedTools && !Array.isArray(cmd.allowedTools)) {
            cmd.allowedTools = void 0;
          }
          if (Array.isArray(cmd.allowedTools)) {
            cmd.allowedTools = cmd.allowedTools.filter((t2) => typeof t2 === "string" && t2.trim().length > 0);
            if (cmd.allowedTools.length === 0) {
              cmd.allowedTools = void 0;
            }
          }
          if (cmd.description && typeof cmd.description !== "string") {
            cmd.description = void 0;
          }
          if (cmd.argumentHint && typeof cmd.argumentHint !== "string") {
            cmd.argumentHint = void 0;
          }
          if (cmd.model && typeof cmd.model !== "string") {
            cmd.model = void 0;
          }
          const parsed = parseSlashCommandContent(cmd.content);
          cmd.description = cmd.description || parsed.description;
          cmd.argumentHint = cmd.argumentHint || parsed.argumentHint;
          cmd.model = cmd.model || parsed.model;
          cmd.allowedTools = cmd.allowedTools || parsed.allowedTools;
          cmd.content = parsed.promptContent;
          if (existingNames.has(cmd.name.toLowerCase())) {
            continue;
          }
          await this.plugin.storage.commands.save(cmd);
          existingNames.add(cmd.name.toLowerCase());
          imported++;
        }
        await this.reloadCommands();
        this.render();
        new import_obsidian27.Notice(`Imported ${imported} slash command(s)`);
      } catch (e2) {
        new import_obsidian27.Notice("Failed to import slash commands. Check file format.");
      }
    });
    input.click();
  }
  refresh() {
    this.render();
  }
};

// src/features/settings/ClaudianSettings.ts
function formatHotkey(hotkey) {
  const isMac = navigator.platform.includes("Mac");
  const modMap = isMac ? { Mod: "\u2318", Ctrl: "\u2303", Alt: "\u2325", Shift: "\u21E7", Meta: "\u2318" } : { Mod: "Ctrl", Ctrl: "Ctrl", Alt: "Alt", Shift: "Shift", Meta: "Win" };
  const mods = hotkey.modifiers.map((m) => modMap[m] || m);
  const key = hotkey.key.length === 1 ? hotkey.key.toUpperCase() : hotkey.key;
  return isMac ? [...mods, key].join("") : [...mods, key].join("+");
}
function openHotkeySettings(app) {
  const setting = app.setting;
  setting.open();
  setting.openTabById("hotkeys");
  setTimeout(() => {
    var _a, _b, _c;
    const tab = setting.activeTab;
    if (tab) {
      const searchEl = (_b = tab.searchInputEl) != null ? _b : (_a = tab.searchComponent) == null ? void 0 : _a.inputEl;
      if (searchEl) {
        searchEl.value = "Claudian";
        (_c = tab.updateHotkeyVisibility) == null ? void 0 : _c.call(tab);
      }
    }
  }, 100);
}
function getHotkeyForCommand(app, commandId) {
  var _a, _b;
  const hotkeyManager = app.hotkeyManager;
  if (!hotkeyManager) return null;
  const customHotkeys = (_a = hotkeyManager.customKeys) == null ? void 0 : _a[commandId];
  const defaultHotkeys = (_b = hotkeyManager.defaultKeys) == null ? void 0 : _b[commandId];
  const hotkeys = (customHotkeys == null ? void 0 : customHotkeys.length) > 0 ? customHotkeys : defaultHotkeys;
  if (!hotkeys || hotkeys.length === 0) return null;
  return hotkeys.map(formatHotkey).join(", ");
}
var ClaudianSettingTab = class extends import_obsidian28.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("claudian-settings");
    setLocale(this.plugin.settings.locale);
    new import_obsidian28.Setting(containerEl).setName(t("settings.language.name")).setDesc(t("settings.language.desc")).addDropdown((dropdown) => {
      const locales = getAvailableLocales();
      for (const locale of locales) {
        dropdown.addOption(locale, getLocaleDisplayName(locale));
      }
      dropdown.setValue(this.plugin.settings.locale).onChange(async (value) => {
        if (!setLocale(value)) {
          dropdown.setValue(this.plugin.settings.locale);
          return;
        }
        this.plugin.settings.locale = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian28.Setting(containerEl).setName(t("settings.customization")).setHeading();
    new import_obsidian28.Setting(containerEl).setName(t("settings.userName.name")).setDesc(t("settings.userName.desc")).addText(
      (text) => text.setPlaceholder(t("settings.userName.name")).setValue(this.plugin.settings.userName).onChange(async (value) => {
        this.plugin.settings.userName = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian28.Setting(containerEl).setName(t("settings.excludedTags.name")).setDesc(t("settings.excludedTags.desc")).addTextArea((text) => {
      text.setPlaceholder("system\nprivate\ndraft").setValue(this.plugin.settings.excludedTags.join("\n")).onChange(async (value) => {
        this.plugin.settings.excludedTags = value.split(/\r?\n/).map((s) => s.trim().replace(/^#/, "")).filter((s) => s.length > 0);
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 4;
      text.inputEl.cols = 30;
    });
    new import_obsidian28.Setting(containerEl).setName(t("settings.mediaFolder.name")).setDesc(t("settings.mediaFolder.desc")).addText((text) => {
      text.setPlaceholder("attachments").setValue(this.plugin.settings.mediaFolder).onChange(async (value) => {
        this.plugin.settings.mediaFolder = value.trim();
        await this.plugin.saveSettings();
      });
      text.inputEl.addClass("claudian-settings-media-input");
    });
    new import_obsidian28.Setting(containerEl).setName(t("settings.systemPrompt.name")).setDesc(t("settings.systemPrompt.desc")).addTextArea((text) => {
      text.setPlaceholder(t("settings.systemPrompt.name")).setValue(this.plugin.settings.systemPrompt).onChange(async (value) => {
        this.plugin.settings.systemPrompt = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 6;
      text.inputEl.cols = 50;
    });
    new import_obsidian28.Setting(containerEl).setName(t("settings.autoTitle.name")).setDesc(t("settings.autoTitle.desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableAutoTitleGeneration).onChange(async (value) => {
        this.plugin.settings.enableAutoTitleGeneration = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.enableAutoTitleGeneration) {
      new import_obsidian28.Setting(containerEl).setName(t("settings.titleModel.name")).setDesc(t("settings.titleModel.desc")).addDropdown((dropdown) => {
        dropdown.addOption("", t("settings.titleModel.auto"));
        const envVars = parseEnvironmentVariables(this.plugin.settings.environmentVariables);
        const customModels = getModelsFromEnvironment(envVars);
        const models = customModels.length > 0 ? customModels : DEFAULT_CLAUDE_MODELS;
        for (const model of models) {
          dropdown.addOption(model.value, model.label);
        }
        dropdown.setValue(this.plugin.settings.titleGenerationModel || "").onChange(async (value) => {
          this.plugin.settings.titleGenerationModel = value;
          await this.plugin.saveSettings();
        });
      });
    }
    new import_obsidian28.Setting(containerEl).setName(t("settings.navMappings.name")).setDesc(t("settings.navMappings.desc")).addTextArea((text) => {
      let pendingValue = buildNavMappingText(this.plugin.settings.keyboardNavigation);
      let saveTimeout = null;
      const commitValue = async (showError) => {
        if (saveTimeout !== null) {
          window.clearTimeout(saveTimeout);
          saveTimeout = null;
        }
        const result = parseNavMappings(pendingValue);
        if (!result.settings) {
          if (showError) {
            new import_obsidian28.Notice(`${t("common.error")}: ${result.error}`);
            pendingValue = buildNavMappingText(this.plugin.settings.keyboardNavigation);
            text.setValue(pendingValue);
          }
          return;
        }
        this.plugin.settings.keyboardNavigation.scrollUpKey = result.settings.scrollUp;
        this.plugin.settings.keyboardNavigation.scrollDownKey = result.settings.scrollDown;
        this.plugin.settings.keyboardNavigation.focusInputKey = result.settings.focusInput;
        await this.plugin.saveSettings();
        pendingValue = buildNavMappingText(this.plugin.settings.keyboardNavigation);
        text.setValue(pendingValue);
      };
      const scheduleSave = () => {
        if (saveTimeout !== null) {
          window.clearTimeout(saveTimeout);
        }
        saveTimeout = window.setTimeout(() => {
          void commitValue(false);
        }, 500);
      };
      text.setPlaceholder("map w scrollUp\nmap s scrollDown\nmap i focusInput").setValue(pendingValue).onChange((value) => {
        pendingValue = value;
        scheduleSave();
      });
      text.inputEl.rows = 3;
      text.inputEl.addEventListener("blur", async () => {
        await commitValue(true);
      });
    });
    new import_obsidian28.Setting(containerEl).setName(t("settings.hotkeys")).setHeading();
    const inlineEditCommandId = "claudian:inline-edit";
    const inlineEditHotkey = getHotkeyForCommand(this.app, inlineEditCommandId);
    new import_obsidian28.Setting(containerEl).setName(t("settings.inlineEditHotkey.name")).setDesc(inlineEditHotkey ? t("settings.inlineEditHotkey.descWithKey", { hotkey: inlineEditHotkey }) : t("settings.inlineEditHotkey.descNoKey")).addButton(
      (button) => button.setButtonText(inlineEditHotkey ? t("settings.inlineEditHotkey.btnChange") : t("settings.inlineEditHotkey.btnSet")).onClick(() => openHotkeySettings(this.app))
    );
    const openChatCommandId = "claudian:open-view";
    const openChatHotkey = getHotkeyForCommand(this.app, openChatCommandId);
    new import_obsidian28.Setting(containerEl).setName(t("settings.openChatHotkey.name")).setDesc(openChatHotkey ? t("settings.openChatHotkey.descWithKey", { hotkey: openChatHotkey }) : t("settings.openChatHotkey.descNoKey")).addButton(
      (button) => button.setButtonText(openChatHotkey ? t("settings.openChatHotkey.btnChange") : t("settings.openChatHotkey.btnSet")).onClick(() => openHotkeySettings(this.app))
    );
    const newSessionCommandId = "claudian:new-session";
    const newSessionHotkey = getHotkeyForCommand(this.app, newSessionCommandId);
    new import_obsidian28.Setting(containerEl).setName(t("settings.newSessionHotkey.name")).setDesc(newSessionHotkey ? t("settings.newSessionHotkey.descWithKey", { hotkey: newSessionHotkey }) : t("settings.newSessionHotkey.descNoKey")).addButton(
      (button) => button.setButtonText(newSessionHotkey ? t("settings.newSessionHotkey.btnChange") : t("settings.newSessionHotkey.btnSet")).onClick(() => openHotkeySettings(this.app))
    );
    const newTabCommandId = "claudian:new-tab";
    const newTabHotkey = getHotkeyForCommand(this.app, newTabCommandId);
    new import_obsidian28.Setting(containerEl).setName(t("settings.newTabHotkey.name")).setDesc(newTabHotkey ? t("settings.newTabHotkey.descWithKey", { hotkey: newTabHotkey }) : t("settings.newTabHotkey.descNoKey")).addButton(
      (button) => button.setButtonText(newTabHotkey ? t("settings.newTabHotkey.btnChange") : t("settings.newTabHotkey.btnSet")).onClick(() => openHotkeySettings(this.app))
    );
    const closeTabCommandId = "claudian:close-current-tab";
    const closeTabHotkey = getHotkeyForCommand(this.app, closeTabCommandId);
    new import_obsidian28.Setting(containerEl).setName(t("settings.closeTabHotkey.name")).setDesc(closeTabHotkey ? t("settings.closeTabHotkey.descWithKey", { hotkey: closeTabHotkey }) : t("settings.closeTabHotkey.descNoKey")).addButton(
      (button) => button.setButtonText(closeTabHotkey ? t("settings.closeTabHotkey.btnChange") : t("settings.closeTabHotkey.btnSet")).onClick(() => openHotkeySettings(this.app))
    );
    new import_obsidian28.Setting(containerEl).setName(t("settings.slashCommands.name")).setHeading();
    const slashCommandsDesc = containerEl.createDiv({ cls: "claudian-slash-settings-desc" });
    slashCommandsDesc.createEl("p", {
      text: t("settings.slashCommands.desc"),
      cls: "setting-item-description"
    });
    const slashCommandsContainer = containerEl.createDiv({ cls: "claudian-slash-commands-container" });
    new SlashCommandSettings(slashCommandsContainer, this.plugin);
    new import_obsidian28.Setting(containerEl).setName(t("settings.mcpServers.name")).setHeading();
    const mcpDesc = containerEl.createDiv({ cls: "claudian-mcp-settings-desc" });
    mcpDesc.createEl("p", {
      text: t("settings.mcpServers.desc"),
      cls: "setting-item-description"
    });
    const mcpContainer = containerEl.createDiv({ cls: "claudian-mcp-container" });
    new McpSettingsManager(mcpContainer, this.plugin);
    new import_obsidian28.Setting(containerEl).setName(t("settings.plugins.name")).setHeading();
    const pluginsDesc = containerEl.createDiv({ cls: "claudian-plugin-settings-desc" });
    pluginsDesc.createEl("p", {
      text: t("settings.plugins.desc"),
      cls: "setting-item-description"
    });
    const pluginsContainer = containerEl.createDiv({ cls: "claudian-plugins-container" });
    new PluginSettingsManager(pluginsContainer, this.plugin);
    new import_obsidian28.Setting(containerEl).setName(t("settings.safety")).setHeading();
    new import_obsidian28.Setting(containerEl).setName(t("settings.loadUserSettings.name")).setDesc(t("settings.loadUserSettings.desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.loadUserClaudeSettings).onChange(async (value) => {
        this.plugin.settings.loadUserClaudeSettings = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian28.Setting(containerEl).setName(t("settings.enableBlocklist.name")).setDesc(t("settings.enableBlocklist.desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableBlocklist).onChange(async (value) => {
        this.plugin.settings.enableBlocklist = value;
        await this.plugin.saveSettings();
      })
    );
    const platformKey = getCurrentPlatformKey();
    const isWindows2 = platformKey === "windows";
    const platformLabel = isWindows2 ? "Windows" : "Unix";
    new import_obsidian28.Setting(containerEl).setName(t("settings.blockedCommands.name", { platform: platformLabel })).setDesc(t("settings.blockedCommands.desc", { platform: platformLabel })).addTextArea((text) => {
      const placeholder = isWindows2 ? "del /s /q\nrd /s /q\nRemove-Item -Recurse -Force" : "rm -rf\nchmod 777\nmkfs";
      text.setPlaceholder(placeholder).setValue(this.plugin.settings.blockedCommands[platformKey].join("\n")).onChange(async (value) => {
        this.plugin.settings.blockedCommands[platformKey] = value.split(/\r?\n/).map((s) => s.trim()).filter((s) => s.length > 0);
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 6;
      text.inputEl.cols = 40;
    });
    if (isWindows2) {
      new import_obsidian28.Setting(containerEl).setName(t("settings.blockedCommands.unixName")).setDesc(t("settings.blockedCommands.unixDesc")).addTextArea((text) => {
        text.setPlaceholder("rm -rf\nchmod 777\nmkfs").setValue(this.plugin.settings.blockedCommands.unix.join("\n")).onChange(async (value) => {
          this.plugin.settings.blockedCommands.unix = value.split(/\r?\n/).map((s) => s.trim()).filter((s) => s.length > 0);
          await this.plugin.saveSettings();
        });
        text.inputEl.rows = 4;
        text.inputEl.cols = 40;
      });
    }
    new import_obsidian28.Setting(containerEl).setName(t("settings.exportPaths.name")).setDesc(t("settings.exportPaths.desc")).addTextArea((text) => {
      const placeholder = process.platform === "win32" ? "~/Desktop\n~/Downloads\n%TEMP%" : "~/Desktop\n~/Downloads\n/tmp";
      text.setPlaceholder(placeholder).setValue(this.plugin.settings.allowedExportPaths.join("\n")).onChange(async (value) => {
        this.plugin.settings.allowedExportPaths = value.split(/\r?\n/).map((s) => s.trim()).filter((s) => s.length > 0);
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 4;
      text.inputEl.cols = 40;
    });
    new import_obsidian28.Setting(containerEl).setName(t("settings.environment")).setHeading();
    new import_obsidian28.Setting(containerEl).setName(t("settings.customVariables.name")).setDesc(t("settings.customVariables.desc")).addTextArea((text) => {
      text.setPlaceholder("ANTHROPIC_API_KEY=your-key\nANTHROPIC_BASE_URL=https://api.example.com\nANTHROPIC_MODEL=custom-model").setValue(this.plugin.settings.environmentVariables).onChange(async (value) => {
        await this.plugin.applyEnvironmentVariables(value);
      });
      text.inputEl.rows = 6;
      text.inputEl.cols = 50;
      text.inputEl.addClass("claudian-settings-env-textarea");
    });
    const envSnippetsContainer = containerEl.createDiv({ cls: "claudian-env-snippets-container" });
    new EnvSnippetManager(envSnippetsContainer, this.plugin);
    new import_obsidian28.Setting(containerEl).setName(t("settings.advanced")).setHeading();
    new import_obsidian28.Setting(containerEl).setName(t("settings.show1MModel.name")).setDesc(t("settings.show1MModel.desc")).addToggle(
      (toggle) => {
        var _a;
        return toggle.setValue((_a = this.plugin.settings.show1MModel) != null ? _a : false).onChange(async (value) => {
          var _a2;
          this.plugin.settings.show1MModel = value;
          await this.plugin.saveSettings();
          const view = (_a2 = this.plugin.app.workspace.getLeavesOfType("claudian-view")[0]) == null ? void 0 : _a2.view;
          view == null ? void 0 : view.refreshModelSelector();
        });
      }
    );
    const maxTabsSetting = new import_obsidian28.Setting(containerEl).setName(t("settings.maxTabs.name")).setDesc(t("settings.maxTabs.desc"));
    const maxTabsWarningEl = containerEl.createDiv({ cls: "claudian-max-tabs-warning" });
    maxTabsWarningEl.style.color = "var(--text-warning)";
    maxTabsWarningEl.style.fontSize = "0.85em";
    maxTabsWarningEl.style.marginTop = "-0.5em";
    maxTabsWarningEl.style.marginBottom = "0.5em";
    maxTabsWarningEl.style.display = "none";
    maxTabsWarningEl.setText(t("settings.maxTabs.warning"));
    const updateMaxTabsWarning = (value) => {
      maxTabsWarningEl.style.display = value > 5 ? "block" : "none";
    };
    maxTabsSetting.addSlider((slider) => {
      var _a, _b;
      slider.setLimits(3, 10, 1).setValue((_a = this.plugin.settings.maxTabs) != null ? _a : 3).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxTabs = value;
        await this.plugin.saveSettings();
        updateMaxTabsWarning(value);
      });
      updateMaxTabsWarning((_b = this.plugin.settings.maxTabs) != null ? _b : 3);
    });
    const hostnameKey = getHostnameKey();
    const platformDesc = process.platform === "win32" ? t("settings.cliPath.descWindows") : t("settings.cliPath.descUnix");
    const cliPathDescription = `${t("settings.cliPath.desc")} ${platformDesc}`;
    const cliPathSetting = new import_obsidian28.Setting(containerEl).setName(`${t("settings.cliPath.name")} (${hostnameKey})`).setDesc(cliPathDescription);
    const validationEl = containerEl.createDiv({ cls: "claudian-cli-path-validation" });
    validationEl.style.color = "var(--text-error)";
    validationEl.style.fontSize = "0.85em";
    validationEl.style.marginTop = "-0.5em";
    validationEl.style.marginBottom = "0.5em";
    validationEl.style.display = "none";
    const validatePath = (value) => {
      const trimmed = value.trim();
      if (!trimmed) return null;
      const expandedPath = expandHomePath(trimmed);
      if (!fs8.existsSync(expandedPath)) {
        return t("settings.cliPath.validation.notExist");
      }
      const stat = fs8.statSync(expandedPath);
      if (!stat.isFile()) {
        return t("settings.cliPath.validation.isDirectory");
      }
      return null;
    };
    cliPathSetting.addText((text) => {
      var _a;
      const placeholder = process.platform === "win32" ? "D:\\nodejs\\node_global\\node_modules\\@anthropic-ai\\claude-code\\cli.js" : "/usr/local/lib/node_modules/@anthropic-ai/claude-code/cli.js";
      const currentValue = ((_a = this.plugin.settings.claudeCliPathsByHost) == null ? void 0 : _a[hostnameKey]) || "";
      text.setPlaceholder(placeholder).setValue(currentValue).onChange(async (value) => {
        var _a2, _b;
        const error2 = validatePath(value);
        if (error2) {
          validationEl.setText(error2);
          validationEl.style.display = "block";
          text.inputEl.style.borderColor = "var(--text-error)";
        } else {
          validationEl.style.display = "none";
          text.inputEl.style.borderColor = "";
        }
        const trimmed = value.trim();
        if (!this.plugin.settings.claudeCliPathsByHost) {
          this.plugin.settings.claudeCliPathsByHost = {};
        }
        this.plugin.settings.claudeCliPathsByHost[hostnameKey] = trimmed;
        await this.plugin.saveSettings();
        (_a2 = this.plugin.cliResolver) == null ? void 0 : _a2.reset();
        const view = this.plugin.getView();
        await ((_b = view == null ? void 0 : view.getTabManager()) == null ? void 0 : _b.broadcastToAllTabs(
          (service) => Promise.resolve(service.cleanup())
        ));
      });
      text.inputEl.addClass("claudian-settings-cli-path-input");
      text.inputEl.style.width = "100%";
      const initialError = validatePath(currentValue);
      if (initialError) {
        validationEl.setText(initialError);
        validationEl.style.display = "block";
        text.inputEl.style.borderColor = "var(--text-error)";
      }
    });
  }
};

// src/utils/claudeCli.ts
var fs9 = __toESM(require("fs"));
var ClaudeCliResolver = class {
  constructor() {
    this.resolvedPath = null;
    this.lastHostnamePath = "";
    this.lastLegacyPath = "";
    this.lastEnvText = "";
    // Cache hostname since it doesn't change during a session
    this.cachedHostname = getHostnameKey();
  }
  /**
   * Resolves CLI path with priority: hostname-specific -> legacy -> auto-detect.
   * @param hostnamePaths Per-device CLI paths keyed by hostname (preferred)
   * @param legacyPath Legacy claudeCliPath (for backwards compatibility)
   * @param envText Environment variables text
   */
  resolve(hostnamePaths, legacyPath, envText) {
    var _a;
    const hostnameKey = this.cachedHostname;
    const hostnamePath = ((_a = hostnamePaths == null ? void 0 : hostnamePaths[hostnameKey]) != null ? _a : "").trim();
    const normalizedLegacy = (legacyPath != null ? legacyPath : "").trim();
    const normalizedEnv = envText != null ? envText : "";
    if (this.resolvedPath && hostnamePath === this.lastHostnamePath && normalizedLegacy === this.lastLegacyPath && normalizedEnv === this.lastEnvText) {
      return this.resolvedPath;
    }
    this.lastHostnamePath = hostnamePath;
    this.lastLegacyPath = normalizedLegacy;
    this.lastEnvText = normalizedEnv;
    this.resolvedPath = resolveClaudeCliPath(hostnamePath, normalizedLegacy, normalizedEnv);
    return this.resolvedPath;
  }
  reset() {
    this.resolvedPath = null;
    this.lastHostnamePath = "";
    this.lastLegacyPath = "";
    this.lastEnvText = "";
  }
};
function resolveClaudeCliPath(hostnamePath, legacyPath, envText) {
  const trimmedHostname = (hostnamePath != null ? hostnamePath : "").trim();
  if (trimmedHostname) {
    try {
      const expandedPath = expandHomePath(trimmedHostname);
      if (fs9.existsSync(expandedPath)) {
        const stat = fs9.statSync(expandedPath);
        if (stat.isFile()) {
          return expandedPath;
        }
      }
    } catch (e) {
    }
  }
  const trimmedLegacy = (legacyPath != null ? legacyPath : "").trim();
  if (trimmedLegacy) {
    try {
      const expandedPath = expandHomePath(trimmedLegacy);
      if (fs9.existsSync(expandedPath)) {
        const stat = fs9.statSync(expandedPath);
        if (stat.isFile()) {
          return expandedPath;
        }
      }
    } catch (e) {
    }
  }
  const customEnv = parseEnvironmentVariables(envText || "");
  return findClaudeCLIPath(customEnv.PATH);
}

// src/utils/sdkSession.ts
var import_fs3 = require("fs");
var fs10 = __toESM(require("fs/promises"));
var os4 = __toESM(require("os"));
var path8 = __toESM(require("path"));
function encodeVaultPathForSDK(vaultPath) {
  const absolutePath = path8.resolve(vaultPath);
  return absolutePath.replace(/[\\/]/g, "-").replace(/:/g, "-").replace(/ /g, "-").replace(/~/g, "-").replace(/'/g, "-");
}
function getSDKProjectsPath() {
  return path8.join(os4.homedir(), ".claude", "projects");
}
function isValidSessionId(sessionId) {
  if (!sessionId || sessionId.length === 0 || sessionId.length > 128) {
    return false;
  }
  if (sessionId.includes("..") || sessionId.includes("/") || sessionId.includes("\\")) {
    return false;
  }
  return /^[a-zA-Z0-9_-]+$/.test(sessionId);
}
function getSDKSessionPath(vaultPath, sessionId) {
  if (!isValidSessionId(sessionId)) {
    throw new Error(`Invalid session ID: ${sessionId}`);
  }
  const projectsPath = getSDKProjectsPath();
  const encodedVault = encodeVaultPathForSDK(vaultPath);
  return path8.join(projectsPath, encodedVault, `${sessionId}.jsonl`);
}
function sdkSessionExists(vaultPath, sessionId) {
  try {
    const sessionPath = getSDKSessionPath(vaultPath, sessionId);
    return (0, import_fs3.existsSync)(sessionPath);
  } catch (e) {
    return false;
  }
}
async function deleteSDKSession(vaultPath, sessionId) {
  try {
    const sessionPath = getSDKSessionPath(vaultPath, sessionId);
    if (!(0, import_fs3.existsSync)(sessionPath)) return;
    await fs10.unlink(sessionPath);
  } catch (e) {
  }
}
async function readSDKSession(vaultPath, sessionId) {
  try {
    const sessionPath = getSDKSessionPath(vaultPath, sessionId);
    if (!(0, import_fs3.existsSync)(sessionPath)) {
      return { messages: [], skippedLines: 0 };
    }
    const content = await fs10.readFile(sessionPath, "utf-8");
    const lines = content.split("\n").filter((line) => line.trim());
    const messages = [];
    let skippedLines = 0;
    for (const line of lines) {
      try {
        const msg = JSON.parse(line);
        messages.push(msg);
      } catch (e) {
        skippedLines++;
      }
    }
    return { messages, skippedLines };
  } catch (error2) {
    const errorMsg = error2 instanceof Error ? error2.message : String(error2);
    return { messages: [], skippedLines: 0, error: errorMsg };
  }
}
function extractTextContent(content) {
  if (!content) return "";
  if (typeof content === "string") return content;
  return content.filter(
    (block) => block.type === "text" && typeof block.text === "string"
  ).map((block) => block.text).join("\n");
}
function isRebuiltContextContent(textContent) {
  if (!/^(User|Assistant):\s/.test(textContent)) return false;
  return textContent.includes("\n\nUser:") || textContent.includes("\n\nAssistant:") || textContent.includes("\n\nA:");
}
function extractDisplayContent(textContent) {
  if (!textContent) return void 0;
  const queryMatch = textContent.match(/<query>\n?([\s\S]*?)\n?<\/query>/);
  if (queryMatch) {
    return queryMatch[1].trim();
  }
  const hasXmlContext = textContent.includes("<current_note") || textContent.includes("<editor_selection") || textContent.includes("<context_files");
  if (hasXmlContext) {
    return void 0;
  }
  return void 0;
}
function extractImages(content) {
  if (!content || typeof content === "string") return void 0;
  const imageBlocks = content.filter(
    (block) => {
      var _a;
      return block.type === "image" && !!((_a = block.source) == null ? void 0 : _a.data);
    }
  );
  if (imageBlocks.length === 0) return void 0;
  return imageBlocks.map((block, index) => ({
    id: `sdk-img-${Date.now()}-${index}`,
    name: `image-${index + 1}`,
    mediaType: block.source.media_type,
    data: block.source.data,
    size: Math.ceil(block.source.data.length * 0.75),
    // Approximate original size from base64
    source: "paste"
  }));
}
function extractToolCalls(content, toolResults) {
  var _a;
  if (!content || typeof content === "string") return void 0;
  const toolUses = content.filter(
    (block) => block.type === "tool_use" && !!block.id && !!block.name
  );
  if (toolUses.length === 0) return void 0;
  const results = toolResults != null ? toolResults : /* @__PURE__ */ new Map();
  if (!toolResults) {
    for (const block of content) {
      if (block.type === "tool_result" && block.tool_use_id) {
        const resultContent = typeof block.content === "string" ? block.content : JSON.stringify(block.content);
        results.set(block.tool_use_id, {
          content: resultContent,
          isError: (_a = block.is_error) != null ? _a : false
        });
      }
    }
  }
  return toolUses.map((block) => {
    var _a2;
    const result = results.get(block.id);
    return {
      id: block.id,
      name: block.name,
      input: (_a2 = block.input) != null ? _a2 : {},
      status: result ? result.isError ? "error" : "completed" : "completed",
      result: result == null ? void 0 : result.content,
      isExpanded: false
    };
  });
}
function mapContentBlocks(content) {
  if (!content || typeof content === "string") return void 0;
  const blocks = [];
  for (const block of content) {
    switch (block.type) {
      case "text":
        if (block.text && block.text.trim()) {
          blocks.push({ type: "text", content: block.text.trim() });
        }
        break;
      case "thinking":
        if (block.thinking) {
          blocks.push({ type: "thinking", content: block.thinking });
        }
        break;
      case "tool_use":
        if (block.id) {
          blocks.push({ type: "tool_use", toolId: block.id });
        }
        break;
    }
  }
  return blocks.length > 0 ? blocks : void 0;
}
function parseSDKMessageToChat(sdkMsg, toolResults) {
  var _a;
  if (sdkMsg.type === "file-history-snapshot") return null;
  if (sdkMsg.type === "system") return null;
  if (sdkMsg.type === "result") return null;
  if (sdkMsg.type !== "user" && sdkMsg.type !== "assistant") return null;
  const content = (_a = sdkMsg.message) == null ? void 0 : _a.content;
  const textContent = extractTextContent(content);
  const images = sdkMsg.type === "user" ? extractImages(content) : void 0;
  const hasToolUse = Array.isArray(content) && content.some((b) => b.type === "tool_use");
  const hasImages = images && images.length > 0;
  if (!textContent && !hasToolUse && !hasImages && (!content || typeof content === "string")) return null;
  const timestamp = sdkMsg.timestamp ? new Date(sdkMsg.timestamp).getTime() : Date.now();
  const displayContent = sdkMsg.type === "user" ? extractDisplayContent(textContent) : void 0;
  const isInterrupt = sdkMsg.type === "user" && textContent === "[Request interrupted by user]";
  const isRebuiltContext = sdkMsg.type === "user" && isRebuiltContextContent(textContent);
  return {
    id: sdkMsg.uuid || `sdk-${timestamp}-${Math.random().toString(36).slice(2)}`,
    role: sdkMsg.type,
    content: textContent,
    displayContent,
    timestamp,
    toolCalls: sdkMsg.type === "assistant" ? extractToolCalls(content, toolResults) : void 0,
    contentBlocks: sdkMsg.type === "assistant" ? mapContentBlocks(content) : void 0,
    images,
    ...isInterrupt && { isInterrupt: true },
    ...isRebuiltContext && { isRebuiltContext: true }
  };
}
function collectToolResults(sdkMessages) {
  var _a, _b;
  const results = /* @__PURE__ */ new Map();
  for (const sdkMsg of sdkMessages) {
    const content = (_a = sdkMsg.message) == null ? void 0 : _a.content;
    if (!content || typeof content === "string") continue;
    for (const block of content) {
      if (block.type === "tool_result" && block.tool_use_id) {
        const resultContent = typeof block.content === "string" ? block.content : JSON.stringify(block.content);
        results.set(block.tool_use_id, {
          content: resultContent,
          isError: (_b = block.is_error) != null ? _b : false
        });
      }
    }
  }
  return results;
}
function isToolResultMessage(sdkMsg) {
  return sdkMsg.type === "user" && "toolUseResult" in sdkMsg;
}
function mergeAssistantMessage(target, source) {
  if (source.content) {
    if (target.content) {
      target.content = target.content + "\n\n" + source.content;
    } else {
      target.content = source.content;
    }
  }
  if (source.toolCalls) {
    target.toolCalls = [...target.toolCalls || [], ...source.toolCalls];
  }
  if (source.contentBlocks) {
    target.contentBlocks = [...target.contentBlocks || [], ...source.contentBlocks];
  }
}
async function loadSDKSessionMessages(vaultPath, sessionId) {
  const result = await readSDKSession(vaultPath, sessionId);
  if (result.error) {
    return { messages: [], skippedLines: result.skippedLines, error: result.error };
  }
  const toolResults = collectToolResults(result.messages);
  const chatMessages = [];
  let pendingAssistant = null;
  for (const sdkMsg of result.messages) {
    if (isToolResultMessage(sdkMsg)) continue;
    const chatMsg = parseSDKMessageToChat(sdkMsg, toolResults);
    if (!chatMsg) continue;
    if (chatMsg.role === "assistant") {
      if (pendingAssistant) {
        mergeAssistantMessage(pendingAssistant, chatMsg);
      } else {
        pendingAssistant = chatMsg;
      }
    } else {
      if (pendingAssistant) {
        chatMessages.push(pendingAssistant);
        pendingAssistant = null;
      }
      chatMessages.push(chatMsg);
    }
  }
  if (pendingAssistant) {
    chatMessages.push(pendingAssistant);
  }
  chatMessages.sort((a, b) => a.timestamp - b.timestamp);
  return { messages: chatMessages, skippedLines: result.skippedLines };
}

// src/main.ts
var ClaudianPlugin = class extends import_obsidian29.Plugin {
  constructor() {
    super(...arguments);
    this.conversations = [];
    this.runtimeEnvironmentVariables = "";
  }
  async onload() {
    await this.loadSettings();
    this.cliResolver = new ClaudeCliResolver();
    const mcpManager = new McpServerManager(this.storage.mcp);
    this.mcpService = new McpService(mcpManager);
    await this.mcpService.loadServers();
    const vaultPath = this.app.vault.adapter.basePath;
    const pluginStorage = new PluginStorage(vaultPath);
    this.pluginManager = new PluginManager(pluginStorage);
    this.pluginManager.setEnabledPluginIds(this.settings.enabledPlugins);
    await this.pluginManager.loadPlugins();
    const unavailablePlugins = this.pluginManager.getUnavailableEnabledPlugins();
    if (unavailablePlugins.length > 0) {
      this.settings.enabledPlugins = this.settings.enabledPlugins.filter((id) => !unavailablePlugins.includes(id));
      await this.saveSettings();
      const count = unavailablePlugins.length;
      new import_obsidian29.Notice(`${count} plugin${count > 1 ? "s" : ""} became unavailable and ${count > 1 ? "were" : "was"} disabled`);
    }
    this.loadPluginSlashCommands();
    this.registerView(
      VIEW_TYPE_CLAUDIAN,
      (leaf) => new ClaudianView(leaf, this)
    );
    this.addRibbonIcon("bot", "Open Claudian", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-view",
      name: "Open chat view",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "inline-edit",
      name: "Inline edit",
      editorCallback: async (editor, view) => {
        var _a;
        const selectedText = editor.getSelection();
        const notePath = ((_a = view.file) == null ? void 0 : _a.path) || "unknown";
        let editContext;
        if (selectedText.trim()) {
          editContext = { mode: "selection", selectedText };
        } else {
          const cursor = editor.getCursor();
          const cursorContext = buildCursorContext(
            (line) => editor.getLine(line),
            editor.lineCount(),
            cursor.line,
            cursor.ch
          );
          editContext = { mode: "cursor", cursorContext };
        }
        const modal = new InlineEditModal(this.app, this, editContext, notePath);
        const result = await modal.openAndWait();
        if (result.decision === "accept" && result.editedText !== void 0) {
          new import_obsidian29.Notice(editContext.mode === "cursor" ? "Inserted" : "Edit applied");
        }
      }
    });
    this.addCommand({
      id: "new-tab",
      name: "New tab",
      checkCallback: (checking) => {
        const leaf = this.app.workspace.getLeavesOfType(VIEW_TYPE_CLAUDIAN)[0];
        if (!leaf) return false;
        const view = leaf.view;
        const tabManager = view.getTabManager();
        if (!tabManager) return false;
        if (!tabManager.canCreateTab()) return false;
        if (!checking) {
          tabManager.createTab();
        }
        return true;
      }
    });
    this.addCommand({
      id: "new-session",
      name: "New session (in current tab)",
      checkCallback: (checking) => {
        const leaf = this.app.workspace.getLeavesOfType(VIEW_TYPE_CLAUDIAN)[0];
        if (!leaf) return false;
        const view = leaf.view;
        const tabManager = view.getTabManager();
        if (!tabManager) return false;
        const activeTab = tabManager.getActiveTab();
        if (!activeTab) return false;
        if (activeTab.state.isStreaming) return false;
        if (!checking) {
          tabManager.createNewConversation();
        }
        return true;
      }
    });
    this.addCommand({
      id: "close-current-tab",
      name: "Close current tab",
      checkCallback: (checking) => {
        const leaf = this.app.workspace.getLeavesOfType(VIEW_TYPE_CLAUDIAN)[0];
        if (!leaf) return false;
        const view = leaf.view;
        const tabManager = view.getTabManager();
        if (!tabManager) return false;
        if (!checking) {
          const activeTabId = tabManager.getActiveTabId();
          if (activeTabId) {
            tabManager.closeTab(activeTabId);
          }
        }
        return true;
      }
    });
    this.addSettingTab(new ClaudianSettingTab(this.app, this));
  }
  async onunload() {
    for (const view of this.getAllViews()) {
      const tabManager = view.getTabManager();
      if (tabManager) {
        const state = tabManager.getPersistedState();
        await this.storage.setTabManagerState(state);
      }
    }
  }
  /** Opens the Claudian sidebar view, creating it if necessary. */
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_CLAUDIAN)[0];
    if (!leaf) {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        await rightLeaf.setViewState({
          type: VIEW_TYPE_CLAUDIAN,
          active: true
        });
        leaf = rightLeaf;
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  /** Loads settings and conversations from persistent storage. */
  async loadSettings() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
    this.storage = new StorageService(this);
    const { claudian } = await this.storage.initialize();
    const slashCommands = await this.storage.commands.loadAll();
    this.settings = {
      ...DEFAULT_SETTINGS,
      ...claudian,
      slashCommands
    };
    (_b = (_a = this.settings).claudeCliPathsByHost) != null ? _b : _a.claudeCliPathsByHost = {};
    const hostname3 = getHostnameKey();
    let didMigrateCliPath = false;
    if (!this.settings.claudeCliPathsByHost[hostname3]) {
      const platformPaths = this.settings.claudeCliPaths;
      const migratedPath = ((_c = platformPaths == null ? void 0 : platformPaths[getCliPlatformKey()]) == null ? void 0 : _c.trim()) || ((_d = this.settings.claudeCliPath) == null ? void 0 : _d.trim());
      if (migratedPath) {
        this.settings.claudeCliPathsByHost[hostname3] = migratedPath;
        this.settings.claudeCliPath = "";
        didMigrateCliPath = true;
      }
    }
    delete this.settings.claudeCliPaths;
    const { conversations: legacyConversations, failedCount } = await this.storage.sessions.loadAllConversations();
    const legacyIds = new Set(legacyConversations.map((c) => c.id));
    for (const conversation of legacyConversations) {
      const meta = await this.storage.sessions.loadMetadata(conversation.id);
      if (!meta) continue;
      conversation.isNative = true;
      conversation.title = (_e = meta.title) != null ? _e : conversation.title;
      conversation.titleGenerationStatus = (_f = meta.titleGenerationStatus) != null ? _f : conversation.titleGenerationStatus;
      conversation.createdAt = (_g = meta.createdAt) != null ? _g : conversation.createdAt;
      conversation.updatedAt = (_h = meta.updatedAt) != null ? _h : conversation.updatedAt;
      conversation.lastResponseAt = (_i = meta.lastResponseAt) != null ? _i : conversation.lastResponseAt;
      if (meta.sessionId !== void 0) {
        conversation.sessionId = meta.sessionId;
      }
      conversation.currentNote = (_j = meta.currentNote) != null ? _j : conversation.currentNote;
      conversation.externalContextPaths = (_k = meta.externalContextPaths) != null ? _k : conversation.externalContextPaths;
      conversation.enabledMcpServers = (_l = meta.enabledMcpServers) != null ? _l : conversation.enabledMcpServers;
      conversation.usage = (_m = meta.usage) != null ? _m : conversation.usage;
      if (meta.sdkSessionId !== void 0) {
        conversation.sdkSessionId = meta.sdkSessionId;
      } else if (conversation.sdkSessionId === void 0 && conversation.sessionId) {
        conversation.sdkSessionId = conversation.sessionId;
      }
      conversation.previousSdkSessionIds = (_n = meta.previousSdkSessionIds) != null ? _n : conversation.previousSdkSessionIds;
      conversation.legacyCutoffAt = (_o = meta.legacyCutoffAt) != null ? _o : conversation.legacyCutoffAt;
    }
    const nativeMetadata = await this.storage.sessions.listNativeMetadata();
    const nativeConversations = nativeMetadata.filter((meta) => !legacyIds.has(meta.id)).map((meta) => {
      const resumeSessionId = meta.sessionId !== void 0 ? meta.sessionId : meta.id;
      const sdkSessionId = meta.sdkSessionId !== void 0 ? meta.sdkSessionId : resumeSessionId != null ? resumeSessionId : void 0;
      return {
        id: meta.id,
        title: meta.title,
        createdAt: meta.createdAt,
        updatedAt: meta.updatedAt,
        lastResponseAt: meta.lastResponseAt,
        sessionId: resumeSessionId,
        sdkSessionId,
        previousSdkSessionIds: meta.previousSdkSessionIds,
        messages: [],
        // Messages are in SDK storage, loaded on demand
        currentNote: meta.currentNote,
        externalContextPaths: meta.externalContextPaths,
        enabledMcpServers: meta.enabledMcpServers,
        usage: meta.usage,
        titleGenerationStatus: meta.titleGenerationStatus,
        legacyCutoffAt: meta.legacyCutoffAt,
        isNative: true,
        toolDiffData: meta.toolDiffData
        // Preserve for applying to loaded messages
      };
    });
    this.conversations = [...legacyConversations, ...nativeConversations].sort(
      (a, b) => {
        var _a2, _b2;
        return ((_a2 = b.lastResponseAt) != null ? _a2 : b.updatedAt) - ((_b2 = a.lastResponseAt) != null ? _b2 : a.updatedAt);
      }
    );
    if (failedCount > 0) {
      new import_obsidian29.Notice(`Failed to load ${failedCount} conversation${failedCount > 1 ? "s" : ""}`);
    }
    setLocale(this.settings.locale);
    const backfilledConversations = this.backfillConversationResponseTimestamps();
    this.runtimeEnvironmentVariables = this.settings.environmentVariables || "";
    const { changed, invalidatedConversations } = this.reconcileModelWithEnvironment(this.runtimeEnvironmentVariables);
    if (changed || didMigrateCliPath) {
      await this.saveSettings();
    }
    const conversationsToSave = /* @__PURE__ */ new Set([...backfilledConversations, ...invalidatedConversations]);
    for (const conv of conversationsToSave) {
      if (conv.isNative) {
        await this.storage.sessions.saveMetadata(
          this.storage.sessions.toSessionMetadata(conv)
        );
      } else {
        await this.storage.sessions.saveConversation(conv);
      }
    }
  }
  backfillConversationResponseTimestamps() {
    const updated = [];
    for (const conv of this.conversations) {
      if (conv.lastResponseAt != null) continue;
      if (!conv.messages || conv.messages.length === 0) continue;
      for (let i = conv.messages.length - 1; i >= 0; i--) {
        const msg = conv.messages[i];
        if (msg.role === "assistant") {
          conv.lastResponseAt = msg.timestamp;
          updated.push(conv);
          break;
        }
      }
    }
    return updated;
  }
  /** Persists settings to storage. */
  async saveSettings() {
    const {
      slashCommands: _,
      ...settingsToSave
    } = this.settings;
    await this.storage.saveClaudianSettings(settingsToSave);
  }
  /**
   * Loads slash commands from enabled plugins and merges them with vault commands.
   * Plugin commands are namespaced with the plugin name (e.g., "plugin-name:command").
   */
  loadPluginSlashCommands() {
    const vaultCommands = this.settings.slashCommands.filter(
      (cmd) => !cmd.id.startsWith("plugin-")
    );
    const pluginPaths = this.pluginManager.getPluginCommandPaths();
    const pluginCommands = pluginPaths.flatMap(
      ({ pluginName, commandsPath }) => loadPluginCommands(commandsPath, pluginName)
    );
    this.settings.slashCommands = [...vaultCommands, ...pluginCommands];
  }
  /** Updates and persists environment variables, restarting processes to apply changes. */
  async applyEnvironmentVariables(envText) {
    var _a, _b, _c;
    const envChanged = envText !== this.runtimeEnvironmentVariables;
    this.settings.environmentVariables = envText;
    if (!envChanged) {
      await this.saveSettings();
      return;
    }
    this.runtimeEnvironmentVariables = envText;
    const { changed, invalidatedConversations } = this.reconcileModelWithEnvironment(envText);
    await this.saveSettings();
    if (invalidatedConversations.length > 0) {
      for (const conv of invalidatedConversations) {
        if (conv.isNative) {
          await this.storage.sessions.saveMetadata(
            this.storage.sessions.toSessionMetadata(conv)
          );
        } else {
          await this.storage.sessions.saveConversation(conv);
        }
      }
    }
    const view = this.getView();
    const tabManager = view == null ? void 0 : view.getTabManager();
    if (tabManager) {
      for (const tab of tabManager.getAllTabs()) {
        if (tab.state.isStreaming) {
          (_a = tab.controllers.inputController) == null ? void 0 : _a.cancelStreaming();
        }
      }
      let failedTabs = 0;
      if (changed) {
        for (const tab of tabManager.getAllTabs()) {
          if (!tab.service || !tab.serviceInitialized) {
            continue;
          }
          try {
            const externalContextPaths = (_c = (_b = tab.ui.externalContextSelector) == null ? void 0 : _b.getExternalContexts()) != null ? _c : [];
            tab.service.resetSession();
            await tab.service.ensureReady({ externalContextPaths });
          } catch (e) {
            failedTabs++;
          }
        }
      } else {
        try {
          await tabManager.broadcastToAllTabs(
            async (service) => {
              await service.ensureReady({ force: true });
            }
          );
        } catch (e) {
          failedTabs++;
        }
      }
      if (failedTabs > 0) {
        new import_obsidian29.Notice(`Environment changes applied, but ${failedTabs} tab(s) failed to restart.`);
      }
    }
    view == null ? void 0 : view.refreshModelSelector();
    const noticeText = changed ? "Environment variables applied. Sessions will be rebuilt on next message." : "Environment variables applied.";
    new import_obsidian29.Notice(noticeText);
  }
  /** Returns the runtime environment variables (fixed at plugin load). */
  getActiveEnvironmentVariables() {
    return this.runtimeEnvironmentVariables;
  }
  getResolvedClaudeCliPath() {
    return this.cliResolver.resolve(
      this.settings.claudeCliPathsByHost,
      // Per-device paths (preferred)
      this.settings.claudeCliPath,
      // Legacy path (fallback)
      this.getActiveEnvironmentVariables()
    );
  }
  getDefaultModelValues() {
    return DEFAULT_CLAUDE_MODELS.map((m) => m.value);
  }
  getPreferredCustomModel(envVars, customModels) {
    const envPreferred = getCurrentModelFromEnvironment(envVars);
    if (envPreferred && customModels.some((m) => m.value === envPreferred)) {
      return envPreferred;
    }
    return customModels[0].value;
  }
  /** Computes a hash of model and provider base URL environment variables for change detection. */
  computeEnvHash(envText) {
    const envVars = parseEnvironmentVariables(envText || "");
    const modelKeys = [
      "ANTHROPIC_MODEL",
      "ANTHROPIC_DEFAULT_OPUS_MODEL",
      "ANTHROPIC_DEFAULT_SONNET_MODEL",
      "ANTHROPIC_DEFAULT_HAIKU_MODEL"
    ];
    const providerKeys = [
      "ANTHROPIC_BASE_URL"
    ];
    const allKeys = [...modelKeys, ...providerKeys];
    const relevantPairs = allKeys.filter((key) => envVars[key]).map((key) => `${key}=${envVars[key]}`).sort().join("|");
    return relevantPairs;
  }
  /**
   * Reconciles model with environment.
   * Returns { changed, invalidatedConversations } where changed indicates if
   * settings were modified (requiring save), and invalidatedConversations lists
   * conversations that had their sessionId cleared (also requiring save).
   */
  reconcileModelWithEnvironment(envText) {
    const currentHash = this.computeEnvHash(envText);
    const savedHash = this.settings.lastEnvHash || "";
    if (currentHash === savedHash) {
      return { changed: false, invalidatedConversations: [] };
    }
    clearDiffState();
    const invalidatedConversations = [];
    for (const conv of this.conversations) {
      if (conv.sessionId) {
        conv.sessionId = null;
        invalidatedConversations.push(conv);
      }
    }
    const envVars = parseEnvironmentVariables(envText || "");
    const customModels = getModelsFromEnvironment(envVars);
    if (customModels.length > 0) {
      this.settings.model = this.getPreferredCustomModel(envVars, customModels);
    } else {
      this.settings.model = DEFAULT_CLAUDE_MODELS[0].value;
    }
    this.settings.lastEnvHash = currentHash;
    return { changed: true, invalidatedConversations };
  }
  generateConversationId() {
    return `conv-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
  }
  generateDefaultTitle() {
    const now = /* @__PURE__ */ new Date();
    return now.toLocaleString(void 0, {
      month: "short",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });
  }
  getConversationPreview(conv) {
    const firstUserMsg = conv.messages.find((m) => m.role === "user");
    if (!firstUserMsg) {
      return conv.isNative ? "SDK session" : "New conversation";
    }
    return firstUserMsg.content.substring(0, 50) + (firstUserMsg.content.length > 50 ? "..." : "");
  }
  async loadSdkMessagesForConversation(conversation) {
    var _a;
    if (!conversation.isNative || conversation.sdkMessagesLoaded) return;
    const vaultPath = getVaultPath(this.app);
    if (!vaultPath) return;
    const allSessionIds = [
      ...conversation.previousSdkSessionIds || [],
      (_a = conversation.sdkSessionId) != null ? _a : conversation.sessionId
    ].filter((id) => !!id);
    if (allSessionIds.length === 0) return;
    const allSdkMessages = [];
    let totalSkippedLines = 0;
    let missingSessionCount = 0;
    let errorCount = 0;
    let successCount = 0;
    for (const sessionId of allSessionIds) {
      if (!sdkSessionExists(vaultPath, sessionId)) {
        missingSessionCount++;
        continue;
      }
      const result = await loadSDKSessionMessages(vaultPath, sessionId);
      if (result.error) {
        errorCount++;
        continue;
      }
      successCount++;
      totalSkippedLines += result.skippedLines;
      allSdkMessages.push(...result.messages);
    }
    if (missingSessionCount > 0 || errorCount > 0) {
      const parts = [];
      if (missingSessionCount > 0) {
        parts.push(`${missingSessionCount} session file(s) not found`);
      }
      if (errorCount > 0) {
        parts.push(`${errorCount} failed to load`);
      }
      new import_obsidian29.Notice(`Conversation history incomplete: ${parts.join(", ")}`);
    }
    if (totalSkippedLines > 0) {
      new import_obsidian29.Notice(`Some messages could not be loaded (${totalSkippedLines} corrupted)`);
    }
    const allSessionsMissing = missingSessionCount === allSessionIds.length;
    const hasLoadErrors = errorCount > 0 && successCount === 0 && !allSessionsMissing;
    if (hasLoadErrors) {
      return;
    }
    const filteredSdkMessages = allSdkMessages.filter((msg) => !msg.isRebuiltContext);
    const afterCutoff = conversation.legacyCutoffAt != null ? filteredSdkMessages.filter((msg) => msg.timestamp > conversation.legacyCutoffAt) : filteredSdkMessages;
    const merged = this.dedupeMessages([
      ...conversation.messages,
      ...afterCutoff
    ]).sort((a, b) => a.timestamp - b.timestamp);
    if (conversation.toolDiffData) {
      this.applyToolDiffData(merged, conversation.toolDiffData);
    }
    conversation.messages = merged;
    conversation.sdkMessagesLoaded = true;
  }
  /**
   * Applies cached toolDiffData to messages.
   * Restores diffData on tool calls so Write/Edit can show +/- stats.
   */
  applyToolDiffData(messages, toolDiffData) {
    for (const msg of messages) {
      if (msg.role !== "assistant" || !msg.toolCalls) continue;
      for (const toolCall of msg.toolCalls) {
        const diffData = toolDiffData[toolCall.id];
        if (diffData && !toolCall.diffData) {
          toolCall.diffData = diffData;
        }
      }
    }
  }
  dedupeMessages(messages) {
    const seen = /* @__PURE__ */ new Set();
    const result = [];
    for (const message of messages) {
      if (seen.has(message.id)) continue;
      seen.add(message.id);
      result.push(message);
    }
    return result;
  }
  /**
   * Creates a new conversation and sets it as active.
   *
   * New conversations always use SDK-native storage.
   * The session ID may be captured after the first SDK response.
   */
  async createConversation(sessionId) {
    const conversationId = sessionId != null ? sessionId : this.generateConversationId();
    const conversation = {
      id: conversationId,
      title: this.generateDefaultTitle(),
      createdAt: Date.now(),
      updatedAt: Date.now(),
      sessionId: sessionId != null ? sessionId : null,
      sdkSessionId: sessionId != null ? sessionId : void 0,
      messages: [],
      isNative: true
    };
    this.conversations.unshift(conversation);
    clearDiffState();
    await this.storage.sessions.saveMetadata(
      this.storage.sessions.toSessionMetadata(conversation)
    );
    return conversation;
  }
  /**
   * Switches to an existing conversation by ID.
   *
   * For native sessions, loads messages from SDK storage if not already loaded.
   */
  async switchConversation(id) {
    const conversation = this.conversations.find((c) => c.id === id);
    if (!conversation) return null;
    await this.loadSdkMessagesForConversation(conversation);
    clearDiffState();
    return conversation;
  }
  /**
   * Deletes a conversation and resets any tabs using it.
   *
   * For native sessions, deletes the metadata file and SDK session file.
   * For legacy sessions, deletes the JSONL file.
   */
  async deleteConversation(id) {
    var _a, _b, _c;
    const index = this.conversations.findIndex((c) => c.id === id);
    if (index === -1) return;
    const conversation = this.conversations[index];
    this.conversations.splice(index, 1);
    const vaultPath = getVaultPath(this.app);
    const sdkSessionId = (_a = conversation.sdkSessionId) != null ? _a : conversation.sessionId;
    if (vaultPath && sdkSessionId) {
      await deleteSDKSession(vaultPath, sdkSessionId);
    }
    if (conversation.isNative) {
      await this.storage.sessions.deleteMetadata(id);
    } else {
      await this.storage.sessions.deleteConversation(id);
    }
    for (const view of this.getAllViews()) {
      const tabManager = view.getTabManager();
      if (!tabManager) continue;
      for (const tab of tabManager.getAllTabs()) {
        if (tab.conversationId === id) {
          (_b = tab.controllers.inputController) == null ? void 0 : _b.cancelStreaming();
          await ((_c = tab.controllers.conversationController) == null ? void 0 : _c.createNew({ force: true }));
        }
      }
    }
  }
  /** Renames a conversation. */
  async renameConversation(id, title) {
    const conversation = this.conversations.find((c) => c.id === id);
    if (!conversation) return;
    conversation.title = title.trim() || this.generateDefaultTitle();
    conversation.updatedAt = Date.now();
    if (conversation.isNative) {
      await this.storage.sessions.saveMetadata(
        this.storage.sessions.toSessionMetadata(conversation)
      );
    } else {
      await this.storage.sessions.saveConversation(conversation);
    }
  }
  /**
   * Updates conversation properties.
   *
   * For native sessions, saves metadata only (SDK handles messages including images).
   * For legacy sessions, saves full JSONL.
   *
   * Image data is cleared from memory after save (SDK/JSONL has persisted it).
   */
  async updateConversation(id, updates) {
    const conversation = this.conversations.find((c) => c.id === id);
    if (!conversation) return;
    Object.assign(conversation, updates, { updatedAt: Date.now() });
    if (conversation.isNative) {
      await this.storage.sessions.saveMetadata(
        this.storage.sessions.toSessionMetadata(conversation)
      );
    } else {
      await this.storage.sessions.saveConversation(conversation);
    }
    for (const msg of conversation.messages) {
      if (msg.images) {
        for (const img of msg.images) {
          img.data = "";
        }
      }
    }
  }
  /**
   * Gets a conversation by ID from the in-memory cache.
   *
   * For native sessions, loads messages from SDK storage if not already loaded.
   */
  async getConversationById(id) {
    const conversation = this.conversations.find((c) => c.id === id) || null;
    if (conversation) {
      await this.loadSdkMessagesForConversation(conversation);
    }
    return conversation;
  }
  /**
   * Gets a conversation by ID without loading SDK messages.
   * Use this for UI code that only needs metadata (title, etc.).
   */
  getConversationSync(id) {
    return this.conversations.find((c) => c.id === id) || null;
  }
  /** Finds an existing empty conversation (no messages). */
  findEmptyConversation() {
    return this.conversations.find((c) => c.messages.length === 0) || null;
  }
  /** Returns conversation metadata list for the history dropdown. */
  getConversationList() {
    return this.conversations.map((c) => ({
      id: c.id,
      title: c.title,
      createdAt: c.createdAt,
      updatedAt: c.updatedAt,
      lastResponseAt: c.lastResponseAt,
      messageCount: c.messages.length,
      preview: this.getConversationPreview(c),
      titleGenerationStatus: c.titleGenerationStatus,
      isNative: c.isNative
    }));
  }
  /** Returns the active Claudian view from workspace, if open. */
  getView() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_CLAUDIAN);
    if (leaves.length > 0) {
      return leaves[0].view;
    }
    return null;
  }
  /** Returns all open Claudian views in the workspace. */
  getAllViews() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_CLAUDIAN);
    return leaves.map((leaf) => leaf.view);
  }
  /**
   * Checks if a conversation is open in any Claudian view.
   * Returns the view and tab if found, null otherwise.
   */
  findConversationAcrossViews(conversationId) {
    for (const view of this.getAllViews()) {
      const tabManager = view.getTabManager();
      if (!tabManager) continue;
      const tabs = tabManager.getAllTabs();
      for (const tab of tabs) {
        if (tab.conversationId === conversationId) {
          return { view, tabId: tab.id };
        }
      }
    }
    return null;
  }
};
